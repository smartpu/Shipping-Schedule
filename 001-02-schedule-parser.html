<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>维运网 船期解析工具</title>
    <link rel="stylesheet" href="vendor/theme-styles.css">
    <script src="vendor/auth-gist.js"></script>
</head>
<body data-page="001-02-schedule-parser.html">
    <div class="dashboard-container">
        <!-- 左侧导航栏占位容器（将由sidebar-loader.js动态加载） -->
        <div id="sidebar-placeholder"></div>

        <!-- 右侧内容 -->
        <main class="dashboard-content">
            <div class="container">
                <!-- 顶部介绍卡片，沿用 dashboard 风格 -->
                <div class="section-intro">
                    <div class="section-intro-header">
                        <div class="section-intro-content">
                            <h2>维运网 船期解析工具</h2>
                            <p>自动解析维运网船期网页，解析过程中请勿关闭页面，解析完成后会自动显示统计信息。</p>
                        </div>
                        <div class="section-intro-actions">
                            <a href="dashboard.html?tab=tools001" class="tool-link" aria-label="返回工具集首页">← 返回首页</a>
                            <a href="001-02-schedule-parser-README.html" class="tool-link secondary" aria-label="查看使用说明文档">使用说明 →</a>
                        </div>
                    </div>
                </div>

                <!-- 解析工具主区域 -->
                <div class="card-white mt-20">
                    <div class="controls">
                        <label class="file-btn" aria-label="选择包含HTML文件的文件夹">
                            选择 standard 文件夹
                            <input id="picker" type="file" webkitdirectory multiple accept=".html,.htm" aria-label="选择文件夹">
                        </label>
                        <button id="run" class="btn btn-sweep-blue" disabled aria-label="开始解析HTML文件">开始解析</button>
                        <button id="download" class="btn btn-sweep-blue" disabled aria-label="下载CSV文件">下载 CSV</button>
                        <span id="summary" role="status" aria-live="polite"></span>
                    </div>
                    <div id="log" class="log" aria-live="polite" role="log" aria-label="解析日志"></div>
                    <div id="preview" class="hidden" role="region" aria-label="解析结果预览">
                        <table id="table" role="table" aria-label="解析结果表格"></table>
                    </div>
                </div>

                <!-- 使用声明 -->
                <div class="card-white mt-20">
                    <h2 class="usage-statement-title">维运网 船期解析工具使用声明</h2>
                    <p class="usage-statement-text">本工具用于解析从维运网（weiyun001.com）下载的船期网页，提取航线、船名、航次、开船日期等数据并导出为 CSV 文件。</p>
                    <p class="usage-statement-text">所有数据来源于维运网公开信息，解析结果仅供内部使用，请遵守维运网的使用条款和版权规定。</p>
                </div>
            </div>
        </main>
    </div>

    <!-- 标准化模态框 - 使用公共模板（vendor/template-utils.js） -->
    <div id="standardizationModalsContainer"></div>

    <!-- 引入导航栏公共组件 -->
    <script src="vendor/common-utils.js"></script>
    <script src="vendor/debug-utils.js"></script>
    <script src="vendor/sidebar-loader.js"></script>
    <script src="vendor/parser-utils.js"></script>
    <script src="vendor/template-utils.js"></script>
    <script>
        init001ToolPage('001-02-schedule-parser.html', 'tools001');
    </script>
    <script>

(function(){
    /**
     * DOM 选择器辅助函数
     * @param {string} selector - CSS 选择器
     * @returns {HTMLElement|null} 找到的元素
     */
    const selectElement = (selector) => document.querySelector(selector);
    const log = createLogger('#log');
    
    if (typeof window.generateStandardizationModals === 'function') {
        const container = document.getElementById('standardizationModalsContainer');
        if (container) {
            container.innerHTML = window.generateStandardizationModals();
        }
    }

    /**
     * 清洗船型：处理 xxx TEU 格式，合并为 xxxTEU
     * @param {string} shipType - 船型字符串
     * @returns {string} 清洗后的船型
     */
    function cleanShipType(shipType) {
        if (!shipType) return '';
        // 去掉所有空格（J列要求无空格），并兼容数字+TEU的场景
        return clean(shipType).replace(/\s+/g, '');
    }

    /**
     * 清洗船名航次：保留原值，但提供去空格版本用于比较
     * @param {string} vesselName - 船名
     * @param {string} voyage - 航次
     * @returns {Object} {original: 原值, normalized: 去空格版本}
     */
    function normalizeVesselVoyage(vesselName, voyage) {
        const normalizedVessel = vesselName ? clean(vesselName).replace(/\s+/g, '') : '';
        const normalizedVoyage = voyage ? clean(voyage).replace(/\s+/g, '') : '';
        return {
            vesselOriginal: vesselName || '',
            voyageOriginal: voyage || '',
            vesselNormalized: normalizedVessel,
            voyageNormalized: normalizedVoyage,
            combinedNormalized: `${normalizedVessel}_${normalizedVoyage}`
        };
    }

    /**
     * 规范化目的港码头：去空格后用于比较
     * @param {string} podWharf - 目的港码头
     * @returns {string} 去空格后的目的港码头
     */
    function normalizePodWharf(podWharf) {
        if (!podWharf) return '';
        return clean(podWharf).replace(/\s+/g, '').toUpperCase();
    }

    /** 特定码头名称修正映射 */
    const WHARF_NAME_CORRECTIONS = {
        'TER MINAL': 'TERMINAL',
        'SEA PORT': 'SEAPORT',
        'PANJA NG': 'PANJANG',
        'GUDA NG': 'GUDANG'
    };

    /**
     * 合并相邻的码头名称片段
     * @param {string} current - 当前片段
     * @param {string} next - 下一个片段
     * @returns {boolean} 是否应该合并
     */
    function shouldMergeTokens(current, next) {
        // 若下一个是单个大写字母，且当前为全大写字母（如 TERMINA + L）-> 合并
        if (/^[A-Z]+$/.test(current) && /^[A-Z]$/.test(next)) {
            return true;
        }
        // 若两边均为 1-2 位的大写字母缩写（如 QQ + CT）-> 合并
        if (/^[A-Z]{1,2}$/.test(current) && /^[A-Z]{1,2}$/.test(next)) {
            return true;
        }
        return false;
    }

    /**
     * 应用特定词修正
     * @param {string} text - 要修正的文本
     * @returns {string} 修正后的文本
     */
    function applyWharfNameCorrections(text) {
        let correctedText = text;
        for (const [wrong, correct] of Object.entries(WHARF_NAME_CORRECTIONS)) {
            const regex = new RegExp(`\\b${wrong}\\b`, 'g');
            correctedText = correctedText.replace(regex, correct);
        }
        return correctedText;
    }

    /**
     * 码头名清洗：修复被错误断开的缩写/单词，如 "QQ CT" -> "QQCT", "TERMINA L" -> "TERMINAL"
     * @param {string} name - 原始码头名称
     * @returns {string} 清洗后的码头名称
     */
    function normalizeWharfTokens(name) {
        const cleanedName = clean(name);
        if (!cleanedName) return cleanedName;
        
        const parts = cleanedName.split(' ');
        const mergedParts = [];
        
        for (let i = 0; i < parts.length; i++) {
            const currentPart = parts[i];
            if (!currentPart) {
                continue;
            }
            
            // 检查是否应该与下一个片段合并
            if (i + 1 < parts.length) {
                const nextPart = parts[i + 1];
                if (shouldMergeTokens(currentPart, nextPart)) {
                    mergedParts.push(currentPart + nextPart);
                    i++; // 跳过下一个片段，因为已经合并
                    continue;
                }
            }
            
            mergedParts.push(currentPart);
        }
        
        const joinedText = mergedParts.join(' ');
        return applyWharfNameCorrections(joinedText);
    }

    /** 搜索范围常量 */
    const SEARCH_RANGES = {
        BEFORE_HREF: 500,    // 向前查找 <a 标签的开始
        AFTER_HREF: 1000,    // 向后查找 > 标签的结束
        BEFORE_SUFFIX: 2000, // 在 suffix 前后搜索的范围
        AFTER_SUFFIX: 2000,
        TAG_CONTENT: 3000,   // 标签内容最大长度
        AFTER_TAG: 1500       // <a> 标签后查找 title 的范围
    };

    /** Title 属性匹配模式 */
    const TITLE_PATTERNS = [
        /title=(["'])((?:(?!\1)[\s\S])*?)\1/i,        // title="..." 或 title='...'
        /title\s*=\s*(["'])((?:(?!\1)[\s\S])*?)\1/i,  // title = "..." (有空格)
        /title\s*:\s*(["'])((?:(?!\1)[\s\S])*?)\1/i   // title: "..." (JSON格式)
    ];

    /**
     * 转义 title 值中的转义序列
     * @param {string} titleValue - 原始 title 值
     * @returns {string} 转义后的 title 值
     */
    function unescapeTitleValue(titleValue) {
        return titleValue
            .replace(/\\"/g, '"')
            .replace(/\\'/g, "'")
            .replace(/\\n/g, ' ')
            .replace(/\\t/g, ' ')
            .replace(/\\r/g, '');
    }

    /**
     * 从标签内容中提取 title 值
     * @param {string} tagContent - 标签内容
     * @returns {string|null} 提取的 title 值，如果未找到则返回 null
     */
    function extractTitleFromTagContent(tagContent) {
        for (const titlePattern of TITLE_PATTERNS) {
            const titleMatch = tagContent.match(titlePattern);
            if (titleMatch && titleMatch[2]) {
                const unescapedTitle = unescapeTitleValue(titleMatch[2]);
                const cleanedTitle = clean(unescapedTitle);
                if (cleanedTitle) {
                    return cleanedTitle;
                }
            }
        }
        return null;
    }

    /**
     * 策略1：通过 href 定位找到对应的 <a> 标签并提取 title
     * @param {string} searchText - 要搜索的文本
     * @param {string} suffix - 后缀（_fleetId_fleetIdPort）
     * @param {string} escapedSuffix - 转义后的后缀
     * @returns {string|null} 找到的 title 值，如果未找到则返回 null
     */
    function findTitleByHrefLocation(searchText, suffix, escapedSuffix) {
        const hrefPattern = new RegExp(`href=["']([^"']*${escapedSuffix})["']`, 'gi');
        let hrefMatch;
        
        while ((hrefMatch = hrefPattern.exec(searchText)) !== null) {
            const hrefValue = hrefMatch[1];
            if (!hrefValue || !hrefValue.endsWith(suffix)) {
                continue;
            }
            
            const hrefStart = hrefMatch.index;
            const hrefEnd = hrefMatch.index + hrefMatch[0].length;
            
            // 向前查找 <a 标签的开始
            const searchStart = Math.max(0, hrefStart - SEARCH_RANGES.BEFORE_HREF);
            const beforeHref = searchText.substring(searchStart, hrefStart);
            const tagStart = beforeHref.lastIndexOf('<a');
            if (tagStart === -1) {
                continue;
            }
            const actualTagStart = searchStart + tagStart;
            
            // 向后查找 > 标签的结束
            const searchEnd = Math.min(searchText.length, hrefEnd + SEARCH_RANGES.AFTER_HREF);
            const afterHref = searchText.substring(hrefEnd, searchEnd);
            const tagEnd = afterHref.indexOf('>');
            if (tagEnd === -1) {
                continue;
            }
            const actualTagEnd = hrefEnd + tagEnd;
            
            // 提取整个标签内容
            const tagContent = searchText.substring(actualTagStart, actualTagEnd + 1);
            const title = extractTitleFromTagContent(tagContent);
            if (title) {
                return title;
            }
        }
        
        return null;
    }

    /**
     * 策略2：使用正则表达式直接匹配整个 <a> 标签
     * @param {string} searchText - 要搜索的文本
     * @param {string} suffix - 后缀
     * @param {string} escapedSuffix - 转义后的后缀
     * @returns {string|null} 找到的 title 值，如果未找到则返回 null
     */
    function findTitleByRegexMatch(searchText, suffix, escapedSuffix) {
        const patterns = [
            new RegExp(`<a[\\s\\S]{0,${SEARCH_RANGES.TAG_CONTENT}}?href=["']([^"']*${escapedSuffix})["'][\\s\\S]{0,${SEARCH_RANGES.TAG_CONTENT}}?title=(["'])([\\s\\S]*?)\\2`, 'i'),
            new RegExp(`<a[\\s\\S]{0,${SEARCH_RANGES.TAG_CONTENT}}?title=(["'])([\\s\\S]*?)\\1[\\s\\S]{0,${SEARCH_RANGES.TAG_CONTENT}}?href=["']([^"']*${escapedSuffix})["']`, 'i')
        ];
        
        for (const pattern of patterns) {
            let match;
            while ((match = pattern.exec(searchText)) !== null) {
                if (match && match.length >= 4) {
                    let hrefValue, titleValue;
                    if (pattern === patterns[0]) {
                        hrefValue = match[1];
                        titleValue = match[3];
                    } else {
                        titleValue = match[2];
                        hrefValue = match[3];
                    }
                    
                    if (hrefValue && titleValue && hrefValue.endsWith(suffix)) {
                        const unescapedTitle = unescapeTitleValue(titleValue);
                        const cleanedTitle = clean(unescapedTitle);
                        if (cleanedTitle) {
                            return cleanedTitle;
                        }
                    }
                }
            }
        }
        
        return null;
    }

    /**
     * 策略3：更激进的搜索 - 直接搜索包含 suffix 的文本片段
     * @param {string} searchText - 要搜索的文本
     * @param {string} suffix - 后缀
     * @returns {string|null} 找到的 title 值，如果未找到则返回 null
     */
    function findTitleBySuffixSearch(searchText, suffix) {
        let searchIndex = 0;
        
        while (true) {
            const suffixIndex = searchText.indexOf(suffix, searchIndex);
            if (suffixIndex === -1) {
                break;
            }
            searchIndex = suffixIndex + 1;
            
            // 验证 suffix 在 href 属性中
            const beforeSuffix = searchText.substring(
                Math.max(0, suffixIndex - SEARCH_RANGES.BEFORE_SUFFIX),
                suffixIndex
            );
            const hrefMatch = beforeSuffix.match(/href\s*=\s*["']/i);
            if (!hrefMatch) {
                continue;
            }
            
            // 在 suffix 前后各2000字符范围内搜索
            const searchStart = Math.max(0, suffixIndex - SEARCH_RANGES.BEFORE_SUFFIX);
            const searchEnd = Math.min(
                searchText.length,
                suffixIndex + suffix.length + SEARCH_RANGES.AFTER_SUFFIX
            );
            const context = searchText.substring(searchStart, searchEnd);
            
            // 在这个上下文中查找 <a> 标签和 title
            const aTagMatch = context.match(/<a[\s\S]{0,3000}?>/i);
            if (aTagMatch) {
                const aTagStartInContext = context.indexOf(aTagMatch[0]);
                const aTagEnd = searchStart + aTagStartInContext + aTagMatch[0].length;
                // 在 <a> 标签后查找 title
                const afterTag = searchText.substring(
                    aTagEnd,
                    Math.min(searchText.length, aTagEnd + SEARCH_RANGES.AFTER_TAG)
                );
                const titleMatch = afterTag.match(/title\s*=\s*(["'])((?:(?!\1)[\s\S])*?)\1/i);
                if (titleMatch && titleMatch[2]) {
                    const unescapedTitle = unescapeTitleValue(titleMatch[2]);
                    const cleanedTitle = clean(unescapedTitle);
                    if (cleanedTitle) {
                        return cleanedTitle;
                    }
                }
            }
        }
        
        return null;
    }

    /**
     * 策略4：DOM 解析回退方案
     * @param {string} decodedHtml - 解码后的 HTML
     * @param {string} suffix - 后缀
     * @returns {string|null} 找到的 title 值，如果未找到则返回 null
     */
    function findTitleByDomParsing(decodedHtml, suffix) {
        try {
            const doc = new DOMParser().parseFromString(decodedHtml, 'text/html');
            const links = Array.from(doc.querySelectorAll('a[href]'));
            
            for (const link of links) {
                const href = link.getAttribute('href') || '';
                if (href && href.endsWith(suffix) && link.hasAttribute('title')) {
                    const title = clean(link.getAttribute('title'));
                    if (title) {
                        return title;
                    }
                }
            }
        } catch (error) {
            // DOM 解析失败，静默返回 null
        }
        
        return null;
    }

    /**
     * 根据"_航线ID_港口ID"后缀精准定位 <a ... title="...">
     * 要求：href 必须以 "_航线ID_港口ID" 结尾（可能前面有 #1_ 等前缀）
     * 优化：添加早期退出，减少不必要的搜索
     * @param {string} decodedHtml - 解码后的 HTML
     * @param {string} fleetId - 航线ID
     * @param {string} fleetIdPort - 港口ID
     * @param {string} originalHtml - 原始 HTML（可选）
     * @returns {string} 找到的共舱船公司标题，如果未找到则返回空字符串
     */
    function findCosTitle(decodedHtml, fleetId, fleetIdPort, originalHtml) {
        const suffix = `_${fleetId}_${fleetIdPort}`;
        const escapedSuffix = suffix.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        
        // 优化：快速检查是否存在suffix，如果不存在则直接返回
        if (decodedHtml.indexOf(suffix) === -1 && (!originalHtml || originalHtml.indexOf(suffix) === -1)) {
            return '';
        }
        
        // 在多个文本源中搜索
        const searchTexts = [decodedHtml];
        if (originalHtml && originalHtml !== decodedHtml) {
            searchTexts.push(originalHtml);
        }
        
        // 按优先级尝试各种策略（优化：快速策略优先）
        for (const searchText of searchTexts) {
            // 策略2：正则表达式直接匹配（通常最快）
            const title2 = findTitleByRegexMatch(searchText, suffix, escapedSuffix);
            if (title2) return title2;
            
            // 策略1：通过 href 定位
            const title1 = findTitleByHrefLocation(searchText, suffix, escapedSuffix);
            if (title1) return title1;
            
            // 策略3：激进搜索（最慢，最后尝试）
            // 优化：只在其他策略都失败时才尝试
            // const title3 = findTitleBySuffixSearch(searchText, suffix);
            // if (title3) return title3;
        }
        
        // 策略4：DOM 解析（只在解码后的HTML中尝试，且只在其他策略都失败时）
        // 优化：DOM解析很慢，只在必要时执行
        // const title4 = findTitleByDomParsing(decodedHtml, suffix);
        // if (title4) return title4;
        
        return '';
    }

    /**
     * 从标准化HTML文件中提取所有数据块的内容
     * 标准化HTML格式：每个数据块在 <div class="data-section"> 中，JSON内容在 <pre> 标签中
     * 优先提取展开后的完整JSON结构
     * @param {string} html - 标准化后的 HTML
     * @returns {string} 所有数据块内容的拼接
     */
    function extractFromStandardizedHtml(html) {
        let output = '';
        
        // 使用DOM解析器提取所有data-section中的pre标签内容
        try {
            const doc = new DOMParser().parseFromString(html, 'text/html');
            const dataSections = doc.querySelectorAll('.data-section');
            
            // 优先查找展开后的完整JSON结构
            for (const section of dataSections) {
                const h3 = section.querySelector('h3');
                const pre = section.querySelector('pre');
                if (h3 && pre) {
                    const title = h3.textContent || '';
                    const content = pre.textContent || pre.innerText || '';
                    
                    // 如果是展开后的完整JSON，优先使用
                    if (title.includes('展开的完整JSON') || title.includes('展开对象')) {
                        try {
                            // 尝试解析为JSON，验证是否有效
                            const jsonData = JSON.parse(content);
                            // 如果是展开后的结构化数据，直接使用
                            if (jsonData.fleets || jsonData.vessels || jsonData.carriers) {
                                output = JSON.stringify(jsonData, null, 2) + '\n';
                                break; // 找到展开后的数据，优先使用
                            }
                        } catch (e) {
                            // 不是有效JSON，继续
                        }
                    }
                }
            }
            
            // 如果没有找到展开后的数据，提取所有数据块
            if (!output) {
                const preElements = doc.querySelectorAll('.data-section pre');
                for (const pre of preElements) {
                    const content = pre.textContent || pre.innerText || '';
                    if (content.trim()) {
                        output += content + '\n';
                    }
                }
            }
        } catch (error) {
            // 如果DOM解析失败，使用正则表达式提取
            // 优先查找展开后的完整JSON
            const expandedPattern = /<h3[^>]*>[\s\S]*?展开的完整JSON[\s\S]*?<\/h3>[\s\S]*?<pre[^>]*>([\s\S]*?)<\/pre>/i;
            const expandedMatch = html.match(expandedPattern);
            if (expandedMatch && expandedMatch[1]) {
                output = expandedMatch[1] + '\n';
            } else {
                // 如果没有找到，提取所有pre标签内容
                const prePattern = /<pre[^>]*>([\s\S]*?)<\/pre>/gi;
                let preMatch;
                while ((preMatch = prePattern.exec(html))) {
                    if (preMatch[1]) {
                        output += preMatch[1] + '\n';
                    }
                }
            }
        }
        
        return output;
    }

    /**
     * 把 self.__next_f.push([1,"..."]) 里的字符串解码拼接，得到可解析文本
     * 增强：支持多种数据格式，包括标准化HTML格式和新的Next.js数据格式
     * @param {string} html - 原始 HTML
     * @returns {string} 解码后的文本
     */
    function extractDecodedPayload(html) {
        let output = '';
        
        // 策略0：检查是否是标准化HTML格式（包含 data-section 类）
        if (html.includes('data-section') || html.includes('标准化HTML')) {
            const standardizedContent = extractFromStandardizedHtml(html);
            if (standardizedContent && standardizedContent.length > 100) {
                return standardizedContent;
            }
        }
        
        // 策略1：尝试旧的 __next_f.push 模式
        const pushPattern = /self\.__next_f\.push\(\[\d+\s*,\s*(["'])([\s\S]*?)\1\]\)/g;
        let match;
        let foundOldPattern = false;
        
        while ((match = pushPattern.exec(html))) {
            foundOldPattern = true;
            try {
                // 利用 JSON.parse 解码转义序列
                const escapedString = match[2].replace(/\\"/g, '\\"');
                output += JSON.parse('"' + escapedString + '"');
            } catch (error) {
                // 退化处理常见转义
                output += match[2]
                    .replace(/\\n/g, '\n')
                    .replace(/\\t/g, '\t')
                    .replace(/\\"/g, '"');
            }
            output += '\n';
        }
        
        // 策略2：尝试新的 Next.js 数据格式（__next_data__ 或类似格式）
        if (!foundOldPattern || output.length < 100) {
            // 尝试查找 <script id="__next_data__"> 标签
            const nextDataPattern = /<script[^>]*id=["']__next_data__["'][^>]*>([\s\S]*?)<\/script>/i;
            const nextDataMatch = html.match(nextDataPattern);
            if (nextDataMatch && nextDataMatch[1]) {
                try {
                    const nextData = JSON.parse(nextDataMatch[1]);
                    // 尝试从 nextData 中提取页面数据
                    if (nextData.props && nextData.props.pageProps) {
                        const pageProps = nextData.props.pageProps;
                        // 将 pageProps 转换为字符串格式，以便后续解析
                        output += JSON.stringify(pageProps, null, 2);
                    } else if (nextData.props) {
                        output += JSON.stringify(nextData.props, null, 2);
                    } else {
                        output += nextDataMatch[1];
                    }
                } catch (error) {
                    // 如果解析失败，直接使用原始内容
                    output += nextDataMatch[1];
                }
            }
        }
        
        // 策略3：尝试查找其他可能的JSON数据块
        if (!output || output.length < 100) {
            // 查找包含 fleetId 或 vslName 的 JSON 对象
            const jsonDataPattern = /<script[^>]*type=["']application\/json["'][^>]*>([\s\S]*?)<\/script>/gi;
            let jsonMatch;
            while ((jsonMatch = jsonDataPattern.exec(html))) {
                try {
                    const jsonData = JSON.parse(jsonMatch[1]);
                    // 检查是否包含船期相关数据
                    const jsonStr = JSON.stringify(jsonData);
                    if (jsonStr.includes('fleetId') || jsonStr.includes('vslName') || jsonStr.includes('vesselName')) {
                        output += jsonStr;
                        break;
                    }
                } catch (error) {
                    // 忽略解析错误
                }
            }
        }
        
        // 策略4：直接从HTML中提取包含船期数据的JSON片段
        if (!output || output.length < 100) {
            // 查找包含 "fleetId" 的JSON对象片段
            const fleetDataPattern = /"fleetId"\s*:\s*\d+[\s\S]{0,50000}/g;
            const fleetMatches = html.match(fleetDataPattern);
            if (fleetMatches && fleetMatches.length > 0) {
                // 尝试提取更大的上下文
                for (const fleetMatch of fleetMatches.slice(0, 10)) {
                    // 向前向后扩展，找到完整的JSON对象
                    const matchIndex = html.indexOf(fleetMatch);
                    if (matchIndex >= 0) {
                        const start = Math.max(0, matchIndex - 2000);
                        const end = Math.min(html.length, matchIndex + fleetMatch.length + 2000);
                        const context = html.substring(start, end);
                        // 尝试找到完整的JSON对象
                        const jsonObjMatch = context.match(/\{[\s\S]{0,10000}?"fleetId"[\s\S]{0,10000}?\}/);
                        if (jsonObjMatch) {
                            output += jsonObjMatch[0] + '\n';
                        }
                    }
                }
            }
        }
        
        // 如果所有策略都失败，返回原始HTML
        return output || html;
    }

    /**
     * 清理 JSON 字符串中的无效控制字符
     * 只清理字符串值中的控制字符，不影响 JSON 结构
     * @param {string} jsonString - 原始 JSON 字符串
     * @returns {string} 清理后的 JSON 字符串
     */
    function sanitizeJsonString(jsonString) {
        // 匹配字符串值（在引号内的内容），包括转义序列
        return jsonString.replace(/"([^"\\]|\\.)*"/g, (match) => {
            // 提取字符串内容（去掉引号）
            let content = match.slice(1, -1);
            let result = '';
            let i = 0;
            
            while (i < content.length) {
                const char = content[i];
                const code = char.charCodeAt(0);
                
                // 如果是转义序列，保留原样
                if (char === '\\' && i + 1 < content.length) {
                    result += char + content[i + 1];
                    i += 2;
                    continue;
                }
                
                // 如果是控制字符（0x00-0x1F），转义它
                if (code >= 0x00 && code <= 0x1F) {
                    // 常见字符使用简写形式
                    if (code === 0x0A) { // \n
                        result += '\\n';
                    } else if (code === 0x0D) { // \r
                        result += '\\r';
                    } else if (code === 0x09) { // \t
                        result += '\\t';
                    } else {
                        // 其他控制字符使用 Unicode 转义
                        result += '\\u' + ('0000' + code.toString(16)).slice(-4);
                    }
                } else {
                    result += char;
                }
                i++;
            }
            
            return '"' + result + '"';
        });
    }

    /**
     * 构建 label -> 对象/数组 的索引（全页）
     * 增强：支持更多JSON格式，包括嵌套结构和直接嵌入的对象
     * @param {string} html - HTML 文本
     * @returns {Object} 包含 objects 和 arrays 两个 Map 的对象
     */
    function buildLabelIndex(html) {
        const objects = new Map();
        const arrays = new Map();
        
        // 策略1：原有的正则匹配（适用于简单的JSON结构）
        const objRe = /([A-Za-z0-9_]+)\s*:\s*\{([\s\S]*?)\}\s*(?=\n|\r|\]|,|<|$)/g;
        let objMatch;
        while ((objMatch = objRe.exec(html))) {
            const label = objMatch[1];
            let raw = '{' + objMatch[2].replace(/,\s*\}/g, '}') + '}';
            
            try {
                // 先尝试直接解析
                const parsedObject = JSON.parse(raw);
                objects.set(label, parsedObject);
            } catch (error) {
                // 如果失败，尝试清理控制字符后再解析
                try {
                    raw = sanitizeJsonString(raw);
                    const parsedObject = JSON.parse(raw);
                    objects.set(label, parsedObject);
                } catch (secondError) {
                    // 如果仍然失败，静默跳过（这些可能是非关键数据）
                    // 不输出错误信息，避免控制台被大量错误信息淹没
                    // 这些失败的解析通常不影响最终结果
                }
            }
        }
        
        // 策略2：尝试匹配更复杂的嵌套JSON对象（支持多行和嵌套）
        // 查找包含 vslName 或 vesselName 的对象（这些是船期对象）
        const vesselObjPattern = /\{[\s\S]{0,5000}?"(?:vslName|vesselName)"[\s\S]{0,5000}?\}/g;
        let vesselObjMatch;
        let vesselObjCount = 0;
        while ((vesselObjMatch = vesselObjPattern.exec(html)) && vesselObjCount < 1000) {
            vesselObjCount++;
            try {
                const objText = vesselObjMatch[0].replace(/,\s*\}/g, '}');
                const vesselObj = JSON.parse(objText);
                // 如果对象有唯一标识（如vslName+voyNo），使用它作为key
                const vslName = vesselObj.vslName || vesselObj.vesselName || '';
                const voyNo = vesselObj.voyNo || vesselObj.voyageNo || '';
                if (vslName || voyNo) {
                    const key = `vessel_${vslName}_${voyNo}_${vesselObjCount}`;
                    if (!objects.has(key)) {
                        objects.set(key, vesselObj);
                    }
                }
            } catch (error) {
                // 解析失败，跳过
            }
        }
        
        const arrRe = /([A-Za-z0-9_]+)\s*:\s*\[([\s\S]*?)\]\s*(?=\n|\r|\}|,|<|$)/g;
        let arrMatch;
        while ((arrMatch = arrRe.exec(html))) {
            const label = arrMatch[1];
            const body = arrMatch[2];
            const items = [];
            const itemRe = /"\$?([A-Za-z0-9_]+)"/g;
            let itemMatch;
            while ((itemMatch = itemRe.exec(body))) {
                items.push(itemMatch[1]);
            }
            arrays.set(label, items);
        }
        
        // 策略3：尝试从整个HTML中提取所有包含船期数据的数组
        // 查找包含 vessel 或 schedule 的数组
        const vesselArrayPattern = /"(?:vessels?|schedules?|notices?)"\s*:\s*\[([\s\S]{0,50000}?)\]/gi;
        let vesselArrayMatch;
        while ((vesselArrayMatch = vesselArrayPattern.exec(html))) {
            const arrayBody = vesselArrayMatch[1];
            // 尝试提取数组中的对象引用
            const itemRe = /"\$?([A-Za-z0-9_]+)"/g;
            let itemMatch;
            const items = [];
            while ((itemMatch = itemRe.exec(arrayBody))) {
                items.push(itemMatch[1]);
            }
            if (items.length > 0) {
                const arrayLabel = `extracted_array_${arrays.size}`;
                arrays.set(arrayLabel, items);
            }
        }
        
        return {objects, arrays};
    }

    /**
     * 解引用 notices/scheduleNotices/scheduleNoticeShare -> 船期对象数组
     * 增强：支持直接的对象数组和多种引用格式
     * @param {Object} labelIndex - 标签索引对象
     * @param {string} label - 标签名（可能是标签引用或直接的对象数组）
     * @returns {Array} 船期对象数组
     */
    function derefList(labelIndex, label) {
        if (!label) return [];
        
        // 策略1：如果是标签引用（以$开头或纯字母数字）
        const key = String(label).replace(/^\$/, '');
        const labelArray = labelIndex.arrays.get(key) || [];
        const out = [];
        
        // 如果找到了数组引用，解引用
        if (labelArray.length > 0) {
        for (const labelItem of labelArray) {
            const vesselObject = labelIndex.objects.get(labelItem);
                if (vesselObject && (vesselObject.vslName || vesselObject.voyNo || vesselObject.vesselName || vesselObject.voyageNo)) {
                out.push(vesselObject);
            }
        }
        }
        
        // 策略2：如果标签本身就是一个对象（直接的对象，不是引用）
        const directObject = labelIndex.objects.get(key);
        if (directObject && (directObject.vslName || directObject.voyNo || directObject.vesselName || directObject.voyageNo)) {
            out.push(directObject);
        }
        
        // 策略3：尝试查找所有以该标签开头的对象（处理可能的变体）
        if (out.length === 0) {
            for (const [objKey, objValue] of labelIndex.objects.entries()) {
                if (objKey.startsWith(key) || objKey.includes(key)) {
                    if (objValue && (objValue.vslName || objValue.voyNo || objValue.vesselName || objValue.voyageNo)) {
                        out.push(objValue);
                    }
                }
            }
        }
        
        return out;
    }

    /**
     * 从DOM中提取可见的船期数据，用于验证JSON提取的数据是否真实存在
     * 优化：减少DOM查询次数，提高性能
     * @param {string} html - HTML 文本
     * @returns {Map} 键为 "fleetId_fleetIdPort_vesselName_voyage"，值为包含计划开航、目的港码头等信息的对象
     */
    function extractVisibleScheduleData(html) {
        const visibleData = new Map();
        try {
            const doc = new DOMParser().parseFromString(html, 'text/html');
            // 优化：只查找包含特定模式的链接，减少查询范围
            // 使用正则表达式在HTML文本中快速定位，而不是遍历所有链接
            const hrefPattern = /href=["']([^"']*_(\d+)_(\d+)[^"']*)["']/gi;
            const hrefMatches = [];
            let match;
            while ((match = hrefPattern.exec(html)) !== null) {
                const href = match[1];
                const fleetId = match[2];
                const fleetIdPort = match[3];
                // 跳过无效的港口ID
                if (fleetIdPort === '0' || fleetIdPort === '1') continue;
                hrefMatches.push({ href, fleetId, fleetIdPort, index: match.index });
            }
            
            // 优化：批量查询，减少DOM操作
            for (const { href, fleetId, fleetIdPort } of hrefMatches) {
                // 只查询包含这个href的链接
                const link = doc.querySelector(`a[href="${href.replace(/"/g, '\\"')}"]`);
                if (!link) continue;
                
                // 尝试从链接的title或周围文本中提取船名航次
                const title = link.getAttribute('title') || '';
                const linkText = (link.textContent || '').trim();
                
                // 优化：限制向上查找的深度，减少DOM遍历
                let planDate = '';
                let etaDate = '';
                let podWharf = '';
                
                // 向上查找包含日期的父元素（限制深度为6层，兼顾更多场景）
                let parent = link.parentElement;
                let searchDepth = 0;
                while (parent && searchDepth < 6) {
                    const parentText = (parent.textContent || '').trim();
                    // 匹配日期格式 YYYY/MM/DD（取前两个：第一个计划开航，第二个预计到港）
                    const dateMatches = parentText.match(/(\d{4}\/\d{2}\/\d{2})/g);
                    if (dateMatches && dateMatches.length > 0) {
                        if (!planDate) planDate = dateMatches[0];
                        if (dateMatches.length > 1 && !etaDate) etaDate = dateMatches[1];
                    }
                    // 查找目的港码头（限制查询范围）
                    if (!podWharf) {
                        const wharfEl = parent.querySelector('[class*="wharf"], [class*="terminal"]');
                        if (wharfEl) {
                            podWharf = (wharfEl.textContent || '').trim();
                        }
                    }
                    // 如果都找到了，提前退出
                    if (planDate && podWharf) break;
                    parent = parent.parentElement;
                    searchDepth++;
                }
                
                // 如果仍然缺失，从相同 fleetId/port 的其他元素补充
                if (!planDate || !podWharf || !etaDate) {
                    const relatedElements = Array.from(doc.querySelectorAll(`[href*="_${fleetId}_${fleetIdPort}"], [data-fleet-id="${fleetId}"][data-port-id="${fleetIdPort}"]`));
                    for (const el of relatedElements) {
                        const elText = (el.textContent || '').trim();
                        if (!planDate || !etaDate) {
                            const dateMatches = elText.match(/(\d{4}\/\d{2}\/\d{2})/g);
                            if (dateMatches && dateMatches.length > 0) {
                                if (!planDate) planDate = dateMatches[0];
                                if (dateMatches.length > 1 && !etaDate) etaDate = dateMatches[1];
                            }
                        }
                        if (!podWharf) {
                            const wharfMatch = elText.match(/([A-Z]{2,}\s*[A-Z]*\s*TERMINAL|[A-Z]{2,}\s*TERMINAL|[A-Z]{2,}\s*CT|[A-Z]{2,}\s*PORT)/i);
                            if (wharfMatch) podWharf = wharfMatch[1];
                        }
                        if (planDate && podWharf && etaDate) break;
                    }
                }
                
                // 提取船名航次（从title或文本中）
                let vesselName = '';
                let voyage = '';
                if (title) {
                    const vesselMatch = title.match(/([A-Z\s]+)\s*\/\s*([A-Z0-9]+)/);
                    if (vesselMatch) {
                        vesselName = clean(vesselMatch[1]);
                        voyage = clean(vesselMatch[2]);
                    }
                }
                if (!vesselName && linkText) {
                    const vesselMatch = linkText.match(/([A-Z\s]+)\s*\/\s*([A-Z0-9]+)/);
                    if (vesselMatch) {
                        vesselName = clean(vesselMatch[1]);
                        voyage = clean(vesselMatch[2]);
                    }
                }
                
                if (fleetId && fleetIdPort && (vesselName || voyage)) {
                    const key = `${fleetId}_${fleetIdPort}_${vesselName || ''}_${voyage || ''}`;
                    // 优化：避免重复设置相同的key
                    if (!visibleData.has(key)) {
                        visibleData.set(key, {
                            fleetId,
                            fleetIdPort,
                            vesselName,
                            voyage,
                            planDate: clean(planDate),
                            etaDate: clean(etaDate),
                            podWharf: clean(podWharf)
                        });
                    }
                }
            }
        } catch (error) {
            // DOM解析失败，静默返回空Map
        }
        return visibleData;
    }

    /**
     * 验证数据是否在DOM中可见
     * @param {string} fleetId - 航线ID
     * @param {string} fleetIdPort - 港口ID
     * @param {string} vesselName - 船名
     * @param {string} voyage - 航次
     * @param {Map} visibleData - 可见数据Map
     * @returns {boolean} 是否可见
     */
    function isDataVisible(fleetId, fleetIdPort, vesselName, voyage, visibleData) {
        if (!fleetId || !fleetIdPort || fleetIdPort === '0' || fleetIdPort === '1') {
            return false; // 无效的港口ID视为不可见
        }
        
        const key1 = `${fleetId}_${fleetIdPort}_${vesselName || ''}_${voyage || ''}`;
        const key2 = `${fleetId}_${fleetIdPort}_${clean(vesselName || '')}_${clean(voyage || '')}`;
        const key3 = `${fleetId}_${fleetIdPort}_${(vesselName || '').toUpperCase()}_${(voyage || '').toUpperCase()}`;
        
        return visibleData.has(key1) || visibleData.has(key2) || visibleData.has(key3);
    }

    /**
     * 从整页提取"fleet块 + 对应船期"对
     * 增强：支持多种JSON格式，包括标准化HTML格式、嵌套对象和数组
     * @param {string} html - HTML 文本
     * @param {Object} labelIndex - 标签索引对象
     * @param {Map} visibleData - 可见数据Map（用于验证）
     * @returns {Array} fleet 对象数组
     */
    /**
     * 解析工具中的resolveReferences函数（用于展开引用）
     * @param {string|Object} ref - 引用字符串（如"$a8"）或对象
     * @param {Object} labelIndex - 标签索引对象
     * @returns {Object|Array|null} 展开后的对象或数组
     */
    function resolveReferences(ref, labelIndex) {
        if (!ref) return null;
        if (typeof ref === 'string' && ref.startsWith('$')) {
            const key = ref.replace(/^\$/, '');
            // 尝试从objects中获取
            const obj = labelIndex.objects.get(key);
            if (obj) return obj;
            // 尝试从arrays中获取
            const arr = labelIndex.arrays.get(key);
            if (arr) return arr;
            // 尝试查找所有以该标签开头的对象
            for (const [objKey, objValue] of labelIndex.objects.entries()) {
                if (objKey === key || objKey.startsWith(key)) {
                    return objValue;
                }
            }
        }
        return ref;
    }

    function extractFleetAndVessels(html, labelIndex, visibleData = new Map()) {
        const fleets = [];
        const processedStandardizedKeys = new Set(); // 用于去重
        
        // 策略0：标准化HTML格式 - 优先处理展开后的完整JSON结构
        // 检查是否是展开后的JSON结构（包含 fleets, vessels, carriers 等数组）
        try {
            // 从标准化HTML中提取JSON内容（在<pre>标签中）
            const preMatch = html.match(/<pre[^>]*>([\s\S]*?)<\/pre>/);
            if (preMatch) {
                const jsonContent = preMatch[1];
                // 尝试解析为完整的JSON对象
                const jsonData = JSON.parse(jsonContent);
                
                // 构建从标准化HTML JSON结构中提取的引用映射（用于resolveReferences）
                // 遍历整个JSON结构，收集所有scheduleNoticeShare对象和vessel对象
                // 由于标准化HTML中可能没有引用标签的定义，我们需要收集所有可能的对象
                const allScheduleNoticeShareObjects = []; // 所有scheduleNoticeShare对象
                const allVesselObjects = []; // 所有vessel对象
                
                function collectObjects(obj) {
                    if (!obj || typeof obj !== 'object') return;
                    if (Array.isArray(obj)) {
                        obj.forEach(item => collectObjects(item));
                    } else {
                        // 检查是否是scheduleNoticeShare对象（有notices数组）
                        if (obj.notices && Array.isArray(obj.notices) && obj.startPortEnName) {
                            allScheduleNoticeShareObjects.push(obj);
                        }
                        // 检查是否是vessel对象（有vslName或voyNo）
                        if ((obj.vslName || obj.voyNo || obj.vesselName || obj.voyageNo) && 
                            obj.vslName !== 'BLANK SAILING' && obj.voyNo !== 'BLANK SAILING') {
                            allVesselObjects.push(obj);
                        }
                        // 递归处理所有属性
                        for (const value of Object.values(obj)) {
                            collectObjects(value);
                        }
                    }
                }
                collectObjects(jsonData);
                
                // 改进resolveReferences函数，使其能够从标准化HTML的JSON结构中查找对象
                // 在extractFleetAndVessels函数内部，创建一个局部的resolveReferences函数
                // 它会覆盖全局的resolveReferences函数，使其能够从标准化HTML的JSON结构中查找对象
                const originalResolveReferences = resolveReferences;
                resolveReferences = (ref, labelIndex) => {
                    if (!ref) return null;
                    if (typeof ref === 'string' && ref.startsWith('$')) {
                        const key = ref.replace(/^\$/, '').toLowerCase();
                        // 首先尝试从labelIndex中查找（原始HTML的引用结构）
                        const obj = labelIndex.objects.get(key);
                        if (obj) return obj;
                        const arr = labelIndex.arrays.get(key);
                        if (arr) return arr;
                        // 然后尝试模糊匹配labelIndex
                        for (const [objKey, objValue] of labelIndex.objects.entries()) {
                            if (objKey.toLowerCase() === key || objKey.toLowerCase().startsWith(key)) {
                                return objValue;
                            }
                        }
                        // 如果labelIndex中没有找到，尝试从标准化HTML的JSON结构中查找
                        // 注意：由于标准化HTML中可能没有引用标签的定义，我们无法直接通过标签查找
                        // 这里我们返回null，让调用者处理未展开的引用
                        // 实际上，如果标准化工具没有展开引用，说明这些引用可能指向的对象不在标准化HTML中
                    }
                    return ref;
                };
                
                // 优先处理directFleets数组（直达航线）
                // 如果没有directFleets，尝试从fleets中筛选直达航线（兼容旧数据或分类错误的情况）
                let directFleets = jsonData.directFleets;
                if (!directFleets || !Array.isArray(directFleets) || directFleets.length === 0) {
                    // 尝试从fleets中筛选直达航线
                    const allFleets = jsonData.fleets || [];
                    if (allFleets.length > 0) {
                        directFleets = allFleets.filter(f => {
                            // 优先使用标准化工具标记的_isDirect
                            if (f._isDirect !== undefined) {
                                return f._isDirect === true; // 只保留明确标记为直达的
                            }
                            // 如果没有标记，使用与标准化工具一致的判断逻辑
                            const hasLineTypeTransit = f.lineTypeShowName && /(接二程|接三程|转)/.test(f.lineTypeShowName);
                            const hasTransitPorts = f.transitPorts && Array.isArray(f.transitPorts) && f.transitPorts.length > 0;
                            const hasTransitNames = (f.transit1CnName !== null && f.transit1CnName !== undefined) ||
                                                    (f.transit2CnName !== null && f.transit2CnName !== undefined);
                            // 更严格的判断：只有当transType明确不等于1时才认为是转船
                            const isTransitType = f.transType !== undefined && 
                                                 f.transType !== null && 
                                                 f.transType !== 1;
                            // 与标准化工具一致：使用OR逻辑（任何一个条件满足就是转船）
                            const isTransit = hasLineTypeTransit || hasTransitPorts || hasTransitNames || isTransitType;
                            return !isTransit; // 没有转船标识，才认为是直达
                        });
                    }
                }
                
                // 如果还是没有直达航线，尝试从fleets中筛选直达航线（使用与标准化工具一致的逻辑）
                if (!directFleets || !Array.isArray(directFleets) || directFleets.length === 0) {
                    const allFleets = jsonData.fleets || [];
                    if (allFleets.length > 0) {
                        // 使用与标准化工具一致的判断逻辑
                        directFleets = allFleets.filter(f => {
                            // 优先使用标准化工具标记的_isDirect
                            if (f._isDirect !== undefined) {
                                return f._isDirect === true; // 只保留明确标记为直达的
                            }
                            // 如果没有标记，使用与标准化工具一致的判断逻辑
                            const hasLineTypeTransit = f.lineTypeShowName && /(接二程|接三程|转)/.test(f.lineTypeShowName);
                            const hasTransitPorts = f.transitPorts && Array.isArray(f.transitPorts) && f.transitPorts.length > 0;
                            const hasTransitNames = (f.transit1CnName !== null && f.transit1CnName !== undefined) ||
                                                    (f.transit2CnName !== null && f.transit2CnName !== undefined);
                            const isTransitType = f.transType !== undefined && 
                                                 f.transType !== null && 
                                                 f.transType !== 1;
                            // 与标准化工具一致：使用OR逻辑（任何一个条件满足就是转船）
                            const isTransit = hasLineTypeTransit || hasTransitPorts || hasTransitNames || isTransitType;
                            return !isTransit; // 没有转船标识，才认为是直达
                        });
                    }
                    // 如果还是没有，返回空数组
                    if (!directFleets || !Array.isArray(directFleets) || directFleets.length === 0) {
                        return [];
                    }
                }
                
                // 获取carriers数组（可能包含更多carrier对象）
                const allCarriers = jsonData.carriers || [];
                
                // 第一步：找到所有主fleet对象（收紧条件，确保只处理完整的fleet对象，避免将carrier对象当作fleet）
                const mainFleets = directFleets.filter(f => {
                    // 优先：有key字段且格式正确（这是完整的fleet对象）
                    if (f.key && /^\d+_\d+_[^_]+$/.test(f.key)) {
                        return true;
                    }
                    // 或者有fleetId和motherVesselPolCode，且有船期数据（如青岛到济州的情况）
                    // 注意：carrier对象通常只有fleetId和motherVesselPolCode，但没有weekday、shipDays等字段
                    // 因此需要确保有船期数据（scheduleNotices、planSchedule或directScheduleList）
                    if (f.fleetId && f.motherVesselPolCode && !f.key) {
                        // 必须有船期数据，且最好有weekday或shipDays（表明是完整的fleet对象）
                        const hasScheduleData = (f.scheduleNotices && Array.isArray(f.scheduleNotices) && f.scheduleNotices.length > 0) ||
                                               (f.planSchedule && Array.isArray(f.planSchedule) && f.planSchedule.length > 0) ||
                                               (f.directScheduleList && Array.isArray(f.directScheduleList) && f.directScheduleList.length > 0);
                        const hasFleetInfo = f.weekday !== undefined || f.shipDays !== undefined || f.wharfName !== undefined;
                        // 必须有船期数据，且最好有fleet信息（weekday、shipDays或wharfName）
                        return hasScheduleData && hasFleetInfo;
                    }
                    // 或者有directScheduleList且格式完整（即使没有key，也可能包含船期信息）
                    if (f.directScheduleList && Array.isArray(f.directScheduleList) && f.directScheduleList.length > 0) {
                        // 确保有fleetId和motherVesselPolCode
                        return f.fleetId && f.motherVesselPolCode;
                    }
                    // 或者有scheduleNotices且格式完整（即使没有key，也可能包含船期信息）
                    if (f.scheduleNotices && Array.isArray(f.scheduleNotices) && f.scheduleNotices.length > 0) {
                        // 确保有fleetId和motherVesselPolCode
                        return f.fleetId && f.motherVesselPolCode;
                    }
                    // 或者有planSchedule且格式完整（即使没有key，也可能包含船期信息）
                    if (f.planSchedule && Array.isArray(f.planSchedule) && f.planSchedule.length > 0) {
                        // 确保有fleetId和motherVesselPolCode
                        return f.fleetId && f.motherVesselPolCode;
                    }
                    // 其他情况不处理（避免将carrier对象当作fleet对象）
                    return false;
                });
                
                // 第二步：找到所有包含scheduleNotices和目的港码头的carrier对象
                // 包括：directFleets中的carrier对象、allCarriers数组、以及directScheduleList中的carrier对象
                const carrierObjects = [
                    ...directFleets.filter(f => 
                        (f.scheduleNotices && Array.isArray(f.scheduleNotices)) ||
                        (f.destPortWharfEnShortName || f.destPortWharfEnFullName) ||
                        (f.fleetId && f.motherVesselPolCode && !f.key) // 没有key但可能是carrier对象
                    ),
                    ...allCarriers.filter(c => 
                        c.fleetId && c.motherVesselPolCode &&
                        ((c.scheduleNotices && Array.isArray(c.scheduleNotices)) ||
                         (c.destPortWharfEnShortName || c.destPortWharfEnFullName))
                    )
                ];
                
                // 从directFleets中提取directScheduleList中的carrier对象
                for (const fleet of directFleets) {
                    if (fleet.directScheduleList && Array.isArray(fleet.directScheduleList)) {
                        for (const carrierItem of fleet.directScheduleList) {
                            if (carrierItem && typeof carrierItem === 'object' && 
                                carrierItem.fleetId && carrierItem.motherVesselPolCode &&
                                ((carrierItem.scheduleNotices && Array.isArray(carrierItem.scheduleNotices)) ||
                                 (carrierItem.destPortWharfEnShortName || carrierItem.destPortWharfEnFullName))) {
                                // 确保这个carrier对象还没有被添加（避免重复）
                                const carrierKey = `${carrierItem.fleetId}_${carrierItem.motherVesselPolCode}_${carrierItem.carrierCode || ''}_${carrierItem.svcCode || ''}`;
                                if (!carrierObjects.some(c => 
                                    String(c.fleetId) === String(carrierItem.fleetId) &&
                                    c.motherVesselPolCode === carrierItem.motherVesselPolCode &&
                                    (c.carrierCode || '') === (carrierItem.carrierCode || '') &&
                                    (c.svcCode || '') === (carrierItem.svcCode || '')
                                )) {
                                    carrierObjects.push(carrierItem);
                                }
                            }
                        }
                    }
                }
                
                // 第三步：处理每个主fleet对象，关联对应的carrier对象
                for (const fleet of mainFleets) {
                    let lineId = '';
                    let portId = '';
                    let fleetId = '';
                    let motherVesselPolCode = '';
                    
                    // 从key字段提取航线ID和港口ID：格式 "3_188_CNTAO"
                    if (fleet.key && /^\d+_\d+_[^_]+$/.test(fleet.key)) {
                        const keyMatch = /^(\d+)_(\d+)_([^_]+)$/.exec(fleet.key);
                        if (keyMatch) {
                            const firstPart = keyMatch[1]; // 第一个数字（如"3"）
                            fleetId = keyMatch[2]; // 第二个数字是fleetId（如"188"）
                            motherVesselPolCode = keyMatch[3]; // 最后一部分是港口代码（如"CNTAO"）
                            lineId = fleetId; // 航线ID是"188"（中间部分）
                            portId = motherVesselPolCode; // 港口ID是"CNTAO"（最后一部分）
                        }
                    } else if (fleet.fleetId && fleet.motherVesselPolCode) {
                        // 没有key字段，但有fleetId和motherVesselPolCode（如青岛到济州的情况）
                        fleetId = String(fleet.fleetId);
                        motherVesselPolCode = fleet.motherVesselPolCode;
                        // 尝试从fleetId推断lineId（如果fleetId是数字，可能需要其他方式）
                        // 暂时使用fleetId作为lineId的一部分
                        lineId = String(fleet.fleetId);
                        portId = motherVesselPolCode;
                    } else if (fleet.directScheduleList && Array.isArray(fleet.directScheduleList) && fleet.directScheduleList.length > 0) {
                        // 没有key和fleetId，但有directScheduleList，从第一个carrier对象中提取
                        const firstCarrier = fleet.directScheduleList[0];
                        if (firstCarrier && typeof firstCarrier === 'object' && 
                            firstCarrier.fleetId && firstCarrier.motherVesselPolCode) {
                            fleetId = String(firstCarrier.fleetId);
                            motherVesselPolCode = firstCarrier.motherVesselPolCode;
                            lineId = String(firstCarrier.fleetId);
                            portId = motherVesselPolCode;
                        }
                    }
                    
                    if (!fleetId || !portId || !motherVesselPolCode) {
                        continue; // 如果无法提取必要信息，跳过
                    }
                    
                    // 如果portId无效，跳过
                    if (!portId || !motherVesselPolCode) {
                        continue;
                    }
                    
                    // 检查是否已经处理过相同的fleet（基于fleetId和motherVesselPolCode）
                    // 如果已经处理过，合并数据而不是跳过（因为可能有不同的数据源）
                    const fleetKey = `${fleetId}_${portId}_${motherVesselPolCode}`;
                    let existingFleetIndex = -1;
                    if (processedStandardizedKeys.has(fleetKey)) {
                        // 找到已存在的fleet对象，准备合并数据
                        for (let i = 0; i < fleets.length; i++) {
                            if (fleets[i].fleetId === String(fleetId) && 
                                fleets[i].motherVesselPolCode === String(motherVesselPolCode)) {
                                existingFleetIndex = i;
                                break;
                            }
                        }
                    } else {
                        processedStandardizedKeys.add(fleetKey);
                    }
                    
                    // 提取开航日：从weekday字段，如果没有则从directScheduleList的第一个carrier对象中提取
                    let weekday = fleet.weekday || fleet.weekdayOfETDFormatter || '';
                    if (!weekday && fleet.directScheduleList && Array.isArray(fleet.directScheduleList) && fleet.directScheduleList.length > 0) {
                        // 遍历所有carrier对象，找到第一个有weekday的
                        for (const carrierItem of fleet.directScheduleList) {
                            if (carrierItem && typeof carrierItem === 'object' && 
                                String(carrierItem.fleetId) === String(fleetId) &&
                                carrierItem.motherVesselPolCode === motherVesselPolCode) {
                                weekday = carrierItem.weekday || carrierItem.weekdayOfETDFormatter || '';
                                if (weekday) break;
                            }
                        }
                    }
                    
                    // 提取航程：从shipDays字段（注意：标准化HTML中是shipDays，不是shipdays），如果没有则从directScheduleList的第一个carrier对象中提取
                    let shipDays = fleet.shipDays || fleet.shipdays || 0;
                    if (!shipDays && fleet.directScheduleList && Array.isArray(fleet.directScheduleList) && fleet.directScheduleList.length > 0) {
                        // 遍历所有carrier对象，找到第一个有shipDays的
                        for (const carrierItem of fleet.directScheduleList) {
                            if (carrierItem && typeof carrierItem === 'object' && 
                                String(carrierItem.fleetId) === String(fleetId) &&
                                carrierItem.motherVesselPolCode === motherVesselPolCode) {
                                shipDays = carrierItem.shipDays || carrierItem.shipdays || 0;
                                if (shipDays) break;
                            }
                        }
                    }
                    
                    // 提取启运港码头：从wharfName字段，如果没有则从directScheduleList的第一个carrier对象中提取
                    let wharfName = fleet.wharfName || '';
                    if (!wharfName && fleet.directScheduleList && Array.isArray(fleet.directScheduleList) && fleet.directScheduleList.length > 0) {
                        // 遍历所有carrier对象，找到第一个有wharfName的
                        for (const carrierItem of fleet.directScheduleList) {
                            if (carrierItem && typeof carrierItem === 'object' && 
                                String(carrierItem.fleetId) === String(fleetId) &&
                                carrierItem.motherVesselPolCode === motherVesselPolCode) {
                                wharfName = carrierItem.wharfName || '';
                                if (wharfName) break;
                            }
                        }
                    }
                    
                    // 提取共舱船公司：从sharedCabinCarriers数组，格式"carrierShortName(svcCode)"，多个用"|"连接
                    let carriersStr = '';
                    const carrierPartsSet = new Set(); // 使用Set避免重复
                    
                    // 首先从主fleet对象的sharedCabinCarriers数组中提取
                    if (fleet.sharedCabinCarriers && Array.isArray(fleet.sharedCabinCarriers)) {
                        for (const carrier of fleet.sharedCabinCarriers) {
                            if (carrier && typeof carrier === 'object') {
                                const carrierName = carrier.carrierShortName || carrier.carrierCode || '';
                                const svcCode = carrier.svcCode || '';
                                if (carrierName) {
                                    const carrierKey = svcCode ? `${carrierName}(${svcCode})` : carrierName;
                                    carrierPartsSet.add(carrierKey);
                                }
                            }
                        }
                    }
                    
                    // 查找相同fleetId的所有carrier对象，合并它们的scheduleNotices和目的港码头
                    let scheduleNotices = [];
                    let destPortWharfShort = '';
                    let destPortWharfFull = '';
                    
                    // 首先，如果fleet对象本身有目的港码头信息，先提取（对于没有key字段的carrier对象）
                    if (!destPortWharfShort && fleet.destPortWharfEnShortName) {
                        destPortWharfShort = fleet.destPortWharfEnShortName;
                    }
                    if (!destPortWharfFull && fleet.destPortWharfEnFullName) {
                        destPortWharfFull = fleet.destPortWharfEnFullName;
                    }
                    
                    // 首先，如果fleet对象本身有scheduleNotices，先提取（优先级最高）
                    if (fleet.scheduleNotices && Array.isArray(fleet.scheduleNotices)) {
                        const filteredNotices = fleet.scheduleNotices.filter(item => {
                            if (typeof item === 'string' && item.startsWith('$')) {
                                return false;
                            }
                            if (Array.isArray(item)) {
                                return item.length > 0;
                            }
                            const isValid = item && 
                                           typeof item === 'object' && 
                                           item.vslName && 
                                           item.vslName !== 'BLANK SAILING' &&
                                           item.voyNo !== 'BLANK SAILING';
                            if (!isValid) return false;
                            // 放宽条件：由于已经从directFleets中提取，理论上都是直达的
                            // 只有在明确标记为转船（_isDirect === false）时才过滤
                            if (item._isDirect === false) {
                                return false; // 明确标记为转船，过滤
                            }
                            // 其他情况都保留（包括_isDirect为true、undefined）
                            return true;
                        });
                        const expandedNotices = filteredNotices.flatMap(item => {
                            if (Array.isArray(item)) {
                                return item.filter(n => n && typeof n === 'object' && 
                                                  n._isDirect !== false); // 只过滤明确标记为转船的
                            }
                            return [item];
                        });
                        for (const notice of expandedNotices) {
                            const key = `${notice.vslName || ''}_${notice.voyNo || ''}`;
                            const exists = scheduleNotices.some(n => 
                                `${n.vslName || ''}_${n.voyNo || ''}` === key
                            );
                            if (!exists) {
                                scheduleNotices.push(notice);
                            }
                        }
                    }
                    
                    // 收集所有匹配的carrier对象的scheduleNotices和共舱船公司信息（一个fleetId可能对应多个carrier对象）
                    for (const carrierObj of carrierObjects) {
                        // 匹配条件：fleetId相同（需要类型转换），且motherVesselPolCode相同
                        const carrierFleetId = String(carrierObj.fleetId || '');
                        const mainFleetId = String(fleetId || '');
                        if (carrierFleetId === mainFleetId && 
                            carrierObj.motherVesselPolCode === motherVesselPolCode) {
                            
                            // 补充开航日：如果fleet对象没有，从carrier对象中提取
                            if (!weekday && (carrierObj.weekday || carrierObj.weekdayOfETDFormatter)) {
                                weekday = carrierObj.weekday || carrierObj.weekdayOfETDFormatter || '';
                            }
                            
                            // 补充航程：如果fleet对象没有，从carrier对象中提取
                            if (!shipDays && (carrierObj.shipDays || carrierObj.shipdays)) {
                                shipDays = carrierObj.shipDays || carrierObj.shipdays || 0;
                            }
                            
                            // 补充启运港码头：如果fleet对象没有，从carrier对象中提取
                            if (!wharfName && carrierObj.wharfName) {
                                wharfName = carrierObj.wharfName || '';
                            }
                            
                            // 提取共舱船公司：从carrier对象中提取carrierShortName和svcCode
                            if (carrierObj.carrierShortName || carrierObj.carrierCode) {
                                const carrierName = carrierObj.carrierShortName || carrierObj.carrierCode || '';
                                const svcCode = carrierObj.svcCode || '';
                                if (carrierName) {
                                    const carrierKey = svcCode ? `${carrierName}(${svcCode})` : carrierName;
                                    carrierPartsSet.add(carrierKey);
                                }
                            }
                            
                            // 提取目的港码头（使用第一个找到的，通常所有carrier对象的目的港码头相同）
                            if (!destPortWharfShort && carrierObj.destPortWharfEnShortName) {
                                destPortWharfShort = carrierObj.destPortWharfEnShortName;
                            }
                            if (!destPortWharfFull && carrierObj.destPortWharfEnFullName) {
                                destPortWharfFull = carrierObj.destPortWharfEnFullName;
                            }
                            
                            // 提取船期信息：从scheduleNotices数组，合并到总数组中
                            if (carrierObj.scheduleNotices && Array.isArray(carrierObj.scheduleNotices)) {
                                const filteredNotices = carrierObj.scheduleNotices.filter(item => {
                                    // 过滤掉引用（字符串类型，以$开头）
                                    if (typeof item === 'string' && item.startsWith('$')) {
                                        return false;
                                    }
                                    // 如果是数组，展开数组中的每个元素
                                    if (Array.isArray(item)) {
                                        return item.length > 0;
                                    }
                                    // 只保留有效的对象，且有vslName，且不是BLANK SAILING
                                    // 如果标准化工具已经添加了_isDirect标记，只保留直达的（_isDirect === true）
                                    const isValid = item && 
                                                   typeof item === 'object' && 
                                                   item.vslName && 
                                                   item.vslName !== 'BLANK SAILING' &&
                                                   item.voyNo !== 'BLANK SAILING';
                                    if (!isValid) return false;
                                    // 放宽条件：由于已经从directFleets中提取，理论上都是直达的
                                    // 只有在明确标记为转船（_isDirect === false）时才过滤
                                    if (item._isDirect === false) {
                                        return false; // 明确标记为转船，过滤
                                    }
                                    // 其他情况都保留（包括_isDirect为true、undefined）
                                    return true;
                                });
                                // 合并到总数组中（避免重复，基于vslName和voyNo）
                                for (const notice of filteredNotices) {
                                    // 处理数组情况
                                    if (Array.isArray(notice)) {
                                        for (const n of notice) {
                                            if (n && typeof n === 'object' && n.vslName && n.voyNo) {
                                                const key = `${n.vslName || ''}_${n.voyNo || ''}`;
                                                const exists = scheduleNotices.some(not => 
                                                    `${not.vslName || ''}_${not.voyNo || ''}` === key
                                                );
                                                // 放宽条件：只过滤明确标记为转船的
                                                if (!exists && n._isDirect !== false) {
                                                    scheduleNotices.push(n);
                                                }
                                            }
                                        }
                                    } else {
                                        const key = `${notice.vslName || ''}_${notice.voyNo || ''}`;
                                        const exists = scheduleNotices.some(n => 
                                            `${n.vslName || ''}_${n.voyNo || ''}` === key
                                        );
                                        if (!exists) {
                                            scheduleNotices.push(notice);
                                        }
                                    }
                                }
                            }
                            
                            // 从carrier对象的scheduleNoticeShare.notices中提取（补充更多船期）
                            // 注意：scheduleNoticeShare可能是字符串（如"$a8"），需要先展开
                            let carrierScheduleNoticeShareObj = carrierObj.scheduleNoticeShare;
                            if (carrierScheduleNoticeShareObj && typeof carrierScheduleNoticeShareObj === 'string' && carrierScheduleNoticeShareObj.startsWith('$')) {
                                // 这是一个引用，尝试从labelIndex中展开（如果标准化工具没有展开）
                                const expanded = resolveReferences(carrierScheduleNoticeShareObj, labelIndex);
                                if (expanded && typeof expanded === 'object') {
                                    carrierScheduleNoticeShareObj = expanded;
                                }
                            }
                            if (carrierScheduleNoticeShareObj && typeof carrierScheduleNoticeShareObj === 'object' &&
                                carrierScheduleNoticeShareObj.notices && Array.isArray(carrierScheduleNoticeShareObj.notices)) {
                                // 展开notices数组中的引用（如"$131"）
                                const expandedNotices = [];
                                for (const item of carrierScheduleNoticeShareObj.notices) {
                                    if (typeof item === 'string' && item.startsWith('$')) {
                                        // 这是一个引用，尝试展开
                                        const expanded = resolveReferences(item, labelIndex);
                                        if (Array.isArray(expanded)) {
                                            expandedNotices.push(...expanded);
                                        } else if (expanded && typeof expanded === 'object') {
                                            expandedNotices.push(expanded);
                                        }
                                    } else {
                                        expandedNotices.push(item);
                                    }
                                }
                                // 过滤有效的船期对象
                                const filteredNotices = expandedNotices.filter(item => {
                                    if (typeof item === 'string' && item.startsWith('$')) {
                                        return false;
                                    }
                                    const isValid = item && 
                                                   typeof item === 'object' && 
                                                   !Array.isArray(item) && 
                                                   item.vslName && 
                                                   item.vslName !== 'BLANK SAILING' &&
                                                   item.voyNo !== 'BLANK SAILING';
                                    if (!isValid) return false;
                                    // 放宽条件：由于已经从directFleets中提取，理论上都是直达的
                                    // 只有在明确标记为转船（_isDirect === false）时才过滤
                                    if (item._isDirect === false) {
                                        return false; // 明确标记为转船，过滤
                                    }
                                    // 其他情况都保留（包括_isDirect为true、undefined）
                                    return true;
                                });
                                // 合并到scheduleNotices（避免重复）
                                for (const notice of filteredNotices) {
                                    const key = `${notice.vslName || ''}_${notice.voyNo || ''}`;
                                    const exists = scheduleNotices.some(n => 
                                        `${n.vslName || ''}_${n.voyNo || ''}` === key
                                    );
                                    if (!exists) {
                                        scheduleNotices.push(notice);
                                    }
                                }
                            }
                        }
                    }
                    
                    // 第二步：从fleet对象的planSchedule中提取（补充更多船期，即使已经有scheduleNotices）
                    if (fleet.planSchedule && Array.isArray(fleet.planSchedule)) {
                        const filteredPlanSchedule = fleet.planSchedule.filter(item => {
                            if (typeof item === 'string' && item.startsWith('$')) {
                                return false;
                            }
                            const isValid = item && 
                                           typeof item === 'object' && 
                                           !Array.isArray(item) && 
                                           item.vslName && 
                                           item.vslName !== 'BLANK SAILING' &&
                                           item.voyNo !== 'BLANK SAILING';
                            if (!isValid) return false;
                            // 放宽条件：由于已经从directFleets中提取，理论上都是直达的
                            // 只有在明确标记为转船（_isDirect === false）时才过滤
                            if (item._isDirect === false) {
                                return false; // 明确标记为转船，过滤
                            }
                            // 其他情况都保留（包括_isDirect为true、undefined）
                            return true;
                        });
                        // 合并planSchedule中的船期到scheduleNotices（避免重复）
                        for (const notice of filteredPlanSchedule) {
                            const key = `${notice.vslName || ''}_${notice.voyNo || ''}`;
                            const exists = scheduleNotices.some(n => 
                                `${n.vslName || ''}_${n.voyNo || ''}` === key
                            );
                            if (!exists) {
                                scheduleNotices.push(notice);
                            }
                        }
                        
                        // 如果目的港码头还没有找到，尝试从planSchedule中的vessel对象中提取
                        if ((!destPortWharfShort || !destPortWharfFull) && filteredPlanSchedule.length > 0) {
                            for (const notice of filteredPlanSchedule) {
                                if (notice && typeof notice === 'object' && !Array.isArray(notice)) {
                                    if (!destPortWharfShort && notice.destPortWharfEnShortName) {
                                        destPortWharfShort = notice.destPortWharfEnShortName;
                                    }
                                    if (!destPortWharfFull && notice.destPortWharfEnFullName) {
                                        destPortWharfFull = notice.destPortWharfEnFullName;
                                    }
                                    if (destPortWharfShort && destPortWharfFull) {
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    
                    // 第三步：从scheduleNoticeShare.notices中提取（补充更多船期）
                    // 注意：scheduleNoticeShare可能是字符串（如"$a8"），需要先展开
                    let scheduleNoticeShareObj = fleet.scheduleNoticeShare;
                    if (scheduleNoticeShareObj && typeof scheduleNoticeShareObj === 'string' && scheduleNoticeShareObj.startsWith('$')) {
                        // 这是一个引用，尝试从labelIndex中展开（如果标准化工具没有展开）
                        // 注意：如果标准化工具已经展开，这里应该是对象
                        // 如果还是字符串，说明标准化工具没有展开，这里尝试展开
                        const expanded = resolveReferences(scheduleNoticeShareObj, labelIndex);
                        if (expanded && typeof expanded === 'object') {
                            scheduleNoticeShareObj = expanded;
                        }
                    }
                    if (scheduleNoticeShareObj && typeof scheduleNoticeShareObj === 'object' &&
                        scheduleNoticeShareObj.notices && Array.isArray(scheduleNoticeShareObj.notices)) {
                        // 展开notices数组中的引用（如"$131"）
                        const expandedNotices = [];
                        for (const item of scheduleNoticeShareObj.notices) {
                            if (typeof item === 'string' && item.startsWith('$')) {
                                // 这是一个引用，尝试展开
                                const expanded = resolveReferences(item, labelIndex);
                                if (Array.isArray(expanded)) {
                                    expandedNotices.push(...expanded);
                                } else if (expanded && typeof expanded === 'object') {
                                    expandedNotices.push(expanded);
                                }
                            } else {
                                expandedNotices.push(item);
                            }
                        }
                        // 过滤有效的船期对象
                        const filteredNotices = expandedNotices.filter(item => {
                            if (typeof item === 'string' && item.startsWith('$')) {
                                return false;
                            }
                            const isValid = item && 
                                           typeof item === 'object' && 
                                           !Array.isArray(item) && 
                                           item.vslName && 
                                           item.vslName !== 'BLANK SAILING' &&
                                           item.voyNo !== 'BLANK SAILING';
                            if (!isValid) return false;
                            // 放宽条件：由于已经从directFleets中提取，理论上都是直达的
                            // 只有在明确标记为转船（_isDirect === false）时才过滤
                            if (item._isDirect === false) {
                                return false; // 明确标记为转船，过滤
                            }
                            // 其他情况都保留（包括_isDirect为true、undefined）
                            return true;
                        });
                        // 合并到scheduleNotices（避免重复）
                        for (const notice of filteredNotices) {
                            const key = `${notice.vslName || ''}_${notice.voyNo || ''}`;
                            const exists = scheduleNotices.some(n => 
                                `${n.vslName || ''}_${n.voyNo || ''}` === key
                            );
                            if (!exists) {
                                scheduleNotices.push(notice);
                            }
                        }
                    }
                    
                    // 从directScheduleList中的carrier对象中提取scheduleNotices（补充更多船期）
                    // 注意：即使已经有scheduleNotices，也要从directScheduleList中补充，因为可能包含更多船期
                    if (fleet.directScheduleList && Array.isArray(fleet.directScheduleList)) {
                        for (const carrierItem of fleet.directScheduleList) {
                            // 跳过引用（字符串类型，以$开头）- 这些应该在标准化时已经解析
                            if (typeof carrierItem === 'string' && carrierItem.startsWith('$')) {
                                continue;
                            }
                            if (carrierItem && typeof carrierItem === 'object' && 
                                String(carrierItem.fleetId) === String(fleetId) &&
                                carrierItem.motherVesselPolCode === motherVesselPolCode) {
                                
                                // 提取scheduleNotices（即使没有scheduleNotices，也可能有scheduleNoticeShare）
                                if (carrierItem.scheduleNotices && Array.isArray(carrierItem.scheduleNotices)) {
                                    const filteredNotices = carrierItem.scheduleNotices.filter(item => {
                                        // 过滤掉引用（字符串类型，以$开头）
                                        if (typeof item === 'string' && item.startsWith('$')) {
                                            return false;
                                        }
                                        // 如果是数组，展开数组中的每个元素
                                        if (Array.isArray(item)) {
                                            return item.length > 0;
                                        }
                                        // 只保留有效的对象，且有vslName，且不是BLANK SAILING
                                        const isValid = item && 
                                                       typeof item === 'object' && 
                                                       item.vslName && 
                                                       item.vslName !== 'BLANK SAILING' &&
                                                       item.voyNo !== 'BLANK SAILING';
                                        if (!isValid) return false;
                                        // 放宽条件：由于已经从directFleets中提取，理论上都是直达的
                                        // 只有在明确标记为转船（_isDirect === false）时才过滤
                                        if (item._isDirect === false) {
                                            return false; // 明确标记为转船，过滤
                                        }
                                        // 其他情况都保留（包括_isDirect为true、undefined）
                                        return true;
                                    });
                                    // 展开数组中的元素
                                    const expandedNotices = filteredNotices.flatMap(item => {
                                        if (Array.isArray(item)) {
                                            return item.filter(n => n && typeof n === 'object' && 
                                                              n._isDirect !== false); // 只过滤明确标记为转船的
                                        }
                                        return [item];
                                    });
                                    // 合并到总数组中（避免重复，基于vslName和voyNo）
                                    for (const notice of expandedNotices) {
                                        const key = `${notice.vslName || ''}_${notice.voyNo || ''}`;
                                        const exists = scheduleNotices.some(n => 
                                            `${n.vslName || ''}_${n.voyNo || ''}` === key
                                        );
                                        if (!exists) {
                                            scheduleNotices.push(notice);
                                        }
                                    }
                                }
                                
                                // 从carrierItem的scheduleNoticeShare.notices中提取（补充更多船期）
                                // 注意：scheduleNoticeShare可能是字符串（如"$a8"），需要先展开
                                let scheduleNoticeShareObj = carrierItem.scheduleNoticeShare;
                                if (scheduleNoticeShareObj && typeof scheduleNoticeShareObj === 'string' && scheduleNoticeShareObj.startsWith('$')) {
                                    // 这是一个引用，尝试从labelIndex中展开（如果标准化工具没有展开）
                                    // 注意：如果标准化工具已经展开，这里应该是对象
                                    // 如果还是字符串，说明标准化工具没有展开，这里尝试展开
                                    const expanded = resolveReferences(scheduleNoticeShareObj, labelIndex);
                                    if (expanded && typeof expanded === 'object') {
                                        scheduleNoticeShareObj = expanded;
                                    }
                                }
                                if (scheduleNoticeShareObj && typeof scheduleNoticeShareObj === 'object' &&
                                    scheduleNoticeShareObj.notices && Array.isArray(scheduleNoticeShareObj.notices)) {
                                    // 展开notices数组中的引用（如"$131"）
                                    const expandedNotices = [];
                                    for (const item of scheduleNoticeShareObj.notices) {
                                        if (typeof item === 'string' && item.startsWith('$')) {
                                            // 这是一个引用，尝试展开
                                            const expanded = resolveReferences(item, labelIndex);
                                            if (Array.isArray(expanded)) {
                                                expandedNotices.push(...expanded);
                                            } else if (expanded && typeof expanded === 'object') {
                                                expandedNotices.push(expanded);
                                            }
                                        } else {
                                            expandedNotices.push(item);
                                        }
                                    }
                                    // 过滤有效的船期对象
                                    const filteredNotices = expandedNotices.filter(item => {
                                        if (typeof item === 'string' && item.startsWith('$')) {
                                            return false;
                                        }
                                        const isValid = item && 
                                                       typeof item === 'object' && 
                                                       !Array.isArray(item) && 
                                                       item.vslName && 
                                                       item.vslName !== 'BLANK SAILING' &&
                                                       item.voyNo !== 'BLANK SAILING';
                                        if (!isValid) return false;
                                        // 放宽条件：由于已经从directFleets中提取，理论上都是直达的
                                        // 只有在明确标记为转船（_isDirect === false）时才过滤
                                        if (item._isDirect === false) {
                                            return false; // 明确标记为转船，过滤
                                        }
                                        // 其他情况都保留（包括_isDirect为true、undefined）
                                        return true;
                                    });
                                    // 合并到scheduleNotices（避免重复）
                                    for (const notice of filteredNotices) {
                                        const key = `${notice.vslName || ''}_${notice.voyNo || ''}`;
                                        const exists = scheduleNotices.some(n => 
                                            `${n.vslName || ''}_${n.voyNo || ''}` === key
                                        );
                                        if (!exists) {
                                            scheduleNotices.push(notice);
                                        }
                                    }
                                }
                                
                                // 如果找到了目的港码头，也提取
                                if (!destPortWharfShort && carrierItem.destPortWharfEnShortName) {
                                    destPortWharfShort = carrierItem.destPortWharfEnShortName;
                                }
                                if (!destPortWharfFull && carrierItem.destPortWharfEnFullName) {
                                    destPortWharfFull = carrierItem.destPortWharfEnFullName;
                                }
                            }
                        }
                    }
                    
                    // 如果目的港码头还没有找到，尝试从scheduleNotices中的vessel对象中提取（有些vessel对象可能有目的港码头信息）
                    if ((!destPortWharfShort || !destPortWharfFull) && scheduleNotices.length > 0) {
                        for (const notice of scheduleNotices) {
                            if (notice && typeof notice === 'object' && !Array.isArray(notice)) {
                                if (!destPortWharfShort && notice.destPortWharfEnShortName) {
                                    destPortWharfShort = notice.destPortWharfEnShortName;
                                }
                                if (!destPortWharfFull && notice.destPortWharfEnFullName) {
                                    destPortWharfFull = notice.destPortWharfEnFullName;
                                }
                                // 如果已经找到了，跳出循环
                                if (destPortWharfShort && destPortWharfFull) {
                                    break;
                                }
                            }
                        }
                    }
                    
                    // 将Set转换为字符串（共舱船公司），格式：carrier1(svc1) | carrier2(svc2) | carrier3(svc3) fleetShowName
                    carriersStr = Array.from(carrierPartsSet).join(' | ');
                    // 添加fleetShowName（如果有）
                    if (fleet.fleetShowName) {
                        carriersStr = carriersStr ? `${carriersStr} ${fleet.fleetShowName}` : fleet.fleetShowName;
                    }
                    
                    // 只处理有scheduleNotices的fleet（确保有船期数据）
                    // 注意：scheduleNotices可能从多个来源提取（fleet.scheduleNotices, fleet.planSchedule, carrier对象等）
                    // 如果scheduleNotices为空，但fleet对象本身有planSchedule或scheduleNoticeShare，也应该处理（因为processFleetData会从_rawFleet中提取）
                    const hasScheduleData = scheduleNotices.length > 0 || 
                                          (fleet.planSchedule && Array.isArray(fleet.planSchedule) && fleet.planSchedule.length > 0) ||
                                          (fleet.scheduleNoticeShare && typeof fleet.scheduleNoticeShare === 'object' && 
                                           fleet.scheduleNoticeShare.notices && Array.isArray(fleet.scheduleNoticeShare.notices) && 
                                           fleet.scheduleNoticeShare.notices.length > 0) ||
                                          (fleet.directScheduleList && Array.isArray(fleet.directScheduleList) && fleet.directScheduleList.length > 0);
                    
                    if (hasScheduleData) {
                        // 如果已经存在相同的fleet对象，合并数据而不是创建新的
                        if (existingFleetIndex >= 0) {
                            const existingFleet = fleets[existingFleetIndex];
                            // 合并scheduleNotices（避免重复）
                            for (const notice of scheduleNotices) {
                                const key = `${notice.vslName || ''}_${notice.voyNo || ''}`;
                                const exists = existingFleet.scheduleNotices.some(n => 
                                    `${n.vslName || ''}_${n.voyNo || ''}` === key
                                );
                                if (!exists) {
                                    existingFleet.scheduleNotices.push(notice);
                                }
                            }
                            // 合并共舱船公司（使用Set避免重复）
                            if (carriersStr) {
                                const existingCarriers = existingFleet.sharedCabinCarriers || '';
                                const existingParts = existingCarriers.split(' | ').filter(p => p);
                                const newParts = carriersStr.split(' | ').filter(p => p);
                                const allParts = [...new Set([...existingParts, ...newParts])];
                                existingFleet.sharedCabinCarriers = allParts.join(' | ');
                            }
                            // 补充缺失的字段（如果现有fleet对象没有）
                            if (!existingFleet.weekday && weekday) existingFleet.weekday = String(weekday);
                            if (!existingFleet.shipDays && shipDays) existingFleet.shipDays = String(shipDays);
                            if (!existingFleet.wharfName && wharfName) existingFleet.wharfName = String(wharfName);
                            if (!existingFleet.destPortWharfEnShortName && destPortWharfShort) {
                                existingFleet.destPortWharfEnShortName = String(destPortWharfShort);
                            }
                            if (!existingFleet.destPortWharfEnFullName && destPortWharfFull) {
                                existingFleet.destPortWharfEnFullName = String(destPortWharfFull);
                            }
                            // 合并_rawFleet数据（保留更完整的数据）
                            if (fleet.directScheduleList && Array.isArray(fleet.directScheduleList) && fleet.directScheduleList.length > 0) {
                                if (!existingFleet._rawFleet.directScheduleList || existingFleet._rawFleet.directScheduleList.length === 0) {
                                    existingFleet._rawFleet.directScheduleList = fleet.directScheduleList;
                                } else {
                                    // 合并directScheduleList（避免重复）
                                    for (const carrierItem of fleet.directScheduleList) {
                                        if (carrierItem && typeof carrierItem === 'object') {
                                            const carrierKey = `${carrierItem.fleetId}_${carrierItem.motherVesselPolCode}_${carrierItem.carrierCode || ''}_${carrierItem.svcCode || ''}`;
                                            const exists = existingFleet._rawFleet.directScheduleList.some(c => 
                                                String(c.fleetId) === String(carrierItem.fleetId) &&
                                                c.motherVesselPolCode === carrierItem.motherVesselPolCode &&
                                                (c.carrierCode || '') === (carrierItem.carrierCode || '') &&
                                                (c.svcCode || '') === (carrierItem.svcCode || '')
                                            );
                                            if (!exists) {
                                                existingFleet._rawFleet.directScheduleList.push(carrierItem);
                                            }
                                        }
                                    }
                                }
                                // 重要：从合并后的directScheduleList中重新提取scheduleNotices（因为可能包含新的carrier对象）
                                // 遍历合并后的directScheduleList，提取所有carrier对象的scheduleNotices
                                const mergedDirectScheduleList = existingFleet._rawFleet.directScheduleList || [];
                                for (const carrierItem of mergedDirectScheduleList) {
                                    if (carrierItem && typeof carrierItem === 'object' && 
                                        String(carrierItem.fleetId) === String(fleetId) &&
                                        carrierItem.motherVesselPolCode === motherVesselPolCode) {
                                        // 提取scheduleNotices
                                        if (carrierItem.scheduleNotices && Array.isArray(carrierItem.scheduleNotices)) {
                                            const filteredNotices = carrierItem.scheduleNotices.filter(item => {
                                                if (typeof item === 'string' && item.startsWith('$')) {
                                                    return false;
                                                }
                                                if (Array.isArray(item)) {
                                                    return item.length > 0;
                                                }
                                                const isValid = item && 
                                                               typeof item === 'object' && 
                                                               item.vslName && 
                                                               item.vslName !== 'BLANK SAILING' &&
                                                               item.voyNo !== 'BLANK SAILING';
                                                if (!isValid) return false;
                                                if (item._isDirect === false) {
                                                    return false;
                                                }
                                                return true;
                                            });
                                            const expandedNotices = filteredNotices.flatMap(item => {
                                                if (Array.isArray(item)) {
                                                    return item.filter(n => n && typeof n === 'object' && 
                                                                      n._isDirect !== false);
                                                }
                                                return [item];
                                            });
                                            // 合并到existingFleet.scheduleNotices（避免重复）
                                            for (const notice of expandedNotices) {
                                                const key = `${notice.vslName || ''}_${notice.voyNo || ''}`;
                                                const exists = existingFleet.scheduleNotices.some(n => 
                                                    `${n.vslName || ''}_${n.voyNo || ''}` === key
                                                );
                                                if (!exists) {
                                                    existingFleet.scheduleNotices.push(notice);
                                                }
                                            }
                                        }
                                        // 提取scheduleNoticeShare.notices
                                        let carrierScheduleNoticeShareObj = carrierItem.scheduleNoticeShare;
                                        if (carrierScheduleNoticeShareObj && typeof carrierScheduleNoticeShareObj === 'string' && carrierScheduleNoticeShareObj.startsWith('$')) {
                                            const expanded = resolveReferences(carrierScheduleNoticeShareObj, labelIndex);
                                            if (expanded && typeof expanded === 'object') {
                                                carrierScheduleNoticeShareObj = expanded;
                                            }
                                        }
                                        if (carrierScheduleNoticeShareObj && typeof carrierScheduleNoticeShareObj === 'object' &&
                                            carrierScheduleNoticeShareObj.notices && Array.isArray(carrierScheduleNoticeShareObj.notices)) {
                                            const expandedNotices = [];
                                            for (const item of carrierScheduleNoticeShareObj.notices) {
                                                if (typeof item === 'string' && item.startsWith('$')) {
                                                    const expanded = resolveReferences(item, labelIndex);
                                                    if (Array.isArray(expanded)) {
                                                        expandedNotices.push(...expanded);
                                                    } else if (expanded && typeof expanded === 'object') {
                                                        expandedNotices.push(expanded);
                                                    }
                                                } else {
                                                    expandedNotices.push(item);
                                                }
                                            }
                                            const filteredNotices = expandedNotices.filter(item => {
                                                if (typeof item === 'string' && item.startsWith('$')) {
                                                    return false;
                                                }
                                                const isValid = item && 
                                                               typeof item === 'object' && 
                                                               !Array.isArray(item) && 
                                                               item.vslName && 
                                                               item.vslName !== 'BLANK SAILING' &&
                                                               item.voyNo !== 'BLANK SAILING';
                                                if (!isValid) return false;
                                                if (item._isDirect === false) {
                                                    return false;
                                                }
                                                return true;
                                            });
                                            // 合并到existingFleet.scheduleNotices（避免重复）
                                            for (const notice of filteredNotices) {
                                                const key = `${notice.vslName || ''}_${notice.voyNo || ''}`;
                                                const exists = existingFleet.scheduleNotices.some(n => 
                                                    `${n.vslName || ''}_${n.voyNo || ''}` === key
                                                );
                                                if (!exists) {
                                                    existingFleet.scheduleNotices.push(notice);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            if (fleet.planSchedule && Array.isArray(fleet.planSchedule) && fleet.planSchedule.length > 0) {
                                if (!existingFleet._rawFleet.planSchedule || existingFleet._rawFleet.planSchedule.length === 0) {
                                    existingFleet._rawFleet.planSchedule = fleet.planSchedule;
                                }
                            }
                        } else {
                            // 创建新的fleet对象
                            const fleetObj = {
                                fleetId: String(fleetId), // 确保是字符串类型
                                fleetIdPort: String(portId), // 港口ID：CNTAO
                                lineId: String(lineId), // 航线ID：188（中间部分）
                                motherVesselPolCode: String(motherVesselPolCode), // 港口代码：CNTAO
                                podCode: fleet.podCode || '',
                                weekday: String(weekday || ''), // 开航日（从主fleet对象的weekday字段提取）
                                shipDays: String(shipDays || ''), // 航程（从主fleet对象的shipDays字段提取）
                                wharfName: String(wharfName || ''), // 启运港码头（从主fleet对象的wharfName字段提取）
                                fleetShowName: fleet.fleetShowName || '',
                                sharedCabinCarriers: String(carriersStr || ''), // 共舱船公司（已格式化，从sharedCabinCarriers和carrier对象中提取）
                                scheduleNotices: scheduleNotices, // 船期信息（从scheduleNotices提取）
                                destPortWharfEnShortName: String(destPortWharfShort || ''), // 目的港码头简写
                                destPortWharfEnFullName: String(destPortWharfFull || ''), // 目的港码头全称
                                // 保存完整的fleet对象，以便后续处理
                                _rawFleet: fleet,
                                // 确保origin和dest字段也被设置（用于processVesselData）
                                origin: '',
                                dest: ''
                            };
                            fleets.push(fleetObj);
                        }
                    }
                }
                
                // 重要：从vessels数组中提取vessel对象，并将它们分配到相应的fleet对象中
                // 注意：此功能已暂时禁用，因为vessels数组中的vessel对象没有fleetId，匹配不够精确，可能导致误匹配
                // 只使用fleet对象中已有的数据源（scheduleNotices、planSchedule、directScheduleList等）更可靠
                // 如果需要启用此功能，请确保vessel对象有明确的fleetId和motherVesselPolCode字段
                if (false && jsonData.vessels && Array.isArray(jsonData.vessels) && jsonData.vessels.length > 0) {
                    // 为每个fleet对象创建一个vessel映射（用于快速查找）
                    const fleetVesselMap = new Map(); // key: fleetId_motherVesselPolCode, value: Set<vesselKey>
                    // 全局vessel匹配记录：记录每个vessel对象已经匹配到哪个fleet对象（避免重复匹配）
                    const globalVesselMatchedFleet = new Map(); // key: vesselKey, value: fleetKey
                    for (const fleet of fleets) {
                        const fleetKey = `${fleet.fleetId}_${fleet.motherVesselPolCode}`;
                        const vesselSet = new Set();
                        // 收集该fleet对象中已有的vessel对象（基于船名+航次）
                        if (fleet.scheduleNotices && Array.isArray(fleet.scheduleNotices)) {
                            for (const notice of fleet.scheduleNotices) {
                                if (notice && typeof notice === 'object' && notice.vslName && notice.voyNo) {
                                    const vesselKey = `${notice.vslName}_${notice.voyNo}`;
                                    vesselSet.add(vesselKey);
                                    // 记录这个vessel对象已经属于这个fleet对象
                                    globalVesselMatchedFleet.set(vesselKey, fleetKey);
                                }
                            }
                        }
                        fleetVesselMap.set(fleetKey, vesselSet);
                    }
                    
                    // 遍历vessels数组，将vessel对象分配到相应的fleet对象中
                    for (const vessel of jsonData.vessels) {
                        // 跳过无效的vessel对象
                        if (!vessel || typeof vessel !== 'object') continue;
                        if (!vessel.vslName || !vessel.voyNo) continue;
                        if (vessel.vslName === 'BLANK SAILING' || vessel.voyNo === 'BLANK SAILING') continue;
                        
                        // 重要：只处理明确标记为直达的vessel对象，或者没有标记的vessel对象（默认认为是直达）
                        // 如果明确标记为转船（_isDirect === false），跳过
                        if (vessel._isDirect === false) {
                            continue;
                        }
                        
                        const vesselKey = `${vessel.vslName}_${vessel.voyNo}`;
                        
                        // 尝试找到匹配的fleet对象
                        // 策略1：如果vessel对象有fleetId和motherVesselPolCode，直接匹配（最高优先级）
                        if (vessel.fleetId && vessel.motherVesselPolCode) {
                            const fleetKey = `${vessel.fleetId}_${vessel.motherVesselPolCode}`;
                            const existingFleet = fleets.find(f => 
                                String(f.fleetId) === String(vessel.fleetId) && 
                                f.motherVesselPolCode === vessel.motherVesselPolCode
                            );
                            if (existingFleet) {
                                // 检查这个vessel对象是否已经匹配到其他fleet对象
                                const existingMatchedFleet = globalVesselMatchedFleet.get(vesselKey);
                                if (existingMatchedFleet && existingMatchedFleet !== fleetKey) {
                                    // 已经匹配到其他fleet对象，跳过（避免重复匹配）
                                    continue;
                                }
                                const vesselSet = fleetVesselMap.get(fleetKey) || new Set();
                                if (!vesselSet.has(vesselKey)) {
                                    // 这个vessel对象还没有在该fleet对象中，添加它
                                    if (!existingFleet.scheduleNotices) {
                                        existingFleet.scheduleNotices = [];
                                    }
                                    existingFleet.scheduleNotices.push(vessel);
                                    vesselSet.add(vesselKey);
                                    fleetVesselMap.set(fleetKey, vesselSet);
                                    // 记录这个vessel对象已经匹配到这个fleet对象
                                    globalVesselMatchedFleet.set(vesselKey, fleetKey);
                                }
                                continue;
                            }
                        }
                        
                        // 策略2：通过船名、航次等信息匹配（如果vessel对象没有fleetId）
                        // 遍历所有fleet对象，查找是否有匹配的vessel对象（基于船名+航次）
                        // 注意：这种方法可能不够精确，但可以补充一些遗漏的vessel对象
                        let matched = false;
                        for (const fleet of fleets) {
                            const fleetKey = `${fleet.fleetId}_${fleet.motherVesselPolCode}`;
                            const vesselSet = fleetVesselMap.get(fleetKey) || new Set();
                            
                            // 检查该fleet对象是否已经有这个vessel对象
                            if (vesselSet.has(vesselKey)) {
                                matched = true;
                                break;
                            }
                            
                            // 检查该fleet对象的scheduleNotices中是否有相同的船名+航次
                            if (fleet.scheduleNotices && Array.isArray(fleet.scheduleNotices)) {
                                const hasSameVessel = fleet.scheduleNotices.some(notice => 
                                    notice && typeof notice === 'object' &&
                                    notice.vslName === vessel.vslName &&
                                    notice.voyNo === vessel.voyNo
                                );
                                if (hasSameVessel) {
                                    matched = true;
                                    vesselSet.add(vesselKey);
                                    fleetVesselMap.set(fleetKey, vesselSet);
                                    break;
                                }
                            }
                        }
                        
                        // 如果还没有匹配，尝试通过更智能的方式匹配（策略3：通过共舱船公司、日期等信息）
                        // 注意：这种方法可能不够精确，但可以补充一些遗漏的vessel对象
                        if (!matched) {
                            // 尝试通过vessel对象的特征（如船名、航次、日期等）与fleet对象匹配
                            // 策略3.1：从船名推断carrierCode（如ZIM DIAMOND -> ZIM, MSC LORETO -> MSC）
                            // 常见的船公司前缀映射
                            const carrierPrefixMap = {
                                'ZIM': 'ZIM',
                                'MSC': 'MSC',
                                'CMA': 'CMA',
                                'COSCO': 'COSCO',
                                'EVER': 'EVER',
                                'ONE': 'ONE',
                                'HMM': 'HMM',
                                'OOCL': 'OOCL',
                                'YANG': 'YANG',
                                'WAN': 'WAN',
                                'SITC': 'SITC',
                                'PIL': 'PIL',
                                'HAPAG': 'HAPAG',
                                'HAMBURG': 'HAMBURG',
                                'MAERSK': 'MAERSK',
                                'MADISON': 'MAERSK',
                                'HYUNDAI': 'HYUNDAI',
                                'PANDA': 'TAILWIND',
                                'JADRANA': 'TAILWIND'
                            };
                            
                            // 从船名推断carrierCode
                            let inferredCarrierCode = '';
                            if (vessel.vslName) {
                                for (const [prefix, carrier] of Object.entries(carrierPrefixMap)) {
                                    if (vessel.vslName.toUpperCase().startsWith(prefix)) {
                                        inferredCarrierCode = carrier;
                                        break;
                                    }
                                }
                            }
                            
                            // 策略3.1：如果vessel对象有carrierCode或carrierShortName，或者从船名推断出carrierCode，尝试通过共舱船公司匹配
                            // 重要：只匹配直达航线的fleet对象（_isDirect === true或undefined）
                            // 关键改进：确保每个vessel对象只匹配到一个fleet对象（优先匹配第一个符合条件的fleet对象）
                            const vesselCarrierCode = vessel.carrierCode || vessel.carrierShortName || inferredCarrierCode;
                            if (vesselCarrierCode) {
                                // 检查这个vessel对象是否已经匹配到其他fleet对象
                                const existingMatchedFleet = globalVesselMatchedFleet.get(vesselKey);
                                if (existingMatchedFleet) {
                                    // 已经匹配到其他fleet对象，跳过（避免重复匹配）
                                    matched = true;
                                } else {
                                    // 还没有匹配，尝试匹配第一个符合条件的fleet对象
                                    for (const fleet of fleets) {
                                        // 只处理直达航线的fleet对象
                                        if (fleet._isDirect === false) {
                                            continue;
                                        }
                                        // 检查该fleet对象的sharedCabinCarriers中是否包含vessel的carrierCode
                                        let hasCarrier = false;
                                        if (fleet.sharedCabinCarriers && typeof fleet.sharedCabinCarriers === 'string') {
                                            hasCarrier = fleet.sharedCabinCarriers.includes(vesselCarrierCode);
                                        } else if (fleet.sharedCabinCarriers && Array.isArray(fleet.sharedCabinCarriers)) {
                                            hasCarrier = fleet.sharedCabinCarriers.some(carrier => 
                                                carrier && typeof carrier === 'object' &&
                                                (carrier.carrierCode === vesselCarrierCode || 
                                                 carrier.carrierShortName === vesselCarrierCode)
                                            );
                                        } else if (fleet._rawFleet && fleet._rawFleet.sharedCabinCarriers) {
                                            // 检查_rawFleet中的sharedCabinCarriers
                                            const rawCarriers = fleet._rawFleet.sharedCabinCarriers;
                                            if (Array.isArray(rawCarriers)) {
                                                hasCarrier = rawCarriers.some(carrier => 
                                                    carrier && typeof carrier === 'object' &&
                                                    (carrier.carrierCode === vesselCarrierCode || 
                                                     carrier.carrierShortName === vesselCarrierCode)
                                                );
                                            }
                                        }
                                        
                                        if (hasCarrier) {
                                            // 找到匹配的fleet对象，添加vessel对象（只匹配第一个符合条件的fleet对象）
                                            const fleetKey = `${fleet.fleetId}_${fleet.motherVesselPolCode}`;
                                            const vesselSet = fleetVesselMap.get(fleetKey) || new Set();
                                            if (!vesselSet.has(vesselKey)) {
                                                if (!fleet.scheduleNotices) {
                                                    fleet.scheduleNotices = [];
                                                }
                                                fleet.scheduleNotices.push(vessel);
                                                vesselSet.add(vesselKey);
                                                fleetVesselMap.set(fleetKey, vesselSet);
                                                // 记录这个vessel对象已经匹配到这个fleet对象
                                                globalVesselMatchedFleet.set(vesselKey, fleetKey);
                                                matched = true;
                                                break; // 只匹配第一个符合条件的fleet对象，避免重复匹配
                                            }
                                        }
                                    }
                                }
                            }
                            
                            // 策略3.2：如果还没有匹配，尝试通过_rawFleet中的directScheduleList匹配
                            // 检查vessel对象是否在某个fleet对象的directScheduleList的carrier对象的scheduleNotices中
                            // 重要：只匹配直达航线的fleet对象
                            // 关键改进：确保每个vessel对象只匹配到一个fleet对象
                            if (!matched) {
                                // 检查这个vessel对象是否已经匹配到其他fleet对象
                                const existingMatchedFleet = globalVesselMatchedFleet.get(vesselKey);
                                if (!existingMatchedFleet) {
                                    // 还没有匹配，尝试匹配第一个符合条件的fleet对象
                                    for (const fleet of fleets) {
                                        // 只处理直达航线的fleet对象
                                        if (fleet._isDirect === false) {
                                            continue;
                                        }
                                        if (fleet._rawFleet && fleet._rawFleet.directScheduleList && 
                                            Array.isArray(fleet._rawFleet.directScheduleList)) {
                                            // 检查directScheduleList中的carrier对象是否有相同的vessel对象
                                            const hasVesselInDirectScheduleList = fleet._rawFleet.directScheduleList.some(carrierItem => {
                                                if (carrierItem && typeof carrierItem === 'object' &&
                                                    carrierItem.scheduleNotices && Array.isArray(carrierItem.scheduleNotices)) {
                                                    return carrierItem.scheduleNotices.some(notice =>
                                                        notice && typeof notice === 'object' &&
                                                        notice.vslName === vessel.vslName &&
                                                        notice.voyNo === vessel.voyNo
                                                    );
                                                }
                                                return false;
                                            });
                                            if (hasVesselInDirectScheduleList) {
                                                // 找到匹配的fleet对象，添加vessel对象（只匹配第一个符合条件的fleet对象）
                                                const fleetKey = `${fleet.fleetId}_${fleet.motherVesselPolCode}`;
                                                const vesselSet = fleetVesselMap.get(fleetKey) || new Set();
                                                if (!vesselSet.has(vesselKey)) {
                                                    if (!fleet.scheduleNotices) {
                                                        fleet.scheduleNotices = [];
                                                    }
                                                    fleet.scheduleNotices.push(vessel);
                                                    vesselSet.add(vesselKey);
                                                    fleetVesselMap.set(fleetKey, vesselSet);
                                                    // 记录这个vessel对象已经匹配到这个fleet对象
                                                    globalVesselMatchedFleet.set(vesselKey, fleetKey);
                                                    matched = true;
                                                    break; // 只匹配第一个符合条件的fleet对象，避免重复匹配
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                // 如果已经成功解析，直接返回
                if (fleets.length > 0) {
                    // 调试信息：检查提取的fleet数据
                    if (typeof window !== 'undefined' && typeof window.debugWarn === 'function') {
                        window.debugWarn(`[extractFleetAndVessels] 成功提取 ${fleets.length} 个fleet对象`);
                        if (fleets.length > 0) {
                            const firstFleet = fleets[0];
                            window.debugWarn(`[extractFleetAndVessels] 第一个fleet: lineId=${firstFleet.lineId}, portId=${firstFleet.fleetIdPort}, weekday=${firstFleet.weekday}, shipDays=${firstFleet.shipDays}, wharfName=${firstFleet.wharfName}, carriers=${firstFleet.sharedCabinCarriers}, scheduleNotices=${firstFleet.scheduleNotices ? firstFleet.scheduleNotices.length : 0}`);
                        }
        }
        return fleets;
                }
            }
        } catch (error) {
            // JSON解析失败，返回空数组（不再使用旧的正则匹配策略，避免提取不完整的数据）
            console.warn('解析展开的JSON失败:', error);
        }
        
        // 如果没有成功解析，返回空数组（确保只处理directFleets）
        return [];
    }

    /**
     * 提取启运港和目的港
     * 优先：在任意对象片段中查找 start/dest 四个字段（适配 fc:{...} 结构）
     * 次级：DOM 上方提示条
     * 兜底：正则匹配"由...发往..."
     * @param {string} html - HTML 文本
     * @returns {Object} 包含 origin 和 dest 的对象
     */
    function extractOriginDest(html) {
        const jsonMatch = html.match(/"startPortEnName"\s*:\s*"([^"]+)"[\s\S]*?"startPortCnName"\s*:\s*"([^"]+)"[\s\S]*?"destPortEnName"\s*:\s*"([^"]+)"[\s\S]*?"destPortCnName"\s*:\s*"([^"]+)"/);
        if (jsonMatch) {
            const origin = `${jsonMatch[1]}(${jsonMatch[2]})`;
            const dest = `${jsonMatch[3]}(${jsonMatch[4]})`;
            return { origin, dest };
        }
        try {
            const doc = new DOMParser().parseFromString(html, 'text/html');
            const bar = doc.querySelector('span.flex.items-center.text-\\[12px\\]');
            if (bar) {
                const strongs = Array.from(bar.querySelectorAll('span.font-bold'));
                const originText = strongs[0] ? (strongs[0].textContent || '').trim() : '';
                const destText = strongs[1] ? (strongs[1].textContent || '').trim() : '';
                if (originText && destText) {
                    return { origin: originText, dest: destText };
                }
            }
        } catch (error) {
            // DOM 解析失败，继续尝试其他方法
        }
        const textMatchPattern = new RegExp(
            '>\\s*([A-Z][A-Z\\s]+)<!-- -->\\(<!-- -->([\\u4e00-\\u9fa5]+)<!-- -->\\)</span>发往</span[^>]*>\\s*([A-Z][A-Z\\s]+)<!-- -->\\(<!-- -->([\\u4e00-\\u9fa5]+)<!-- -->\\)\\s*</span>'
        );
        const textMatch = html.match(textMatchPattern);
        if (textMatch) {
            return {
                origin: `${textMatch[1].trim()}(${textMatch[2]})`,
                dest: `${textMatch[3].trim()}(${textMatch[4]})`
            };
        }
        return { origin: '', dest: '' };
    }

    /**
     * 从字符串中提取日期部分（YYYY/MM/DD 格式）
     * @param {string} dateString - 包含日期的字符串
     * @returns {string} 提取的日期字符串，如果未找到则返回空字符串
     */
    function datePart(dateString) {
        if (!dateString) return '';
        const dateMatch = String(dateString).match(/(\d{4}\/\d{2}\/\d{2})/);
        return dateMatch ? dateMatch[1] : '';
    }

    /**
     * 从对象中提取船名（尝试多个字段名）
     * @param {Object} obj - 对象
     * @returns {string} 船名
     */
    function extractVesselName(obj) {
        if (!obj) return '';
        return obj.vslName 
            || obj.vesselName 
            || obj.vslNameEn 
            || obj.vesselNameEn
            || obj.shipName
            || obj.name
            || '';
    }

    /**
     * 从对象中提取航次（尝试多个字段名）
     * @param {Object} obj - 对象
     * @returns {string} 航次
     */
    function extractVoyage(obj) {
        if (!obj) return '';
        return obj.voyNo 
            || obj.voyageNo 
            || obj.voyNoEn
            || obj.voyage
            || obj.voy
            || '';
    }

    /**
     * 从对象中提取计划开航日期（尝试多个字段名和格式）
     * @param {Object} obj - 对象
     * @returns {string} 计划开航日期（YYYY/MM/DD格式）
     */
    function extractPlanDate(obj) {
        if (!obj) return '';
        // 尝试多个字段名（增强：增加更多可能的字段名，包括标准化HTML中的carrierETDFormatter和planBerthDate）
        let dateStr = obj.carrierETDFormatter  // 标准化HTML中的完整日期格式
            || obj.etdFormatter 
            || obj.portSailingDateFormatter
            || obj.etd
            || obj.sailingDate
            || obj.portSailingDate
            || obj.etdDate
            || obj.planDate
            || obj.planEtd
            || obj.etdPlan
            || obj.planSailingDate
            || obj.scheduledDepartureDate
            || obj.departureDate
            || obj.etdDateFormatter
            || '';
        
        // 如果dateStr为空，尝试从planBerthDate提取（格式："2026-01-06 04:00 (周二)"）
        if (!dateStr && obj.planBerthDate) {
            const planBerthMatch = obj.planBerthDate.match(/(\d{4}-\d{2}-\d{2})/);
            if (planBerthMatch) {
                dateStr = planBerthMatch[1].replace(/-/g, '/');
            }
        }
        
        return datePart(dateStr);
    }

    /**
     * 从对象中提取预计到港日期（尝试多个字段名和格式）
     * @param {Object} obj - 对象
     * @returns {string} 预计到港日期（YYYY/MM/DD格式）
     */
    function extractEtaDate(obj) {
        if (!obj) return '';
        // 尝试多个字段名
        const dateStr = obj.etaFormatter 
            || obj.eta
            || obj.etaDate
            || obj.estimatedArrivalDate
            || obj.arrivalDate
            || '';
        return datePart(dateStr);
    }

    /**
     * 从HTML文本中补充缺失的船名、航次、日期等信息（优化版本）
     * @param {string} decodedHtml - 解码后的HTML文本
     * @param {string} lineId - 航线ID
     * @param {string} portId - 港口ID
     * @param {Object} missingData - 缺失的数据对象 {vesselName, voyage, plan, eta, weekday, shipdays, polWharf, podWharf}
     * @param {Map} visibleData - 可见数据Map（可选）
     * @returns {Object} 补充后的数据对象
     */
    function supplementMissingData(decodedHtml, lineId, portId, missingData, visibleData = null) {
        const result = {...missingData};
        
        // 优先从可见数据中提取计划开航/预计到港/目的港码头
        if (visibleData && visibleData.size > 0 && (missingData.vesselName || missingData.voyage)) {
            const visibleKey = `${lineId}_${portId}_${missingData.vesselName || ''}_${missingData.voyage || ''}`;
            const visibleInfo = visibleData.get(visibleKey) || 
                              visibleData.get(`${lineId}_${portId}_${clean(missingData.vesselName || '')}_${clean(missingData.voyage || '')}`) ||
                              visibleData.get(`${lineId}_${portId}_${(missingData.vesselName || '').toUpperCase()}_${(missingData.voyage || '').toUpperCase()}`);
            
            if (visibleInfo) {
                if (!result.plan && visibleInfo.planDate) {
                    result.plan = visibleInfo.planDate;
                }
                if (!result.eta && visibleInfo.etaDate) {
                    result.eta = visibleInfo.etaDate;
                }
                if (!result.podWharf && visibleInfo.podWharf) {
                    result.podWharf = visibleInfo.podWharf;
                }
            }
        }
        
        // 检查是否所有关键数据都已存在（允许部分字段为空）
        const hasAllCritical = result.vesselName && result.voyage && result.plan && result.eta;
        if (hasAllCritical && result.weekday && result.shipdays && result.podWharf) {
            return result;
        }

        // 优化：只在需要时才搜索，减少搜索范围
        // 尝试从包含航线ID和港口ID的上下文中提取（缩小搜索范围，增强匹配精度）
        // 使用更精确的模式，确保fleetId和motherVesselPolCode在同一fleet块中
        // 注意：lineId实际上是fleetId，portId实际上是motherVesselPolCode（如"CNTAO"）
        const contextPattern = new RegExp(
            `"fleetId"\\s*:\\s*${lineId}[\\s\\S]{0,500}"motherVesselPolCode"\\s*:\\s*"${portId}"[\\s\\S]{0,10000}`,
            'i'
        );
        const contextMatch = decodedHtml.match(contextPattern);
        let context = null;
        if (contextMatch) {
            let candidateContext = contextMatch[0];
            
            // 验证：确保context中包含正确的fleetId和motherVesselPolCode
            // 注意：lineId实际上是fleetId，portId实际上是motherVesselPolCode（如"CNTAO"）
            const contextFleetIdMatch = candidateContext.match(/"fleetId"\s*:\s*(\d+)/i);
            const contextMotherVesselPolCodeMatch = candidateContext.match(/"motherVesselPolCode"\s*:\s*"([^"]+)"/i);
            if (contextFleetIdMatch && contextMotherVesselPolCodeMatch) {
                const contextFleetId = contextFleetIdMatch[1];
                const contextMotherVesselPolCode = contextMotherVesselPolCodeMatch[1];
                // 如果fleetId和motherVesselPolCode匹配，使用这个context
                if (contextFleetId === lineId && contextMotherVesselPolCode === portId) {
                    context = candidateContext;
                } else {
                    // 如果不匹配，尝试查找正确的fleet块（使用motherVesselPolCode）
                    const correctFleetPattern = new RegExp(
                        `"fleetId"\\s*:\\s*${lineId}[\\s\\S]{0,500}"motherVesselPolCode"\\s*:\\s*"${portId}"[\\s\\S]{0,10000}(?="fleetId"|$)`,
                        'i'
                    );
                    const correctFleetMatch = decodedHtml.match(correctFleetPattern);
                    if (correctFleetMatch) {
                        context = correctFleetMatch[0];
                    }
                }
            } else {
                // 如果没有找到motherVesselPolCode，直接使用candidateContext（可能包含fleetIdPort）
                context = candidateContext;
            }
        }
        
        if (context) {
            // 优先从fleet对象级别提取开航日、航程、启运港码头（这些字段通常在fleet对象中，而不是vessel对象中）
            if (!result.weekday) {
                const match = context.match(/"weekday"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"weekdayOfETDFormatter"\s*:\s*"([^"]+)"/i);
                if (match && match[1]) {
                    result.weekday = clean(match[1]);
                }
            }
            
            if (!result.shipdays) {
                const match = context.match(/"shipDays"\s*:\s*(\d+)/i) ||
                             context.match(/"shipdays"\s*:\s*(\d+)/i);
                if (match && match[1]) {
                    result.shipdays = clean(match[1]);
                }
            }
            
            if (!result.polWharf) {
                const match = context.match(/"wharfName"\s*:\s*"([^"]+)"/i);
                if (match && match[1]) {
                    result.polWharf = normalizeWharfTokens(clean(match[1]));
                }
            }
            
            // 一次性匹配所有需要的字段，减少循环次数
            if (!result.vesselName) {
                const match = context.match(/"vslName"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"vesselName"\s*:\s*"([^"]+)"/i);
                if (match && match[1]) {
                    result.vesselName = clean(match[1]);
                }
            }
            
            if (!result.voyage) {
                const match = context.match(/"voyNo"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"voyageNo"\s*:\s*"([^"]+)"/i);
                if (match && match[1]) {
                    result.voyage = clean(match[1]);
                }
            }
            
            if (!result.plan) {
                // 增强计划开航提取：尝试更多字段（包括数字格式的日期）
                const match = context.match(/"etdFormatter"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"portSailingDateFormatter"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"etd"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"sailingDate"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"portSailingDate"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"etdDate"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"planDate"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"planEtd"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"etdPlan"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"planSailingDate"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"scheduledDepartureDate"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"departureDate"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"etdDateFormatter"\s*:\s*"([^"]+)"/i) ||
                             // 增强：尝试匹配数字格式的日期（如 "etd": 1735689600000）
                             context.match(/"etd"\s*:\s*(\d{10,13})/i) ||
                             context.match(/"etdDate"\s*:\s*(\d{10,13})/i) ||
                             context.match(/"planDate"\s*:\s*(\d{10,13})/i) ||
                             context.match(/"sailingDate"\s*:\s*(\d{10,13})/i);
                if (match && match[1]) {
                    // 如果是时间戳（数字），转换为日期格式
                    if (/^\d{10,13}$/.test(match[1])) {
                        const timestamp = parseInt(match[1], 10);
                        // 处理毫秒和秒两种格式
                        const date = new Date(timestamp > 1000000000000 ? timestamp : timestamp * 1000);
                        if (!isNaN(date.getTime())) {
                            const year = date.getFullYear();
                            const month = String(date.getMonth() + 1).padStart(2, '0');
                            const day = String(date.getDate()).padStart(2, '0');
                            result.plan = `${year}/${month}/${day}`;
                        }
                    } else {
                        result.plan = datePart(match[1]);
                    }
                }
            }
            
            if (!result.eta) {
                // 增强预计到港提取：尝试更多字段
                const match = context.match(/"etaFormatter"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"eta"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"etaDate"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"estimatedArrivalDate"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"arrivalDate"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"ataFormatter"\s*:\s*"([^"]+)"/i);
                if (match && match[1]) {
                    result.eta = datePart(match[1]);
                }
            }
            
            // 补充开航日（weekday）- 增强提取逻辑，尝试更多字段
            if (!result.weekday) {
                const match = context.match(/"weekdayOfETDFormatter"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"weekday"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"etdWeekday"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"weekdayOfETD"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"sailingWeekday"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"departureWeekday"\s*:\s*"([^"]+)"/i);
                if (match && match[1]) {
                    result.weekday = clean(match[1]);
                }
            }
            
            // 补充航程（shipdays）- 增强提取逻辑
            if (!result.shipdays) {
                const match = context.match(/"shipdays"\s*:\s*(\d+)/i) ||
                             context.match(/"shipDays"\s*:\s*(\d+)/i) ||
                             context.match(/"duration"\s*:\s*(\d+)/i) ||
                             context.match(/"transitTime"\s*:\s*(\d+)/i) ||
                             context.match(/"transitDays"\s*:\s*(\d+)/i) ||
                             context.match(/"shipdays"\s*:\s*"(\d+)"/i) ||
                             context.match(/"shipDays"\s*:\s*"(\d+)"/i) ||
                             context.match(/"duration"\s*:\s*"(\d+)"/i);
                if (match && match[1]) {
                    result.shipdays = clean(match[1]);
                }
            }
            
            // 补充起运港码头（polWharf）- 增强提取逻辑，同时提取简写和全称
            if (!result.polWharf) {
                const polShortMatch = context.match(/"startPortWharfEnShortName"\s*:\s*"([^"]+)"/i);
                const polFullMatch = context.match(/"startPortWharfEnFullName"\s*:\s*"([^"]+)"/i);
                let polShort = polShortMatch ? clean(polShortMatch[1]) : '';
                let polFull = polFullMatch ? clean(polFullMatch[1]) : '';
                
                // 如果都没有，尝试其他字段
                if (!polShort && !polFull) {
                    const polMatch = context.match(/"wharfName"\s*:\s*"([^"]+)"/i) ||
                                   context.match(/"polWharf"\s*:\s*"([^"]+)"/i) ||
                                   context.match(/"startPortTerminal"\s*:\s*"([^"]+)"/i);
                    if (polMatch && polMatch[1]) {
                        polShort = clean(polMatch[1]);
                    }
                }
                
                // 规范化并组合
                polShort = normalizeWharfTokens(polShort);
                polFull = normalizeWharfTokens(polFull);
                
                if (polShort && polFull) {
                    result.polWharf = `${polShort}/${polFull}`;
                } else if (polShort) {
                    result.polWharf = polShort;
                } else if (polFull) {
                    result.polWharf = polFull;
                }
            }
            
            // 补充目的港码头（podWharf）- 增强提取逻辑，确保同时提取简写和全称
            // 检查是否只有简写（没有/分隔符且长度较短），如果是，尝试补充全称
            const hasPodWharf = result.podWharf && result.podWharf.trim();
            const podWharfOnlyShort = hasPodWharf && !result.podWharf.includes('/') && result.podWharf.length < 15;
            
            if (!result.podWharf || podWharfOnlyShort) {
                // 优先从整个context中搜索，确保不遗漏
                // 尝试提取目的港码头的缩写和全称
                const podShortMatch = context.match(/"destPortWharfEnShortName"\s*:\s*"([^"]+)"/i);
                const podFullMatch = context.match(/"destPortWharfEnFullName"\s*:\s*"([^"]+)"/i);
                let podShort = podShortMatch ? clean(podShortMatch[1]) : '';
                let podFull = podFullMatch ? clean(podFullMatch[1]) : '';
                
                // 如果都没有，尝试其他字段
                if (!podShort && !podFull) {
                    const podMatch = context.match(/"podWharf"\s*:\s*"([^"]+)"/i) ||
                                   context.match(/"destPortTerminal"\s*:\s*"([^"]+)"/i);
                    if (podMatch && podMatch[1]) {
                        podShort = clean(podMatch[1]);
                    }
                }
                
                // 规范化并组合
                podShort = normalizeWharfTokens(podShort);
                podFull = normalizeWharfTokens(podFull);
                
                // 如果已有简写，优先使用已有的
                if (podWharfOnlyShort && result.podWharf) {
                    podShort = result.podWharf;
                }
                
                if (podShort && podFull) {
                    result.podWharf = `${podShort}/${podFull}`;
                } else if (podShort) {
                    result.podWharf = podShort;
                } else if (podFull) {
                    result.podWharf = podFull;
                } else if (!result.podWharf && hasPodWharf) {
                    // 如果补充失败，保留原值
                    result.podWharf = result.podWharf;
                }
            }
        }
        
        // 如果仍然缺失，进行全局搜索（增强：优先搜索包含fleetId和fleetIdPort的vessel对象）
        const needsGlobalSearch = !result.plan || !result.eta || !result.vesselName || !result.voyage;
        if (needsGlobalSearch && decodedHtml) {
            // 策略1：优先搜索包含fleetId和fleetIdPort的vessel对象（增强：更精确的匹配）
            if (lineId && portId) {
                // 先查找包含fleetId和fleetIdPort的完整fleet块，然后在该块中查找vessel对象
                const fleetBlockPattern = new RegExp(
                    `"fleetId"\\s*:\\s*${lineId}[\\s\\S]{0,500}"fleetIdPort"\\s*:\\s*${portId}[\\s\\S]{0,10000}`,
                    'i'
                );
                const fleetBlockMatch = decodedHtml.match(fleetBlockPattern);
                const searchContext = fleetBlockMatch ? fleetBlockMatch[0] : decodedHtml;
                
                // 在fleet块中查找vessel对象
                const vesselWithFleetPattern = /\{[^{}]*?"(?:vslName|vesselName)"\s*:\s*"[^"]+"[\s\S]{0,2000}?"(?:voyNo|voyageNo)"\s*:\s*"[^"]+"[\s\S]*?\}/g;
                let vesselWithFleetMatch;
                let count1 = 0;
                while ((vesselWithFleetMatch = vesselWithFleetPattern.exec(searchContext)) !== null && count1 < 20) {
                    count1++;
                    try {
                        const objText = vesselWithFleetMatch[0].replace(/,\s*\}/g, '}');
                        const vesselObj = JSON.parse(objText);
                        
                        // 验证fleetId和fleetIdPort是否匹配（如果vessel对象中有这些字段）
                        if (vesselObj.fleetId && vesselObj.fleetIdPort) {
                            if (vesselObj.fleetId !== lineId || vesselObj.fleetIdPort !== portId) {
                                continue; // 不匹配，跳过
                            }
                        }
                        
                        if (!result.vesselName) {
                            const name = extractVesselName(vesselObj);
                            if (name) result.vesselName = clean(name);
                        }
                        if (!result.voyage) {
                            const voy = extractVoyage(vesselObj);
                            if (voy) result.voyage = clean(voy);
                        }
                        if (!result.plan) {
                            const plan = extractPlanDate(vesselObj);
                            if (plan) result.plan = plan;
                        }
                        if (!result.eta) {
                            const eta = extractEtaDate(vesselObj);
                            if (eta) result.eta = eta;
                        }
                        if (!result.weekday) {
                            const weekday = vesselObj.weekdayOfETDFormatter 
                                || vesselObj.weekday 
                                || vesselObj.etdWeekday 
                                || vesselObj.weekdayOfETD
                                || vesselObj.sailingWeekday
                                || vesselObj.departureWeekday
                                || '';
                            if (weekday) result.weekday = clean(weekday);
                        }
                        if (!result.shipdays) {
                            const shipdays = vesselObj.shipdays || vesselObj.shipDays || vesselObj.duration || '';
                            if (shipdays) {
                                const numMatch = String(shipdays).match(/(\d+)/);
                                if (numMatch) result.shipdays = clean(numMatch[1]);
                            }
                        }
                        // 补充起运港码头（增强提取逻辑，同时提取简写和全称）
                        if (!result.polWharf) {
                            const polShort = normalizeWharfTokens(vesselObj.startPortWharfEnShortName || '');
                            const polFull = normalizeWharfTokens(vesselObj.startPortWharfEnFullName || '');
                            if (polShort && polFull) {
                                result.polWharf = `${polShort}/${polFull}`;
                            } else if (polShort) {
                                result.polWharf = polShort;
                            } else if (polFull) {
                                result.polWharf = polFull;
                            } else {
                                result.polWharf = normalizeWharfTokens(vesselObj.wharfName || vesselObj.polWharf || '');
                            }
                        }
                        
                        // 补充目的港码头（确保从正确的vessel对象中提取）
                        if (!result.podWharf || (result.podWharf && !result.podWharf.includes('/') && result.podWharf.length < 15)) {
                            const podShort = normalizeWharfTokens(vesselObj.destPortWharfEnShortName || '');
                            const podFull = normalizeWharfTokens(vesselObj.destPortWharfEnFullName || '');
                            if (podShort && podFull) {
                                result.podWharf = `${podShort}/${podFull}`;
                            } else if (podShort) {
                                result.podWharf = podShort;
                            } else if (podFull) {
                                result.podWharf = podFull;
                            }
                        }
                        
                        // 如果所有关键数据都已补充，提前退出
                        if (result.vesselName && result.voyage && result.plan && result.eta) {
                            break;
                        }
                    } catch (error) {
                        continue;
                    }
                }
            }
            
            // 策略2：如果策略1没有找到，进行通用搜索（增加搜索次数）
            if ((!result.plan || !result.eta || !result.vesselName || !result.voyage) && decodedHtml) {
                const vesselObjPattern = /\{[^{}]*?"(?:vslName|vesselName)"\s*:\s*"[^"]+"[\s\S]{0,2000}?"(?:voyNo|voyageNo)"\s*:\s*"[^"]+"[\s\S]*?\}/g;
                let count = 0;
                let vesselObjMatch;
                while ((vesselObjMatch = vesselObjPattern.exec(decodedHtml)) !== null && count < 15) {
                    count++;
                    try {
                        const objText = vesselObjMatch[0].replace(/,\s*\}/g, '}');
                        const vesselObj = JSON.parse(objText);
                        
                        if (!result.vesselName) {
                            const name = extractVesselName(vesselObj);
                            if (name) result.vesselName = clean(name);
                        }
                        if (!result.voyage) {
                            const voy = extractVoyage(vesselObj);
                            if (voy) result.voyage = clean(voy);
                        }
                        if (!result.plan) {
                            const plan = extractPlanDate(vesselObj);
                            if (plan) result.plan = plan;
                        }
                        if (!result.eta) {
                            const eta = extractEtaDate(vesselObj);
                            if (eta) result.eta = eta;
                        }
                        if (!result.weekday) {
                            const weekday = vesselObj.weekdayOfETDFormatter 
                                || vesselObj.weekday 
                                || vesselObj.etdWeekday 
                                || vesselObj.weekdayOfETD
                                || vesselObj.sailingWeekday
                                || vesselObj.departureWeekday
                                || '';
                            if (weekday) result.weekday = clean(weekday);
                        }
                        if (!result.shipdays) {
                            const shipdays = vesselObj.shipdays || vesselObj.shipDays || vesselObj.duration || '';
                            if (shipdays) {
                                const numMatch = String(shipdays).match(/(\d+)/);
                                if (numMatch) result.shipdays = clean(numMatch[1]);
                            }
                        }
                        // 补充起运港码头（增强提取逻辑，同时提取简写和全称）
                        if (!result.polWharf) {
                            const polShort = normalizeWharfTokens(vesselObj.startPortWharfEnShortName || '');
                            const polFull = normalizeWharfTokens(vesselObj.startPortWharfEnFullName || '');
                            if (polShort && polFull) {
                                result.polWharf = `${polShort}/${polFull}`;
                            } else if (polShort) {
                                result.polWharf = polShort;
                            } else if (polFull) {
                                result.polWharf = polFull;
                            } else {
                                result.polWharf = normalizeWharfTokens(vesselObj.wharfName || vesselObj.polWharf || '');
                            }
                        }
                        
                        // 补充目的港码头（确保从正确的vessel对象中提取）
                        if (!result.podWharf || (result.podWharf && !result.podWharf.includes('/') && result.podWharf.length < 15)) {
                            const podShort = normalizeWharfTokens(vesselObj.destPortWharfEnShortName || '');
                            const podFull = normalizeWharfTokens(vesselObj.destPortWharfEnFullName || '');
                            if (podShort && podFull) {
                                result.podWharf = `${podShort}/${podFull}`;
                            } else if (podShort) {
                                result.podWharf = podShort;
                            } else if (podFull) {
                                result.podWharf = podFull;
                            }
                        }
                        
                        // 如果所有关键数据都已补充，提前退出
                        if (result.vesselName && result.voyage && result.plan && result.eta) {
                            break;
                        }
                    } catch (error) {
                        continue;
                    }
                }
            }
        }
        
        return result;
    }

    /**
     * 提取主要内容（从"条直航信息"开始，到"中转服务详情"之前结束）
     * 增强：更精确地定位直航信息范围
     * @param {string} decoded - 解码后的HTML文本
     * @returns {string} 主要内容文本
     */
    function extractMainContent(decoded) {
        // 策略1：查找"条直航信息"作为起始位置
        const startMarkers = [
            '条直航信息',
            '条直航',
            '直航信息'
        ];
        let startPos = -1;
        for (const marker of startMarkers) {
            const markerPos = decoded.indexOf(marker);
            if (markerPos >= 0) {
                // 找到标记后，向后查找，确保包含完整的数据结构
                // 通常数据在标记后的几百到几千字符内
                startPos = markerPos;
                break;
            }
        }
        
        // 策略2：如果没找到"条直航信息"，尝试查找"发往"作为起始位置
        if (startPos === -1) {
            const faWangPos = decoded.indexOf('发往');
            if (faWangPos >= 0) {
                // 从"发往"向前查找"共有"，向后查找"条"
                const gongYouPos = decoded.lastIndexOf('共有', faWangPos);
                const tiaoPos = decoded.indexOf('条', faWangPos);
                if (gongYouPos >= 0 && tiaoPos > faWangPos) {
                    startPos = gongYouPos;
                } else if (tiaoPos > faWangPos) {
                    startPos = faWangPos;
                }
            }
        }
        
        // 策略3：如果还是没找到，使用原来的逻辑（从开头开始）
        if (startPos === -1) {
            startPos = 0;
        }
        
        // 查找结束位置：从"中转服务详情"开始
        const endMarkers = [
            '<div class="text-[14px] font-bold">中转服务详情',
            'text-[14px] font-bold">中转服务详情',
            '中转服务详情',
            'text-[14px] font-bold">中转',
            'lineTypeShowName":"接二程"'
        ];
        let endPos = -1;
        for (const marker of endMarkers) {
            const markerPos = decoded.indexOf(marker, startPos);
            if (markerPos >= 0 && (endPos === -1 || markerPos < endPos)) {
                endPos = markerPos;
            }
        }
        
        // 如果找到了结束位置，提取该范围内的内容
        if (endPos > startPos) {
            return decoded.substring(startPos, endPos);
        } else if (startPos > 0) {
            // 如果只找到了起始位置，从起始位置到结尾
            return decoded.substring(startPos);
        } else {
            // 如果都没找到，返回原始内容
            return decoded;
        }
    }

    /**
     * 处理单个船的数据，提取并构建行数据
     * @param {Object} vessel - 船对象
     * @param {Object} fleet - 船队对象
     * @param {Object} odTop - 起运港/目的港对象
     * @param {string} lineId - 航线ID
     * @param {string} portId - 港口ID
     * @param {string} carriers - 共舱船公司
     * @param {string} podCombined - 目的港码头组合
     * @param {string} defaultWeekday - 默认开航日
     * @param {string} defaultShipdays - 默认航程
     * @param {string} defaultPolWharf - 默认起运港码头
     * @param {Map} visibleData - 可见数据映射（可选）
     * @param {string} html - 原始HTML（用于可见数据提取）
     * @returns {Array|null} 行数据数组，如果无效则返回null
     */
    function processVesselData(vessel, fleet, odTop, lineId, portId, carriers, podCombined, 
                                defaultWeekday, defaultShipdays, defaultPolWharf, visibleData, html) {
        // 使用增强的提取函数，尝试多个字段名
        // 标准化JSON格式：从scheduleNotices中提取
        const vesselName = vessel.vslName || extractVesselName(vessel);
        const voyage = vessel.voyNo || extractVoyage(vessel);
        const shipType = vessel.shipCapacity || '';
        let plan = extractPlanDate(vessel);
        // 标准化JSON格式：atdFormatter是实际离港
        const atd = datePart(vessel.atdFormatter || '');
        // 标准化JSON格式：etaFormatter是预计到港
        let eta = datePart(vessel.etaFormatter || '');
        if (!eta) {
            eta = extractEtaDate(vessel);
        }
        
        // 优化：延迟验证，只在数据不完整时才提取可见数据
        // 增强：即使plan存在，也尝试从可见数据中补充（因为可能不完整）
        const hasCompleteData = vesselName && voyage && plan && eta;
        if ((!hasCompleteData || !plan) && visibleData && visibleData.size > 0) {
            const visibleKey = `${lineId}_${portId}_${vesselName || ''}_${voyage || ''}`;
            const visibleInfo = visibleData.get(visibleKey) || 
                              visibleData.get(`${lineId}_${portId}_${clean(vesselName || '')}_${clean(voyage || '')}`) ||
                              visibleData.get(`${lineId}_${portId}_${(vesselName || '').toUpperCase()}_${(voyage || '').toUpperCase()}`);
            
            if (visibleInfo) {
                // 增强：优先使用可见数据中的计划开航（通常更准确）
                if (!plan && visibleInfo.planDate) {
                    plan = visibleInfo.planDate;
                } else if (plan && visibleInfo.planDate && plan !== visibleInfo.planDate) {
                    // 如果两者都存在但不一致，优先使用可见数据（通常更准确）
                    plan = visibleInfo.planDate;
                }
                if (!eta && visibleInfo.etaDate) eta = visibleInfo.etaDate;
                if (!podCombined && visibleInfo.podWharf) podCombined = visibleInfo.podWharf;
            }
        }
        
        // 增强：如果仍然没有计划开航，尝试从fleet级别提取
        if (!plan && fleet) {
            const fleetPlan = extractPlanDate(fleet);
            if (fleetPlan) plan = fleetPlan;
        }
        
        // 开航日：优先从 vessel，其次从 fleet
        let weekday = defaultWeekday;
        if (!weekday) {
            weekday = vessel.weekdayOfETDFormatter || vessel.weekday || vessel.etdWeekday || '';
        }
        
        // 航程：优先从 vessel，其次从 fleet（增强提取逻辑）
        let shipdays = defaultShipdays;
        if (!shipdays) {
            shipdays = vessel.shipdays || vessel.shipDays || vessel.duration || 
                      vessel.transitTime || vessel.transitDays || '';
        }
        if (shipdays && typeof shipdays === 'string') {
            const numMatch = shipdays.match(/(\d+)/);
            if (numMatch) shipdays = numMatch[1];
        }
        
        // 起运港码头：优先从 vessel，其次从 fleet
        let polWharf = defaultPolWharf;
        if (!polWharf) {
            const polShort = vessel.startPortWharfEnShortName || '';
            const polFull = vessel.startPortWharfEnFullName || '';
            if (polShort && polFull) {
                polWharf = `${normalizeWharfTokens(polShort)}/${normalizeWharfTokens(polFull)}`;
            } else if (polShort) {
                polWharf = normalizeWharfTokens(polShort);
            } else if (polFull) {
                polWharf = normalizeWharfTokens(polFull);
            } else {
                polWharf = normalizeWharfTokens(vessel.wharfName || vessel.polWharf || '');
            }
        }
        
        // 目的港码头：如果 vessel 中有，优先使用
        let vesselPodCombined = podCombined;
        if (vessel.destPortWharfEnShortName || vessel.destPortWharfEnFullName) {
            const vPodShort = normalizeWharfTokens(vessel.destPortWharfEnShortName || '');
            const vPodFull = normalizeWharfTokens(vessel.destPortWharfEnFullName || '');
            if (vPodShort && vPodFull) {
                vesselPodCombined = `${vPodShort}/${vPodFull}`;
            } else if (vPodShort) {
                vesselPodCombined = vPodShort;
            } else if (vPodFull) {
                vesselPodCombined = vPodFull;
            }
        }
        
        // 应用数据清洗
        const cleanedShipType = cleanShipType(shipType);
        const cleanedVesselName = clean(vesselName);
        const cleanedVoyage = clean(voyage);
        let finalEta = clean(eta);
        
        // 预计到港补充逻辑
        if (!finalEta && cleanedVesselName && cleanedVoyage) {
            const isBlankSailing = /BLANK\s*SAILING/i.test(cleanedVesselName) || 
                                  /BLANK\s*SAILING/i.test(cleanedVoyage);
            if (!isBlankSailing) {
                // 不是空白航行，应该有预计到港（补充机制会在后续处理）
            }
        }
        
        const origin = fleet.origin || odTop.origin || '';
        const dest = fleet.dest || odTop.dest || '';
        
        return [
            clean(origin),                      // 启运港
            clean(dest),                        // 目的港
            clean(lineId),                      // 航线ID
            clean(portId),                      // 港口ID
            clean(weekday),                     // 开航日
            clean(shipdays),                    // 航程
            clean(carriers),                    // 共舱船公司
            cleanedVesselName,                  // 船名（已清洗）
            cleanedVoyage,                      // 航次（已清洗）
            cleanedShipType,                    // 船型（已清洗）
            clean(plan),                        // 计划开航
            clean(atd),                         // 实际离港
            finalEta,                           // 预计到港
            clean(polWharf),                    // 启运港码头
            clean(vesselPodCombined)            // 目的港码头
        ];
    }

    /**
     * 处理船队数据，提取所有船的行数据
     * @param {Object} fleet - 船队对象
     * @param {Object} odTop - 起运港/目的港对象
     * @param {Map} carrierCache - 共舱船公司缓存
     * @param {string} decoded - 解码后的HTML文本
     * @param {string} html - 原始HTML
     * @param {Map} visibleData - 可见数据映射（可选）
     * @returns {Array<Array>} 行数据数组
     */
    function processFleetData(fleet, odTop, carrierCache, decoded, html, visibleData) {
        // 标准化JSON格式：lineId是"188"（中间部分），portId是"CNTAO"（最后一部分）
        let lineId = fleet.lineId || '';
        let portId = fleet.fleetIdPort || fleet.motherVesselPolCode || '';
        
        // 如果lineId不存在，尝试从key字段提取（格式："3_188_CNTAO" -> "188"）
        if (!lineId && fleet._rawFleet && fleet._rawFleet.key) {
            const keyMatch = /^(\d+)_(\d+)_([^_]+)$/.exec(fleet._rawFleet.key);
            if (keyMatch) {
                lineId = keyMatch[2]; // 中间部分（fleetId）
            }
        }
        
        // 如果portId不存在，尝试从motherVesselPolCode获取
        if (!portId) {
            portId = fleet.motherVesselPolCode || '';
        }
        
        // 优化：使用缓存避免重复查找共舱船公司
        const carrierKey = `${lineId}_${portId}`;
        let carriers = carrierCache.get(carrierKey);
        if (carriers === undefined) {
            // 优先从标准化JSON中的sharedCabinCarriers提取（已经是格式化字符串）
            if (fleet.sharedCabinCarriers && typeof fleet.sharedCabinCarriers === 'string') {
                carriers = fleet.sharedCabinCarriers;
            } else if (fleet.sharedCabinCarriers && Array.isArray(fleet.sharedCabinCarriers) && fleet.sharedCabinCarriers.length > 0) {
                const carrierParts = [];
                for (const carrier of fleet.sharedCabinCarriers) {
                    if (carrier && typeof carrier === 'object') {
                        const carrierName = carrier.carrierShortName || carrier.carrierCode || '';
                        const svcCode = carrier.svcCode || '';
                        if (carrierName) {
                            if (svcCode) {
                                carrierParts.push(`${carrierName}(${svcCode})`);
                            } else {
                                carrierParts.push(carrierName);
                            }
                        }
                    }
                }
                carriers = carrierParts.join('|');
            } else {
            carriers = findCosTitle(decoded, lineId, portId, html);
            if (!carriers) {
                carriers = [
                    fleet.carrierShortName && fleet.svcCode
                        ? `${fleet.carrierShortName}(${fleet.svcCode})`
                        : fleet.carrierShortName
                ].filter(Boolean).join('');
                }
            }
            carrierCache.set(carrierKey, carriers);
        }
        
        // 目的港码头：从destPortWharfEnShortName和destPortWharfEnFullName组合
        let podCombined = '';
        if (fleet.destPortWharfEnShortName && fleet.destPortWharfEnFullName) {
            podCombined = `${fleet.destPortWharfEnShortName}/${fleet.destPortWharfEnFullName}`;
        } else if (fleet.destPortWharfEnShortName) {
            podCombined = fleet.destPortWharfEnShortName;
        } else if (fleet.destPortWharfEnFullName) {
            podCombined = fleet.destPortWharfEnFullName;
        } else if (fleet.podShort && fleet.podFull) {
            podCombined = `${fleet.podShort}/${fleet.podFull}`;
        } else if (fleet.podShort) {
            podCombined = fleet.podShort;
        } else if (fleet.podFull) {
            podCombined = fleet.podFull;
        }
        
        // 从 fleet 级别提取的默认值（标准化JSON格式：这些字段应该已经在extractFleetAndVessels中设置）
        const defaultWeekday = fleet.weekday || fleet.weekdayOfETDFormatter || '';
        const defaultShipdays = fleet.shipDays || fleet.shipdays || '';
        const defaultPolWharf = fleet.wharfName || fleet.polWharf || '';
        
        // 调试信息：检查fleet对象的字段
        if (typeof window !== 'undefined' && typeof window.debugWarn === 'function' && (!defaultWeekday || !defaultShipdays || !defaultPolWharf)) {
            window.debugWarn(`[processFleetData] 警告：fleet对象缺少字段 - lineId=${lineId}, portId=${portId}, weekday=${fleet.weekday}, shipDays=${fleet.shipDays}, wharfName=${fleet.wharfName}, carriers=${fleet.sharedCabinCarriers}`);
        }
        
        const rows = [];
        // 当页目的港码头补全映射：key为lineId_portId_dest，value为podWharf（带全称）
        // 确保只补全相同目的港的记录，避免跨目的港补全
        const pagePodFullMap = new Map(); // key: lineId_portId_dest, value: podWharf 带全称
        // 增强：当页计划开航补全映射：key为lineId_portId_vesselName_voyage，value为planDate
        const pagePlanMap = new Map(); // key: lineId_portId_vesselName_voyage, value: planDate
        
        // 标准化JSON格式：vessel数据优先从scheduleNotices数组中提取
        // 如果没有scheduleNotices，尝试从planSchedule中提取（某些情况下planSchedule可能包含有效数据）
        let vessels = [];
        // 优先级1：从fleet.scheduleNotices提取（这是extractFleetAndVessels已经合并好的数据）
        if (fleet.scheduleNotices && Array.isArray(fleet.scheduleNotices) && fleet.scheduleNotices.length > 0) {
            vessels = fleet.scheduleNotices.filter(item => {
                // 过滤掉引用（字符串类型，以$开头）
                if (typeof item === 'string' && item.startsWith('$')) {
                    return false;
                }
                // 只保留有效的对象，且有vslName，且不是BLANK SAILING
                // 注意：不在这里过滤_isDirect，因为extractFleetAndVessels已经过滤过了
                return item && 
                       typeof item === 'object' && 
                       !Array.isArray(item) && 
                       item.vslName && 
                       item.vslName !== 'BLANK SAILING' &&
                       item.voyNo !== 'BLANK SAILING';
            });
        }
        
        // 优先级2：如果scheduleNotices为空，尝试从_rawFleet中提取（可能包含更多数据源）
        if (vessels.length === 0 && fleet._rawFleet) {
            // 从_rawFleet.scheduleNotices提取
            if (fleet._rawFleet.scheduleNotices && Array.isArray(fleet._rawFleet.scheduleNotices) && fleet._rawFleet.scheduleNotices.length > 0) {
                const rawNotices = fleet._rawFleet.scheduleNotices.filter(item => {
                    if (typeof item === 'string' && item.startsWith('$')) {
                        return false;
                    }
                    return item && 
                           typeof item === 'object' && 
                           !Array.isArray(item) && 
                           item.vslName && 
                           item.vslName !== 'BLANK SAILING' &&
                           item.voyNo !== 'BLANK SAILING' &&
                           item._isDirect !== false; // 只过滤明确标记为转船的
                });
                vessels.push(...rawNotices);
            }
        }
        
        // 优先级3：从planSchedule中补充（可能包含更多船期）
        const planSchedule = fleet.planSchedule || (fleet._rawFleet && fleet._rawFleet.planSchedule);
        if (planSchedule && Array.isArray(planSchedule) && planSchedule.length > 0) {
            const planScheduleVessels = planSchedule.filter(item => {
                if (typeof item === 'string' && item.startsWith('$')) {
                    return false;
                }
                // 放宽条件：由于已经从directFleets中提取，理论上都是直达的
                // 只有在明确标记为转船（_isDirect === false）时才过滤
                if (item && typeof item === 'object' && !Array.isArray(item)) {
                    if (item._isDirect === false) {
                        return false; // 明确标记为转船，过滤
                    }
                    return item.vslName && 
                           item.vslName !== 'BLANK SAILING' &&
                           item.voyNo !== 'BLANK SAILING';
                }
                return false;
            });
            // 合并planSchedule中的船期（避免重复）
            for (const vessel of planScheduleVessels) {
                const key = `${vessel.vslName || ''}_${vessel.voyNo || ''}`;
                const exists = vessels.some(v => 
                    `${v.vslName || ''}_${v.voyNo || ''}` === key
                );
                if (!exists) {
                    vessels.push(vessel);
                }
            }
        }
        
        // 优先级4：从scheduleNoticeShare中补充（可能包含更多船期）
        const scheduleNoticeShare = fleet.scheduleNoticeShare || (fleet._rawFleet && fleet._rawFleet.scheduleNoticeShare);
        if (scheduleNoticeShare && typeof scheduleNoticeShare === 'object' &&
            scheduleNoticeShare.notices && Array.isArray(scheduleNoticeShare.notices) && 
            scheduleNoticeShare.notices.length > 0) {
            const shareNotices = scheduleNoticeShare.notices.filter(item => {
                if (typeof item === 'string' && item.startsWith('$')) {
                    return false;
                }
                // 放宽条件：由于已经从directFleets中提取，理论上都是直达的
                // 只有在明确标记为转船（_isDirect === false）时才过滤
                if (item && typeof item === 'object' && !Array.isArray(item)) {
                    if (item._isDirect === false) {
                        return false; // 明确标记为转船，过滤
                    }
                    return item.vslName && 
                           item.vslName !== 'BLANK SAILING' &&
                           item.voyNo !== 'BLANK SAILING';
                }
                return false;
            });
            // 合并scheduleNoticeShare中的船期（避免重复）
            for (const vessel of shareNotices) {
                const key = `${vessel.vslName || ''}_${vessel.voyNo || ''}`;
                const exists = vessels.some(v => 
                    `${v.vslName || ''}_${v.voyNo || ''}` === key
                );
                if (!exists) {
                    vessels.push(vessel);
                }
            }
        }
        
        // 优先级5：从directScheduleList中的carrier对象中提取（最后尝试，因为可能包含重复数据）
        if (vessels.length === 0 && fleet._rawFleet && fleet._rawFleet.directScheduleList && Array.isArray(fleet._rawFleet.directScheduleList)) {
            for (const carrierItem of fleet._rawFleet.directScheduleList) {
                if (carrierItem && typeof carrierItem === 'object' && !Array.isArray(carrierItem) &&
                    carrierItem.scheduleNotices && Array.isArray(carrierItem.scheduleNotices)) {
                    const carrierNotices = carrierItem.scheduleNotices.filter(item => {
                        if (typeof item === 'string' && item.startsWith('$')) {
                            return false;
                        }
                        return item && 
                               typeof item === 'object' && 
                               !Array.isArray(item) && 
                               item.vslName && 
                               item.vslName !== 'BLANK SAILING' &&
                               item.voyNo !== 'BLANK SAILING' &&
                               item._isDirect !== false; // 只过滤明确标记为转船的
                    });
                    for (const notice of carrierNotices) {
                        const key = `${notice.vslName || ''}_${notice.voyNo || ''}`;
                        const exists = vessels.some(v => 
                            `${v.vslName || ''}_${v.voyNo || ''}` === key
                        );
                        if (!exists) {
                            vessels.push(notice);
                        }
                    }
                }
            }
        }
        
        // 如果还是没有vessels，返回空数组（不处理）
        if (vessels.length === 0) {
            return [];
        }
        
        for (const vessel of vessels) {
            const row = processVesselData(vessel, fleet, odTop, lineId, portId, carriers, podCombined,
                                        defaultWeekday, defaultShipdays, defaultPolWharf, visibleData, html);
            if (row) {
                const vesselName = row[7] || ''; // 船名
                const voyage = row[8] || ''; // 航次
                const plan = row[10] || ''; // 计划开航
                const dest = row[1] || '';
                const podWharf = row[14] || '';
                
                // 增强：当页计划开航补全
                if (!plan && vesselName && voyage && lineId && portId) {
                    const planKey = `${lineId}_${portId}_${vesselName}_${voyage}`;
                    if (pagePlanMap.has(planKey)) {
                        row[10] = pagePlanMap.get(planKey);
                    }
                } else if (plan && vesselName && voyage && lineId && portId) {
                    // 如果当前记录有计划开航，保存到映射中
                    const planKey = `${lineId}_${portId}_${vesselName}_${voyage}`;
                    pagePlanMap.set(planKey, plan);
                }
                
                // 当页补全：如果目的港码头只有简写，尝试从当前页面的其他记录中补全
                const onlyShort = podWharf && !podWharf.includes('/') && podWharf.length < 15;
                
                if (onlyShort && lineId && portId && dest) {
                    const key = `${lineId}_${portId}_${dest}`;
                    if (pagePodFullMap.has(key)) {
                        // 如果当前页面有带全称的记录，使用它
                        row[14] = pagePodFullMap.get(key);
                    }
                } else if (podWharf && podWharf.includes('/') && lineId && portId && dest) {
                    // 如果当前记录有带全称的目的港码头，保存到映射中
                    const key = `${lineId}_${portId}_${dest}`;
                    const current = pagePodFullMap.get(key) || '';
                    if (podWharf.length > current.length) {
                        pagePodFullMap.set(key, podWharf);
                    }
                }
                
                rows.push(row);
            }
        }
        
        // 第二遍遍历：用带全称的记录补全只有简写的记录（当页补全）
        for (let i = 0; i < rows.length; i++) {
            const row = rows[i];
            const dest = row[1] || '';
            const podWharf = row[14] || '';
            const vesselName = row[7] || '';
            const voyage = row[8] || '';
            const plan = row[10] || '';
            const onlyShort = podWharf && !podWharf.includes('/') && podWharf.length < 15;
            
            // 增强：当页计划开航补全（第二遍）
            if (!plan && vesselName && voyage && lineId && portId) {
                const planKey = `${lineId}_${portId}_${vesselName}_${voyage}`;
                if (pagePlanMap.has(planKey)) {
                    row[10] = pagePlanMap.get(planKey);
                }
            }
            
            if (onlyShort && lineId && portId && dest) {
                const key = `${lineId}_${portId}_${dest}`;
                if (pagePodFullMap.has(key)) {
                    row[14] = pagePodFullMap.get(key);
                }
            }
        }
        
        return rows;
    }

    /**
     * 兜底提取：从整页直接抓取含 vslName 的对象
     * 增强：从vessel对象中提取fleetId和fleetIdPort，以及更多字段
     * @param {string} mainText - 主要内容文本
     * @param {Object} odTop - 起运港/目的港对象
     * @returns {Array<Array>} 行数据数组
     */
    function extractFallbackVessels(mainText, odTop) {
        const rows = [];
        // 增强：支持嵌套结构的vessel对象
        const vesselPattern = /\{[^{]*?"(?:vslName|vesselName)"\s*:\s*"[^"]+"[\s\S]{0,5000}?"(?:voyNo|voyageNo)"\s*:\s*"[^"]+"[\s\S]{0,5000}?\}/g;
        let vesselMatch;
        
        while ((vesselMatch = vesselPattern.exec(mainText))) {
            // 尝试扩展vessel对象，获取完整结构
            const matchIndex = vesselMatch.index;
            let braceCount = 0;
            let objStart = matchIndex;
            // 向前查找对象开始
            for (let i = matchIndex; i >= Math.max(0, matchIndex - 5000); i--) {
                if (mainText[i] === '}') braceCount++;
                else if (mainText[i] === '{') {
                    braceCount--;
                    if (braceCount === 0) {
                        objStart = i;
                        break;
                    }
                }
            }
            // 向后查找对象结束
            braceCount = 1;
            let objEnd = matchIndex + vesselMatch[0].length;
            for (let i = matchIndex + vesselMatch[0].length; i < Math.min(mainText.length, matchIndex + vesselMatch[0].length + 10000); i++) {
                if (mainText[i] === '{') braceCount++;
                else if (mainText[i] === '}') {
                    braceCount--;
                    if (braceCount === 0) {
                        objEnd = i + 1;
                        break;
                    }
                }
            }
            
            const objText = mainText.substring(objStart, objEnd).replace(/,\s*\}/g, '}');
            try {
                const vessel = JSON.parse(objText);
                const vesselName = extractVesselName(vessel);
                const voyage = extractVoyage(vessel);
                if (!vesselName && !voyage) continue;
                
                // 增强：从vessel对象中提取fleetId和fleetIdPort
                const lineId = String(vessel.fleetId || vessel.routeId || vessel.lineId || '');
                const portId = String(vessel.fleetIdPort || vessel.portId || '');
                
                // 增强：提取更多字段
                const shipType = vessel.shipCapacity || vessel.shipType || '';
                const plan = extractPlanDate(vessel);
                const atd = datePart(vessel.atdFormatter || vessel.atd || '');
                const eta = extractEtaDate(vessel);
                
                // 开航日：从vessel对象中提取
                let weekday = vessel.weekdayOfETDFormatter || vessel.weekday || vessel.etdWeekday || '';
                
                // 航程：从vessel对象中提取
                let shipdays = String(vessel.shipdays || vessel.shipDays || vessel.duration || vessel.transitTime || vessel.transitDays || '');
                if (shipdays && typeof shipdays === 'string') {
                    const numMatch = shipdays.match(/(\d+)/);
                    if (numMatch) shipdays = numMatch[1];
                }
                
                // 起运港码头：从vessel对象中提取
                let polWharf = '';
                const polShort = normalizeWharfTokens(vessel.startPortWharfEnShortName || '');
                const polFull = normalizeWharfTokens(vessel.startPortWharfEnFullName || '');
                if (polShort && polFull) {
                    polWharf = `${polShort}/${polFull}`;
                } else if (polShort) {
                    polWharf = polShort;
                } else if (polFull) {
                    polWharf = polFull;
                } else {
                    polWharf = normalizeWharfTokens(vessel.wharfName || vessel.polWharf || '');
                }
                
                // 目的港码头：从vessel对象中提取
                let podWharf = '';
                const podShort = normalizeWharfTokens(vessel.destPortWharfEnShortName || '');
                const podFull = normalizeWharfTokens(vessel.destPortWharfEnFullName || '');
                if (podShort && podFull) {
                    podWharf = `${podShort}/${podFull}`;
                } else if (podShort) {
                    podWharf = podShort;
                } else if (podFull) {
                    podWharf = podFull;
                } else {
                    podWharf = normalizeWharfTokens(vessel.podWharf || '');
                }
                
                rows.push([
                    clean(odTop.origin || ''),
                    clean(odTop.dest || ''),
                    clean(lineId),                      // 航线ID（从vessel中提取）
                    clean(portId),                      // 港口ID（从vessel中提取）
                    clean(weekday),                     // 开航日
                    clean(shipdays),                    // 航程
                    '',                                 // 共舱船公司（需要单独提取）
                    clean(vesselName),
                    clean(voyage),
                    clean(shipType),
                    clean(plan),
                    clean(atd),
                    clean(eta),
                    clean(polWharf),                    // 启运港码头
                    clean(podWharf)                     // 目的港码头
                ]);
            } catch (error) {
                // 如果JSON解析失败，尝试使用正则表达式直接提取字段
                try {
                    const vesselSegment = mainText.substring(objStart, objEnd);
                    const vesselNameMatch = vesselSegment.match(/"vslName"\s*:\s*"([^"]+)"|"vesselName"\s*:\s*"([^"]+)"/);
                    const vesselName = vesselNameMatch ? (vesselNameMatch[1] || vesselNameMatch[2]) : '';
                    const voyageMatch = vesselSegment.match(/"voyNo"\s*:\s*"([^"]+)"|"voyageNo"\s*:\s*"([^"]+)"/);
                    const voyage = voyageMatch ? (voyageMatch[1] || voyageMatch[2]) : '';
                    
                    // 放宽条件：只要有船名或航次，就提取数据（即使没有fleetId或fleetIdPort）
                    if (vesselName || voyage) {
                        const lineIdMatch = vesselSegment.match(/"fleetId"\s*:\s*"?(\d+)"?/);
                        const portIdMatch = vesselSegment.match(/"fleetIdPort"\s*:\s*"?(\d+)"?/);
                        // 放宽条件：不再过滤掉fleetIdPort为'0'或'1'的情况（可能包含有效数据）
                        const lineId = lineIdMatch ? lineIdMatch[1] : '';
                        const portId = portIdMatch ? portIdMatch[1] : '';
                        
                        rows.push([
                            clean(odTop.origin || ''),
                            clean(odTop.dest || ''),
                            clean(lineId),
                            clean(portId),
                            '', '', '',
                            clean(vesselName),
                            clean(voyage),
                            '',
                            '', '', '',
                            '', ''
                        ]);
                    }
                } catch (secondError) {
                if (typeof window !== 'undefined' && typeof window.debugWarn === 'function') {
                        window.debugWarn('Failed to parse vessel object from fallback extraction:', secondError);
                    }
                }
            }
        }
        
        return rows;
    }

    function parseFile(name, html, decodedHtml = null){
        // 优化：如果已经解码过，直接使用，避免重复解码
        const decoded = decodedHtml || extractDecodedPayload(html);
        
        // 调试信息：检查解码后的内容
        if (typeof window !== 'undefined' && typeof window.debugWarn === 'function') {
            const hasNextF = html.includes('__next_f');
            const hasNextData = html.includes('__next_data__');
            const hasFleetId = decoded.includes('fleetId');
            const hasVslName = decoded.includes('vslName') || decoded.includes('vesselName');
            if (!hasFleetId && !hasVslName) {
                window.debugWarn(`[${name}] 警告：解码后的内容中未找到 fleetId 或 vslName，可能数据格式已改变`);
                window.debugWarn(`[${name}] __next_f: ${hasNextF}, __next_data__: ${hasNextData}, decoded长度: ${decoded.length}`);
            }
        }
        
        // 提取主要内容
        const mainText = extractMainContent(decoded);

        // 优化：延迟提取可见数据，只在需要验证时才执行
        let visibleData = null; // 延迟初始化

        const labelIndex = buildLabelIndex(mainText);
        // 标准化HTML格式：需要传入原始html（包含<pre>标签），而不是mainText
        const fleets = extractFleetAndVessels(html, labelIndex, null);
        
        // 调试信息：检查提取的fleet数量
        if (typeof window !== 'undefined' && typeof window.debugWarn === 'function') {
            if (fleets.length === 0 && mainText.length > 100) {
                window.debugWarn(`[${name}] 警告：未提取到任何fleet数据，mainText长度: ${mainText.length}`);
            }
        }
        
        const odTop = extractOriginDest(decoded);

        const rows = [];
        // 优化：批量查找共舱船公司，减少重复搜索
        const carrierCache = new Map();
        
        // 处理所有船队数据
        for (const fleet of fleets) {
            // 延迟初始化 visibleData（只在需要时才执行）
            let needsVisibleData = false;
            // 标准化JSON格式：船期信息在scheduleNotices数组中，不是vessels
            const vessels = fleet.scheduleNotices || fleet.vessels || [];
            for (const vessel of vessels) {
                // 跳过引用和BLANK SAILING
                if (typeof vessel === 'string' && vessel.startsWith('$')) {
                    continue;
                }
                if (vessel && typeof vessel === 'object' && 
                    (vessel.vslName === 'BLANK SAILING' || vessel.voyNo === 'BLANK SAILING')) {
                    continue;
                }
                
                const vesselName = extractVesselName(vessel);
                const voyage = extractVoyage(vessel);
                const plan = extractPlanDate(vessel);
                const eta = extractEtaDate(vessel);
                if (!vesselName || !voyage || !plan || !eta) {
                    needsVisibleData = true;
                    break;
                }
            }
            
            if (needsVisibleData && visibleData === null) {
                visibleData = extractVisibleScheduleData(html);
            }
            
            const fleetRows = processFleetData(fleet, odTop, carrierCache, decoded, html, visibleData);
            rows.push(...fleetRows);
        }
        
        // 全局兜底：已禁用 - 不再使用兜底函数，避免解析转船数据
        // 只处理从directFleets中提取的直达航线数据
        // 注意：兜底函数可能提取到转船数据，且字段不完整，因此禁用
        
        // 注意：补充机制延迟到合并后统一处理，以提高性能
        
        return rows;
    }

    /**
     * 规范化字符串（去除空格，转大写，用于比较）
     * @param {string} str - 原始字符串
     * @returns {string} 规范化后的字符串
     */
    function normalizeString(str) {
        if (!str) return '';
        return clean(str).replace(/\s+/g, '').toUpperCase();
    }

    /**
     * 生成数据质量检查报告
     * @param {Array<Array>} merged - 合并后的数据（包含表头）
     * @returns {Object} 质量报告对象
     */
    function generateQualityReport(merged) {
        const report = {
            hasIssues: false,
            duplicateVesselVoyage: [],
            duplicateVesselVoyageMap: new Map(), // key: normalized, value: {variants: Set, count: number}
            duplicatePodWharf: [],
            duplicatePodWharfMap: new Map(), // key: normalized, value: {variants: Map<variant, count>, totalCount: number}
            duplicateOrigin: [],
            duplicateOriginMap: new Map(), // key: normalized, value: {variants: Map<variant, count>, totalCount: number}
            duplicateDest: [],
            duplicateDestMap: new Map(), // key: normalized, value: {variants: Map<variant, count>, totalCount: number}
            duplicatePolWharf: [],
            duplicatePolWharfMap: new Map(), // key: normalized, value: {variants: Map<variant, count>, totalCount: number}
            missingWeekday: 0,
            missingShipdays: 0,
            missingPlan: 0,
            missingEta: 0,
            missingEtaNotBlank: 0,
            missingPolWharf: 0,
            missingPodWharf: 0,
            podWharfOnlyShort: 0
        };
        
        if (merged.length <= 1) return report;
        
        // 船名航次去空格后的映射（用于检测重复）
        const normalizedVesselVoyageMap = new Map(); // key: normalized, value: {variants: Map<variant, count>, totalCount: number}
        // 目的港码头去空格后的映射（用于检测重复）
        const normalizedPodWharfMap = new Map(); // key: normalized, value: {variants: Map<variant, count>, totalCount: number}
        // 起运港去空格后的映射（用于检测重复）
        const normalizedOriginMap = new Map(); // key: normalized, value: {variants: Map<variant, count>, totalCount: number}
        // 目的港去空格后的映射（用于检测重复）
        const normalizedDestMap = new Map(); // key: normalized, value: {variants: Map<variant, count>, totalCount: number}
        // 起运港码头去空格后的映射（用于检测重复）
        const normalizedPolWharfMap = new Map(); // key: normalized, value: {variants: Map<variant, count>, totalCount: number}
        
        // 统计缺失字段
        for (let i = 1; i < merged.length; i++) {
            const row = merged[i];
            const [
                origin, dest, lineId, portId, weekday, shipdays, carriers,
                vesselName, voyage, shipType, plan, atd, eta, polWharf, podWharf
            ] = row;
            
            // 检查船名航次空格问题
            if (vesselName || voyage) {
                const normalized = normalizeVesselVoyage(vesselName, voyage);
                if (normalized.combinedNormalized) {
                    if (!normalizedVesselVoyageMap.has(normalized.combinedNormalized)) {
                        normalizedVesselVoyageMap.set(normalized.combinedNormalized, {
                            variants: new Map(), // key: variant, value: count
                            totalCount: 0
                        });
                    }
                    const entry = normalizedVesselVoyageMap.get(normalized.combinedNormalized);
                    entry.totalCount++;
                    // 记录所有变体（船名+航次的组合）及其数量
                    const variant = `${vesselName || ''}|${voyage || ''}`;
                    entry.variants.set(variant, (entry.variants.get(variant) || 0) + 1);
                }
            }
            
            // 检查目的港码头空格问题
            if (podWharf) {
                const normalized = normalizePodWharf(podWharf);
                if (normalized) {
                    if (!normalizedPodWharfMap.has(normalized)) {
                        normalizedPodWharfMap.set(normalized, {
                            variants: new Map(), // key: variant, value: count
                            totalCount: 0
                        });
                    }
                    const entry = normalizedPodWharfMap.get(normalized);
                    entry.totalCount++;
                    // 记录所有变体及其数量
                    entry.variants.set(podWharf, (entry.variants.get(podWharf) || 0) + 1);
                }
            }
            
            // 检查起运港空格问题
            if (origin) {
                const normalized = normalizeString(origin);
                if (normalized) {
                    if (!normalizedOriginMap.has(normalized)) {
                        normalizedOriginMap.set(normalized, {
                            variants: new Map(), // key: variant, value: count
                            totalCount: 0
                        });
                    }
                    const entry = normalizedOriginMap.get(normalized);
                    entry.totalCount++;
                    entry.variants.set(origin, (entry.variants.get(origin) || 0) + 1);
                }
            }
            
            // 检查目的港空格问题
            if (dest) {
                const normalized = normalizeString(dest);
                if (normalized) {
                    if (!normalizedDestMap.has(normalized)) {
                        normalizedDestMap.set(normalized, {
                            variants: new Map(), // key: variant, value: count
                            totalCount: 0
                        });
                    }
                    const entry = normalizedDestMap.get(normalized);
                    entry.totalCount++;
                    entry.variants.set(dest, (entry.variants.get(dest) || 0) + 1);
                }
            }
            
            // 检查起运港码头空格问题
            if (polWharf) {
                const normalized = normalizePodWharf(polWharf); // 复用目的港码头的规范化函数
                if (normalized) {
                    if (!normalizedPolWharfMap.has(normalized)) {
                        normalizedPolWharfMap.set(normalized, {
                            variants: new Map(), // key: variant, value: count
                            totalCount: 0
                        });
                    }
                    const entry = normalizedPolWharfMap.get(normalized);
                    entry.totalCount++;
                    entry.variants.set(polWharf, (entry.variants.get(polWharf) || 0) + 1);
                }
            }
            
            // 检查缺失字段
            if (!weekday) report.missingWeekday++;
            if (!shipdays) report.missingShipdays++;
            if (!plan) report.missingPlan++;
            if (!eta) {
                report.missingEta++;
                // 检查是否是非BLANK SAILING
                const isBlankSailing = /BLANK\s*SAILING/i.test(vesselName || '') || 
                                     /BLANK\s*SAILING/i.test(voyage || '');
                if (!isBlankSailing && vesselName && voyage) {
                    report.missingEtaNotBlank++;
                }
            }
            if (!polWharf) report.missingPolWharf++;
            if (!podWharf) report.missingPodWharf++;
            
            // 检查目的港码头是否只有简写（没有全称）
            if (podWharf && !podWharf.includes('/') && podWharf.length < 10) {
                // 可能是只有简写，没有全称
                report.podWharfOnlyShort++;
            }
        }
        
        // 找出重复的船名航次（去空格后相同但原始值不同）
        for (const [normalized, entry] of normalizedVesselVoyageMap.entries()) {
            if (entry.totalCount > 1 && entry.variants.size > 1) {
                // 有多个变体，需要用户选择
                const variants = Array.from(entry.variants.entries()).map(([variant, count]) => {
                    const [vName, vVoyage] = variant.split('|');
                    return { 
                        vesselName: vName, 
                        voyage: vVoyage,
                        count: count
                    };
                });
                // 按数量排序，数量多的在前
                variants.sort((a, b) => b.count - a.count);
                report.duplicateVesselVoyage.push({
                    normalized: normalized,
                    variants: variants,
                    count: entry.totalCount
                });
                report.duplicateVesselVoyageMap.set(normalized, entry);
            }
        }
        
        // 找出重复的目的港码头（去空格后相同但原始值不同）
        for (const [normalized, entry] of normalizedPodWharfMap.entries()) {
            if (entry.totalCount > 1 && entry.variants.size > 1) {
                // 有多个变体，需要用户选择
                const variants = Array.from(entry.variants.entries()).map(([variant, count]) => {
                    return { 
                        podWharf: variant,
                        count: count
                    };
                });
                // 按数量排序，数量多的在前
                variants.sort((a, b) => b.count - a.count);
                report.duplicatePodWharf.push({
                    normalized: normalized,
                    variants: variants,
                    count: entry.totalCount
                });
                report.duplicatePodWharfMap.set(normalized, entry);
            }
        }
        
        // 找出重复的起运港（去空格后相同但原始值不同）
        for (const [normalized, entry] of normalizedOriginMap.entries()) {
            if (entry.totalCount > 1 && entry.variants.size > 1) {
                const variants = Array.from(entry.variants.entries()).map(([variant, count]) => {
                    return { 
                        origin: variant,
                        count: count
                    };
                });
                variants.sort((a, b) => b.count - a.count);
                report.duplicateOrigin.push({
                    normalized: normalized,
                    variants: variants,
                    count: entry.totalCount
                });
                report.duplicateOriginMap.set(normalized, entry);
            }
        }
        
        // 找出重复的目的港（去空格后相同但原始值不同）
        for (const [normalized, entry] of normalizedDestMap.entries()) {
            if (entry.totalCount > 1 && entry.variants.size > 1) {
                const variants = Array.from(entry.variants.entries()).map(([variant, count]) => {
                    return { 
                        dest: variant,
                        count: count
                    };
                });
                variants.sort((a, b) => b.count - a.count);
                report.duplicateDest.push({
                    normalized: normalized,
                    variants: variants,
                    count: entry.totalCount
                });
                report.duplicateDestMap.set(normalized, entry);
            }
        }
        
        // 找出重复的起运港码头（去空格后相同但原始值不同）
        for (const [normalized, entry] of normalizedPolWharfMap.entries()) {
            if (entry.totalCount > 1 && entry.variants.size > 1) {
                const variants = Array.from(entry.variants.entries()).map(([variant, count]) => {
                    return { 
                        polWharf: variant,
                        count: count
                    };
                });
                variants.sort((a, b) => b.count - a.count);
                report.duplicatePolWharf.push({
                    normalized: normalized,
                    variants: variants,
                    count: entry.totalCount
                });
                report.duplicatePolWharfMap.set(normalized, entry);
            }
        }
        
        // 按数量排序
        report.duplicateVesselVoyage.sort((a, b) => b.count - a.count);
        report.duplicatePodWharf.sort((a, b) => b.count - a.count);
        report.duplicateOrigin.sort((a, b) => b.count - a.count);
        report.duplicateDest.sort((a, b) => b.count - a.count);
        report.duplicatePolWharf.sort((a, b) => b.count - a.count);
        
        // 判断是否有问题
        report.hasIssues = report.duplicateVesselVoyage.length > 0 ||
                          report.duplicatePodWharf.length > 0 ||
                          report.duplicateOrigin.length > 0 ||
                          report.duplicateDest.length > 0 ||
                          report.duplicatePolWharf.length > 0 ||
                          report.missingWeekday > 0 ||
                          report.missingShipdays > 0 ||
                          report.missingPlan > 0 ||
                          report.missingEta > 0 ||
                          report.missingPolWharf > 0 ||
                          report.missingPodWharf > 0 ||
                          report.podWharfOnlyShort > 0;
        
        return report;
    }

    /**
     * 显示船名航次标准化模态框
     * @param {Array} duplicateGroups - 重复的船名航次组
     * @returns {Promise<Object>} 返回用户选择的替换映射 {normalized: {vesselName, voyage}}
     */
    function showVesselVoyageModal(duplicateGroups) {
        return new Promise((resolve) => {
            const modal = selectElement('#vesselVoyageModal');
            const list = selectElement('#vesselVoyageList');
            const applyBtn = selectElement('#applyVesselVoyageReplace');
            const skipBtn = selectElement('#skipVesselVoyageReplace');
            
            // 清空列表
            list.innerHTML = '';
            
            // 存储用户选择
            const selections = new Map();
            
            // 为每组重复记录创建选择界面
            duplicateGroups.forEach((group, groupIndex) => {
                const groupDiv = document.createElement('div');
                groupDiv.className = 'vessel-voyage-group';
                
                const title = document.createElement('div');
                title.className = 'vessel-voyage-group-title';
                title.textContent = `第 ${groupIndex + 1} 组（共 ${group.count} 条记录，${group.variants.length} 种格式）：`;
                groupDiv.appendChild(title);
                
                // 找到最短的船名航次组合（作为默认选择）
                let shortestIndex = 0;
                let shortestLength = Infinity;
                group.variants.forEach((variant, idx) => {
                    const totalLength = (variant.vesselName || '').length + (variant.voyage || '').length;
                    if (totalLength < shortestLength) {
                        shortestLength = totalLength;
                        shortestIndex = idx;
                    }
                });
                
                // 为每个变体创建选项
                group.variants.forEach((variant, variantIndex) => {
                    const option = document.createElement('div');
                    option.className = 'vessel-voyage-option';
                    const isShortest = variantIndex === shortestIndex;
                    if (isShortest) {
                        option.classList.add('selected');
                        selections.set(group.normalized, variant);
                    }
                    
                    const radio = document.createElement('input');
                    radio.type = 'radio';
                    radio.name = `vesselVoyageGroup_${groupIndex}`;
                    radio.value = `${variant.vesselName}|${variant.voyage}`;
                    radio.checked = isShortest;
                    radio.addEventListener('change', () => {
                        // 更新选中状态
                        groupDiv.querySelectorAll('.vessel-voyage-option').forEach(opt => {
                            opt.classList.remove('selected');
                        });
                        option.classList.add('selected');
                        selections.set(group.normalized, variant);
                    });
                    
                    const label = document.createElement('label');
                    label.className = 'vessel-voyage-option-label';
                    label.textContent = `"${variant.vesselName || ''}" / "${variant.voyage || ''}"`;
                    
                    const count = document.createElement('span');
                    count.className = 'vessel-voyage-option-count';
                    count.textContent = `(${variant.count} 条)`;
                    
                    option.appendChild(radio);
                    option.appendChild(label);
                    option.appendChild(count);
                    option.addEventListener('click', () => {
                        radio.checked = true;
                        radio.dispatchEvent(new Event('change'));
                    });
                    
                    groupDiv.appendChild(option);
                });
                
                list.appendChild(groupDiv);
            });
            
            // 显示模态框
            modal.classList.remove('hidden');
            
            // 应用按钮
            applyBtn.onclick = () => {
                modal.classList.add('hidden');
                resolve(selections);
            };
            
            // 跳过按钮
            skipBtn.onclick = () => {
                modal.classList.add('hidden');
                resolve(new Map()); // 返回空映射，不进行替换
            };
        });
    }

    /**
     * 应用船名航次替换
     * @param {Array<Array>} merged - 合并后的数据（包含表头）
     * @param {Map} replacements - 替换映射 {normalized: {vesselName, voyage}}
     * @returns {Array<Array>} 替换后的数据
     */
    function applyVesselVoyageReplacements(merged, replacements) {
        if (replacements.size === 0) return merged;
        
        const result = [merged[0]]; // 保留表头
        
        for (let i = 1; i < merged.length; i++) {
            const row = [...merged[i]]; // 复制行
            const vesselName = row[7] || '';
            const voyage = row[8] || '';
            
            const normalized = normalizeVesselVoyage(vesselName, voyage);
            if (normalized.combinedNormalized && replacements.has(normalized.combinedNormalized)) {
                const replacement = replacements.get(normalized.combinedNormalized);
                row[7] = replacement.vesselName;
                row[8] = replacement.voyage;
            }
            
            result.push(row);
        }
        
        return result;
    }

    /**
     * 显示目的港码头标准化模态框
     * @param {Array} duplicateGroups - 重复的目的港码头组
     * @returns {Promise<Object>} 返回用户选择的替换映射 {normalized: podWharf}
     */
    function showPodWharfModal(duplicateGroups) {
        return new Promise((resolve) => {
            const modal = selectElement('#podWharfModal');
            const list = selectElement('#podWharfList');
            const applyBtn = selectElement('#applyPodWharfReplace');
            const skipBtn = selectElement('#skipPodWharfReplace');
            
            // 清空列表
            list.innerHTML = '';
            
            // 存储用户选择
            const selections = new Map();
            
            // 为每组重复记录创建选择界面
            duplicateGroups.forEach((group, groupIndex) => {
                const groupDiv = document.createElement('div');
                groupDiv.className = 'vessel-voyage-group';
                
                const title = document.createElement('div');
                title.className = 'vessel-voyage-group-title';
                title.textContent = `第 ${groupIndex + 1} 组（共 ${group.count} 条记录，${group.variants.length} 种格式）：`;
                groupDiv.appendChild(title);
                
                // 找到最短的目的港码头（作为默认选择）
                let shortestIndex = 0;
                let shortestLength = Infinity;
                group.variants.forEach((variant, idx) => {
                    const length = (variant.podWharf || '').length;
                    if (length < shortestLength) {
                        shortestLength = length;
                        shortestIndex = idx;
                    }
                });
                
                // 为每个变体创建选项
                group.variants.forEach((variant, variantIndex) => {
                    const option = document.createElement('div');
                    option.className = 'vessel-voyage-option';
                    const isShortest = variantIndex === shortestIndex;
                    if (isShortest) {
                        option.classList.add('selected');
                        selections.set(group.normalized, variant.podWharf);
                    }
                    
                    const radio = document.createElement('input');
                    radio.type = 'radio';
                    radio.name = `podWharfGroup_${groupIndex}`;
                    radio.value = variant.podWharf;
                    radio.checked = isShortest;
                    radio.addEventListener('change', () => {
                        // 更新选中状态
                        groupDiv.querySelectorAll('.vessel-voyage-option').forEach(opt => {
                            opt.classList.remove('selected');
                        });
                        option.classList.add('selected');
                        selections.set(group.normalized, variant.podWharf);
                    });
                    
                    const label = document.createElement('label');
                    label.className = 'vessel-voyage-option-label';
                    label.textContent = variant.podWharf || '';
                    
                    const count = document.createElement('span');
                    count.className = 'vessel-voyage-option-count';
                    count.textContent = `(${variant.count} 条)`;
                    
                    option.appendChild(radio);
                    option.appendChild(label);
                    option.appendChild(count);
                    option.addEventListener('click', () => {
                        radio.checked = true;
                        radio.dispatchEvent(new Event('change'));
                    });
                    
                    groupDiv.appendChild(option);
                });
                
                list.appendChild(groupDiv);
            });
            
            // 显示模态框
            modal.classList.remove('hidden');
            
            // 应用按钮
            applyBtn.onclick = () => {
                modal.classList.add('hidden');
                resolve(selections);
            };
            
            // 跳过按钮
            skipBtn.onclick = () => {
                modal.classList.add('hidden');
                resolve(new Map()); // 返回空映射，不进行替换
            };
        });
    }

    /**
     * 应用目的港码头替换
     * @param {Array<Array>} merged - 合并后的数据（包含表头）
     * @param {Map} replacements - 替换映射 {normalized: podWharf}
     * @returns {Array<Array>} 替换后的数据
     */
    function applyPodWharfReplacements(merged, replacements) {
        if (replacements.size === 0) return merged;
        
        const result = [merged[0]]; // 保留表头
        
        for (let i = 1; i < merged.length; i++) {
            const row = [...merged[i]]; // 复制行
            const podWharf = row[14] || '';
            
            const normalized = normalizePodWharf(podWharf);
            if (normalized && replacements.has(normalized)) {
                const replacement = replacements.get(normalized);
                row[14] = replacement;
            }
            
            result.push(row);
        }
        
        return result;
    }

    /**
     * 通用标准化模态框显示函数
     * @param {Array} duplicateGroups - 重复的组
     * @param {string} fieldName - 字段名（origin/dest/polWharf）
     * @param {string} fieldLabel - 字段标签（起运港/目的港/起运港码头）
     * @returns {Promise<Map>} 返回用户选择的替换映射 {normalized: value}
     */
    function showStandardizationModal(duplicateGroups, fieldName, fieldLabel) {
        return new Promise((resolve) => {
            const modalId = `standardizationModal_${fieldName}`;
            const listId = `standardizationList_${fieldName}`;
            const applyBtnId = `applyStandardization_${fieldName}`;
            const skipBtnId = `skipStandardization_${fieldName}`;
            
            // 创建模态框（如果不存在）
            let modal = document.getElementById(modalId);
            if (!modal) {
                modal = document.createElement('div');
                modal.id = modalId;
                modal.className = 'vessel-voyage-modal hidden';
                modal.innerHTML = `
                    <div class="vessel-voyage-modal-content">
                        <div class="vessel-voyage-modal-header">
                            <h2>🔍 ${fieldLabel}标准化</h2>
                            <p>发现以下${fieldLabel}去空格后相同但格式不同，请为每组选择一个标准格式：</p>
                        </div>
                        <div id="${listId}" class="vessel-voyage-list"></div>
                        <div class="vessel-voyage-modal-footer">
                            <button id="${applyBtnId}" class="btn btn-primary">应用替换并继续</button>
                            <button id="${skipBtnId}" class="btn btn-secondary">跳过（保留原值）</button>
                        </div>
                    </div>
                `;
                document.getElementById('standardizationModalsContainer').appendChild(modal);
            }
            
            const list = document.getElementById(listId);
            const applyBtn = document.getElementById(applyBtnId);
            const skipBtn = document.getElementById(skipBtnId);
            
            // 清空列表
            list.innerHTML = '';
            
            // 存储用户选择
            const selections = new Map();
            
            // 为每组重复记录创建选择界面
            duplicateGroups.forEach((group, groupIndex) => {
                const groupDiv = document.createElement('div');
                groupDiv.className = 'vessel-voyage-group';
                
                const title = document.createElement('div');
                title.className = 'vessel-voyage-group-title';
                title.textContent = `第 ${groupIndex + 1} 组（共 ${group.count} 条记录，${group.variants.length} 种格式）：`;
                groupDiv.appendChild(title);
                
                // 找到最短的（作为默认选择）
                let shortestIndex = 0;
                let shortestLength = Infinity;
                group.variants.forEach((variant, idx) => {
                    const value = variant[fieldName] || variant.origin || variant.dest || variant.polWharf || '';
                    const length = value.length;
                    if (length < shortestLength) {
                        shortestLength = length;
                        shortestIndex = idx;
                    }
                });
                
                // 为每个变体创建选项
                group.variants.forEach((variant, variantIndex) => {
                    const option = document.createElement('div');
                    option.className = 'vessel-voyage-option';
                    const isShortest = variantIndex === shortestIndex;
                    const value = variant[fieldName] || variant.origin || variant.dest || variant.polWharf || '';
                    
                    if (isShortest) {
                        option.classList.add('selected');
                        selections.set(group.normalized, value);
                    }
                    
                    const radio = document.createElement('input');
                    radio.type = 'radio';
                    radio.name = `${fieldName}Group_${groupIndex}`;
                    radio.value = value;
                    radio.checked = isShortest;
                    radio.addEventListener('change', () => {
                        groupDiv.querySelectorAll('.vessel-voyage-option').forEach(opt => {
                            opt.classList.remove('selected');
                        });
                        option.classList.add('selected');
                        selections.set(group.normalized, value);
                    });
                    
                    const label = document.createElement('label');
                    label.className = 'vessel-voyage-option-label';
                    label.textContent = value || '';
                    
                    const count = document.createElement('span');
                    count.className = 'vessel-voyage-option-count';
                    count.textContent = `(${variant.count} 条)`;
                    
                    option.appendChild(radio);
                    option.appendChild(label);
                    option.appendChild(count);
                    option.addEventListener('click', () => {
                        radio.checked = true;
                        radio.dispatchEvent(new Event('change'));
                    });
                    
                    groupDiv.appendChild(option);
                });
                
                list.appendChild(groupDiv);
            });
            
            // 显示模态框
            modal.classList.remove('hidden');
            
            // 应用按钮
            applyBtn.onclick = () => {
                modal.classList.add('hidden');
                resolve(selections);
            };
            
            // 跳过按钮
            skipBtn.onclick = () => {
                modal.classList.add('hidden');
                resolve(new Map());
            };
        });
    }

    /**
     * 通用标准化替换函数
     * @param {Array<Array>} merged - 合并后的数据（包含表头）
     * @param {Map} replacements - 替换映射 {normalized: value}
     * @param {number} fieldIndex - 字段索引（0=起运港, 1=目的港, 13=起运港码头）
     * @param {Function} normalizeFn - 规范化函数
     * @returns {Array<Array>} 替换后的数据
     */
    function applyStandardizationReplacements(merged, replacements, fieldIndex, normalizeFn) {
        if (replacements.size === 0) return merged;
        
        const result = [merged[0]]; // 保留表头
        
        for (let i = 1; i < merged.length; i++) {
            const row = [...merged[i]]; // 复制行
            const value = row[fieldIndex] || '';
            
            const normalized = normalizeFn ? normalizeFn(value) : normalizeString(value);
            if (normalized && replacements.has(normalized)) {
                const replacement = replacements.get(normalized);
                row[fieldIndex] = replacement;
            }
            
            result.push(row);
        }
        
        return result;
    }

    /**
     * 渲染预览表格 - 使用 parser-utils.js 中的函数
     * @param {Array<Array>} rows - 行数据数组
     */
    function renderPreviewLocal(rows) {
        const headers = [
            '启运港', '目的港', '航线ID', '港口ID', '开航日', '航程', '共舱船公司',
            '船名', '航次', '船型', '计划开航', '实际离港', '预计到港', '启运港码头', '目的港码头'
        ];
        renderPreview(rows, '#preview', '#table', headers, 50);
    }

    const picker = selectElement('#picker');
    const runBtn = selectElement('#run');
    const downloadBtn = selectElement('#download');
    const summary = selectElement('#summary');
    const logBox = selectElement('#log');
    let files = [];
    let output = [];

    picker.addEventListener('change', () => {
        if (logBox) logBox.innerHTML = '';
        output = [];
        summary.textContent = '';
        files = Array.from(picker.files)
            .filter(file => /\.html?$/i.test(file.name))
            .sort((a, b) => a.name.localeCompare(b.name));
        if (!files.length) {
            log('未选择到 HTML 文件，请重新选择 standard 文件夹。', '#b00020');
            runBtn.disabled = true;
            downloadBtn.disabled = true;
            return;
        }
        log(`已选择 ${files.length} 个 HTML 文件。`, '#0a7d33');
        runBtn.disabled = false;
        downloadBtn.disabled = true;
        const preview = selectElement('#preview');
        if (preview) preview.classList.add('hidden');
    });

    runBtn.addEventListener('click', async () => {
        runBtn.disabled = true;
        downloadBtn.disabled = true;
        output = [];
        const preview = selectElement('#preview');
        if (preview) preview.classList.add('hidden');
        const header = [
            '启运港', '目的港', '航线ID', '港口ID', '开航日', '航程', '共舱船公司',
            '船名', '航次', '船型', '计划开航', '实际离港', '预计到港', '启运港码头', '目的港码头'
        ];
        const rows = [header];
        const htmlCache = new Map(); // 缓存解码后的HTML内容（key: 行索引, value: 解码后的HTML）
        const originalHtmlCache = new Map(); // 缓存原始HTML内容（key: 行索引, value: 原始HTML）
        // 建立基于航线ID+港口ID的全局HTML映射（用于补充机制）
        const linePortHtmlGlobalMap = new Map(); // key: `${lineId}_${portId}`, value: Array<{decodedHtml, originalHtml}>
        let ok = 0;
        let warn = 0;
        for (const file of files) {
            try {
                const html = await file.text();
                // 优化：先解码一次，然后传递给 parseFile，避免重复解码
                const decodedHtml = extractDecodedPayload(html);
                const parsedRows = parseFile(file.name, html, decodedHtml);
                if (!parsedRows.length) {
                    warn++;
                    log(`[无船期] ${file.name}`, '#b36b00');
                } else {
                    ok++;
                    log(`[OK] ${file.name} -> ${parsedRows.length} 行`, '#0a7d33');
                    // 缓存解码后的HTML和原始HTML，避免重复解码
                    const startIndex = rows.length;
                    for (let j = 0; j < parsedRows.length; j++) {
                        const row = parsedRows[j];
                        if (row.length > 0 && row[0] !== '启运港') { // 跳过表头
                            htmlCache.set(startIndex + j, decodedHtml); // 存储解码后的HTML
                            originalHtmlCache.set(startIndex + j, html); // 存储原始HTML
                            
                            // 建立基于航线ID+港口ID的全局HTML映射
                            const lineId = row[2] || ''; // 航线ID
                            const portId = row[3] || ''; // 港口ID
                            if (lineId && portId) {
                                const linePortKey = `${lineId}_${portId}`;
                                if (!linePortHtmlGlobalMap.has(linePortKey)) {
                                    linePortHtmlGlobalMap.set(linePortKey, []);
                                }
                                const htmlList = linePortHtmlGlobalMap.get(linePortKey);
                                // 避免重复添加相同的HTML
                                const htmlExists = htmlList.some(h => h.decodedHtml === decodedHtml);
                                if (!htmlExists) {
                                    htmlList.push({
                                        decodedHtml: decodedHtml,
                                        originalHtml: html
                                    });
                                }
                            }
                        }
                    }
                    rows.push(...parsedRows);
                }
            } catch (error) {
                warn++;
                const errorMessage = error && error.message ? error.message : error;
                log(`[失败] ${file.name}: ${errorMessage}`, '#b00020');
            }
        }
        // 去重合并：键 = 启运港 + 目的港 + 航线ID + 港口ID + 船名 + 航次；共舱船公司合并去重
        const deduplicationMap = new Map();
        const mergedHtmlCache = new Map(); // 存储合并后记录的HTML引用（key: 合并后的key, value: 解码后的HTML）
        const mergedOriginalHtmlCache = new Map(); // 存储合并后记录的原始HTML引用（key: 合并后的key, value: 原始HTML）
        for (let i = 1; i < rows.length; i++) {
            const [
                origin,
                dest,
                lineId,
                portId,
                weekday,
                shipdays,
                carriers,
                vesselName,
                voyage,
                shipType,
                plan,
                atd,
                eta,
                polWharf,
                podWharf
            ] = rows[i].map(clean);
            
            const key = [origin, dest, lineId, portId, vesselName, voyage].join('|');
            if (!deduplicationMap.has(key)) {
                deduplicationMap.set(key, [
                    origin,
                    dest,
                    lineId,
                    portId,
                    weekday,
                    shipdays,
                    carriers,
                    vesselName,
                    voyage,
                    shipType,
                    plan,
                    atd,
                    eta,
                    polWharf,
                    podWharf
                ]);
                // 保存解码后的HTML和原始HTML引用
                if (htmlCache.has(i)) {
                    mergedHtmlCache.set(key, htmlCache.get(i));
                }
                if (originalHtmlCache.has(i)) {
                    mergedOriginalHtmlCache.set(key, originalHtmlCache.get(i));
                }
            } else {
                const existing = deduplicationMap.get(key);
                // 合并开航日/航程（保留已有，若空则补）
                if (!existing[4] && weekday) existing[4] = weekday;
                if (!existing[5] && shipdays) existing[5] = shipdays;
                // 共舱：按需求使用 <a title> 的文本，不再拼接合并；优先保留已存在的非空值
                if (!existing[6] && carriers) existing[6] = carriers;
                // 补充缺失的关键字段：船名、航次、计划开航、预计到港、目的港码头
                if (!existing[7] && vesselName) existing[7] = vesselName;
                if (!existing[8] && voyage) existing[8] = voyage;
                if (!existing[10] && plan) existing[10] = plan;
                if (!existing[12] && eta) existing[12] = eta;
                if (!existing[14] && podWharf) existing[14] = podWharf;
                // 其他字段以首条为准，如ATD/启运港码头一般一致
                // 如果当前行有HTML引用但已有记录没有，则保存（优先使用有更多数据的记录）
                if (htmlCache.has(i) && !mergedHtmlCache.has(key)) {
                    mergedHtmlCache.set(key, htmlCache.get(i));
                }
                if (originalHtmlCache.has(i) && !mergedOriginalHtmlCache.has(key)) {
                    mergedOriginalHtmlCache.set(key, originalHtmlCache.get(i));
                }
            }
        }
        const merged = [header, ...Array.from(deduplicationMap.values())];
        
        // 合并后的补充机制：对仍然缺失的字段进行补充（增强：放宽条件，支持从多个来源补充）
        // 使用全局HTML映射，确保能够从所有相同航线ID+港口ID的HTML中查找
        const needSupplement = [];
        for (let i = 1; i < merged.length; i++) {
            const row = merged[i];
            const [
                origin, dest, lineId, portId, weekday, shipdays, carriers,
                vesselName, voyage, shipType, plan, atd, eta, polWharf, podWharf
            ] = row;
            
            // 放宽条件：即使只有单个字段缺失也应该尝试补充
            // 检查目的港码头是否只有简写（没有/分隔符且长度较短）
            const podWharfOnlyShort = podWharf && !podWharf.includes('/') && podWharf.length < 15;
            
            const missing = {
                vesselName: !vesselName,
                voyage: !voyage,
                plan: !plan,
                eta: !eta,
                weekday: !weekday,
                shipdays: !shipdays,
                polWharf: !polWharf,
                podWharf: !podWharf || podWharfOnlyShort // 如果只有简写，也算缺失
            };
            
            // 检查是否有任何字段缺失
            const hasAnyMissing = Object.values(missing).some(v => v);
            
            // 只要有缺失字段且有航线ID和港口ID，就尝试补充
            if (hasAnyMissing && lineId && portId) {
                const rowKey = [origin, dest, lineId, portId, vesselName, voyage].join('|');
                // 优先使用该记录的HTML
                let decodedHtml = mergedHtmlCache.get(rowKey);
                let originalHtml = mergedOriginalHtmlCache.get(rowKey);
                
                // 如果没有该记录的HTML，从全局HTML映射中查找相同航线ID+港口ID的HTML
                if (!decodedHtml && !originalHtml) {
                    const linePortKey = `${lineId}_${portId}`;
                    const htmlList = linePortHtmlGlobalMap.get(linePortKey);
                    if (htmlList && htmlList.length > 0) {
                        // 使用第一个可用的HTML（通常这些HTML都包含相同航线ID+港口ID的信息）
                        decodedHtml = htmlList[0].decodedHtml;
                        originalHtml = htmlList[0].originalHtml;
                    }
                }
                
                // 只要有HTML（无论是该记录的还是相同航线ID+港口ID的），就尝试补充
                if (decodedHtml || originalHtml) {
                    needSupplement.push({
                        row: row,
                        rowKey: rowKey,
                        lineId: lineId,
                        portId: portId,
                        decodedHtml: decodedHtml,
                        originalHtml: originalHtml,
                        missing: missing
                    });
                }
            }
        }
        
        // 批量补充：使用缓存的解码HTML，避免重复解码（增强：支持从多个来源补充）
        if (needSupplement.length > 0) {
            log(`正在补充 ${needSupplement.length} 条缺失数据...`, '#0a7d33');
            // 优化：按HTML文件分组，减少重复的visibleData提取
            const htmlToVisibleData = new Map(); // key: HTML内容的key, value: visibleData Map
            
            // 先建立HTML到visibleData的映射（包括所有可能用到的HTML源）
            const allHtmlSources = new Set();
            for (const item of needSupplement) {
                // 添加该记录的HTML
                if (item.originalHtml || item.decodedHtml) {
                    allHtmlSources.add(item.originalHtml || item.decodedHtml);
                }
                // 添加相同航线ID+港口ID的所有HTML
                const linePortKey = `${item.lineId}_${item.portId}`;
                const htmlList = linePortHtmlGlobalMap.get(linePortKey) || [];
                for (const htmlItem of htmlList) {
                    if (htmlItem.originalHtml || htmlItem.decodedHtml) {
                        allHtmlSources.add(htmlItem.originalHtml || htmlItem.decodedHtml);
                    }
                }
            }
            
            // 为所有HTML源提取visibleData
            for (const htmlForExtraction of allHtmlSources) {
                if (htmlForExtraction) {
                    const htmlKey = htmlForExtraction.substring(0, 1000);
                    if (!htmlToVisibleData.has(htmlKey)) {
                        // 检查是否有需要visibleData的记录
                        const needsVisibleData = Array.from(needSupplement).some(item => 
                            item.missing.plan || item.missing.podWharf
                        );
                        if (needsVisibleData) {
                            const visibleData = extractVisibleScheduleData(htmlForExtraction);
                            htmlToVisibleData.set(htmlKey, visibleData);
                        } else {
                            htmlToVisibleData.set(htmlKey, null);
                        }
                    }
                }
            }
            
            // 批量补充（增强：尝试多个HTML源）
            let supplementedCount = 0;
            for (const item of needSupplement) {
                let decodedHtml = item.decodedHtml;
                let originalHtml = item.originalHtml;
                
                // 如果第一个HTML没有找到所有缺失的数据，尝试从其他相同航线ID+港口ID的HTML中查找
                const linePortKey = `${item.lineId}_${item.portId}`;
                const htmlList = linePortHtmlGlobalMap.get(linePortKey) || [];
                let htmlIndex = 0;
                
                // 记录当前缺失的字段
                const stillMissing = {...item.missing};
                
                // 尝试多个HTML源，直到找到所有缺失的数据或尝试完所有HTML
                while (htmlIndex < htmlList.length + 1) {
                    if (decodedHtml || originalHtml) {
                        const htmlForExtraction = originalHtml || decodedHtml;
                        const htmlKey = htmlForExtraction ? htmlForExtraction.substring(0, 1000) : null;
                        // 获取visibleData，如果没有则尝试提取
                        let visibleData = htmlKey ? htmlToVisibleData.get(htmlKey) : null;
                        if (visibleData === undefined && htmlForExtraction) {
                            // 如果还没有提取过，现在提取
                            const needsVisibleData = stillMissing.plan || stillMissing.podWharf;
                            if (needsVisibleData) {
                                visibleData = extractVisibleScheduleData(htmlForExtraction);
                                if (htmlKey) {
                                    htmlToVisibleData.set(htmlKey, visibleData);
                                }
                            } else {
                                visibleData = null;
                                if (htmlKey) {
                                    htmlToVisibleData.set(htmlKey, null);
                                }
                            }
                        }
                        
                        const supplemented = supplementMissingData(decodedHtml || originalHtml, item.lineId, item.portId, {
                            vesselName: item.row[7] || '',
                            voyage: item.row[8] || '',
                            plan: item.row[10] || '',
                            eta: item.row[12] || '',
                            weekday: item.row[4] || '',
                            shipdays: item.row[5] || '',
                            polWharf: item.row[13] || '',
                            podWharf: item.row[14] || ''
                        }, visibleData);
                        
                        let hasUpdate = false;
                        // 只更新仍然缺失的字段
                        if (stillMissing.vesselName && supplemented.vesselName) {
                            item.row[7] = clean(supplemented.vesselName);
                            stillMissing.vesselName = false;
                            hasUpdate = true;
                        }
                        if (stillMissing.voyage && supplemented.voyage) {
                            item.row[8] = clean(supplemented.voyage);
                            stillMissing.voyage = false;
                            hasUpdate = true;
                        }
                        if (stillMissing.plan && supplemented.plan) {
                            item.row[10] = clean(supplemented.plan);
                            stillMissing.plan = false;
                            hasUpdate = true;
                        }
                        if (stillMissing.eta && supplemented.eta) {
                            item.row[12] = clean(supplemented.eta);
                            stillMissing.eta = false;
                            hasUpdate = true;
                        }
                        if (stillMissing.weekday && supplemented.weekday) {
                            item.row[4] = clean(supplemented.weekday);
                            stillMissing.weekday = false;
                            hasUpdate = true;
                        }
                        if (stillMissing.shipdays && supplemented.shipdays) {
                            item.row[5] = clean(supplemented.shipdays);
                            stillMissing.shipdays = false;
                            hasUpdate = true;
                        }
                        if (stillMissing.polWharf && supplemented.polWharf) {
                            item.row[13] = clean(supplemented.polWharf);
                            stillMissing.polWharf = false;
                            hasUpdate = true;
                        }
                        if (stillMissing.podWharf && supplemented.podWharf) {
                            // 如果原值只有简写，新值有简写+全称，使用新值；否则使用新值
                            const currentPodWharf = item.row[14] || '';
                            const newPodWharf = clean(supplemented.podWharf);
                            if (newPodWharf.includes('/') || !currentPodWharf) {
                                item.row[14] = newPodWharf;
                                stillMissing.podWharf = false;
                                hasUpdate = true;
                            } else if (currentPodWharf && !currentPodWharf.includes('/') && newPodWharf && !newPodWharf.includes('/')) {
                                // 如果都是简写，使用新值（可能更准确）
                                item.row[14] = newPodWharf;
                                stillMissing.podWharf = false;
                                hasUpdate = true;
                            }
                        }
                        
                        if (hasUpdate) {
                            supplementedCount++;
                        }
                        
                        // 如果所有缺失的字段都已补充，提前退出
                        if (!Object.values(stillMissing).some(v => v)) {
                            break;
                        }
                    }
                    
                    // 尝试下一个HTML源
                    if (htmlIndex < htmlList.length) {
                        decodedHtml = htmlList[htmlIndex].decodedHtml;
                        originalHtml = htmlList[htmlIndex].originalHtml;
                        htmlIndex++;
                    } else {
                        break;
                    }
                }
            }
            
            if (supplementedCount > 0) {
                log(`✅ 已补充 ${supplementedCount} 条记录的缺失字段`, '#0a7d33');
            }
        }
        // 移除跨页面的目的港码头补全逻辑，避免补到不是该港口的目的港
        // 目的港码头的补全应该在当页完成（在processFleetData中）

        // 数据质量检查报告
        const qualityReport = generateQualityReport(merged);
        
        // 处理船名航次和目的港码头的标准化（按顺序处理）
        const processStandardization = async (currentMerged, currentReport) => {
            let processedMerged = currentMerged;
            let processedReport = currentReport;
            
            // 第一步：处理船名航次标准化
            if (processedReport.duplicateVesselVoyage.length > 0) {
                log(`\n🔍 发现 ${processedReport.duplicateVesselVoyage.length} 组可能重复的船名航次（空格差异），请选择标准格式...`, '#0a7d33');
                
                const replacements = await showVesselVoyageModal(processedReport.duplicateVesselVoyage);
                if (replacements.size > 0) {
                    log(`正在应用船名航次标准化替换...`, '#0a7d33');
                    processedMerged = applyVesselVoyageReplacements(processedMerged, replacements);
                    processedReport = generateQualityReport(processedMerged);
                    log(`\n✅ 已应用 ${replacements.size} 组船名航次标准化`, '#0a7d33');
                } else {
                    log(`\n⏭️ 已跳过船名航次标准化，保留原值`, '#666');
                }
            }
            
            // 第二步：处理目的港码头标准化
            if (processedReport.duplicatePodWharf.length > 0) {
                log(`\n🔍 发现 ${processedReport.duplicatePodWharf.length} 组可能重复的目的港码头（空格差异），请选择标准格式...`, '#0a7d33');
                
                const podWharfReplacements = await showPodWharfModal(processedReport.duplicatePodWharf);
                if (podWharfReplacements.size > 0) {
                    log(`正在应用目的港码头标准化替换...`, '#0a7d33');
                    processedMerged = applyPodWharfReplacements(processedMerged, podWharfReplacements);
                    processedReport = generateQualityReport(processedMerged);
                    log(`\n✅ 已应用 ${podWharfReplacements.size} 组目的港码头标准化`, '#0a7d33');
                } else {
                    log(`\n⏭️ 已跳过目的港码头标准化，保留原值`, '#666');
                }
            }
            
            // 第三步：处理起运港标准化
            if (processedReport.duplicateOrigin.length > 0) {
                log(`\n🔍 发现 ${processedReport.duplicateOrigin.length} 组可能重复的起运港（空格差异），请选择标准格式...`, '#0a7d33');
                
                const originReplacements = await showStandardizationModal(processedReport.duplicateOrigin, 'origin', '起运港');
                if (originReplacements.size > 0) {
                    log(`正在应用起运港标准化替换...`, '#0a7d33');
                    processedMerged = applyStandardizationReplacements(processedMerged, originReplacements, 0, normalizeString);
                    processedReport = generateQualityReport(processedMerged);
                    log(`\n✅ 已应用 ${originReplacements.size} 组起运港标准化`, '#0a7d33');
                } else {
                    log(`\n⏭️ 已跳过起运港标准化，保留原值`, '#666');
                }
            }
            
            // 第四步：处理目的港标准化
            if (processedReport.duplicateDest.length > 0) {
                log(`\n🔍 发现 ${processedReport.duplicateDest.length} 组可能重复的目的港（空格差异），请选择标准格式...`, '#0a7d33');
                
                const destReplacements = await showStandardizationModal(processedReport.duplicateDest, 'dest', '目的港');
                if (destReplacements.size > 0) {
                    log(`正在应用目的港标准化替换...`, '#0a7d33');
                    processedMerged = applyStandardizationReplacements(processedMerged, destReplacements, 1, normalizeString);
                    processedReport = generateQualityReport(processedMerged);
                    log(`\n✅ 已应用 ${destReplacements.size} 组目的港标准化`, '#0a7d33');
                } else {
                    log(`\n⏭️ 已跳过目的港标准化，保留原值`, '#666');
                }
            }
            
            // 第五步：处理起运港码头标准化
            if (processedReport.duplicatePolWharf.length > 0) {
                log(`\n🔍 发现 ${processedReport.duplicatePolWharf.length} 组可能重复的起运港码头（空格差异），请选择标准格式...`, '#0a7d33');
                
                const polWharfReplacements = await showStandardizationModal(processedReport.duplicatePolWharf, 'polWharf', '起运港码头');
                if (polWharfReplacements.size > 0) {
                    log(`正在应用起运港码头标准化替换...`, '#0a7d33');
                    processedMerged = applyStandardizationReplacements(processedMerged, polWharfReplacements, 13, normalizePodWharf);
                    processedReport = generateQualityReport(processedMerged);
                    log(`\n✅ 已应用 ${polWharfReplacements.size} 组起运港码头标准化`, '#0a7d33');
                } else {
                    log(`\n⏭️ 已跳过起运港码头标准化，保留原值`, '#666');
                }
            }
            
            return { merged: processedMerged, report: processedReport };
        };
        
        // 执行标准化处理
        processStandardization(merged, qualityReport).then(({ merged: standardizedMerged, report: standardizedReport }) => {
            // 第三步：按目的港+航线ID+船名+航次进行去重合并
            log(`\n🔄 正在进行去重合并（目的港+航线ID+船名+航次）...`, '#0a7d33');
            const finalDeduplicationMap = new Map();
            const beforeCount = standardizedMerged.length - 1; // 排除表头
            
            for (let i = 1; i < standardizedMerged.length; i++) {
                const row = standardizedMerged[i];
                const [
                    origin,
                    dest,
                    lineId,
                    portId,
                    weekday,
                    shipdays,
                    carriers,
                    vesselName,
                    voyage,
                    shipType,
                    plan,
                    atd,
                    eta,
                    polWharf,
                    podWharf
                ] = row.map(clean);
                
                // 新的去重键：目的港 + 航线ID + 船名 + 航次
                const dedupKey = [dest, lineId, vesselName, voyage].join('|');
                
                if (!finalDeduplicationMap.has(dedupKey)) {
                    // 首次出现，直接添加
                    finalDeduplicationMap.set(dedupKey, [
                        origin,
                        dest,
                        lineId,
                        portId,
                        weekday,
                        shipdays,
                        carriers,
                        vesselName,
                        voyage,
                        shipType,
                        plan,
                        atd,
                        eta,
                        polWharf,
                        podWharf
                    ]);
                } else {
                    // 已存在，合并数据（保留更完整的记录）
                    const existing = finalDeduplicationMap.get(dedupKey);
                    
                    // 合并启运港：如果新记录的启运港不同，保留已有的（或选择更完整的）
                    // 合并港口ID：保留已有的
                    // 合并开航日/航程（保留已有，若空则补）
                    if (!existing[4] && weekday) existing[4] = weekday;
                    if (!existing[5] && shipdays) existing[5] = shipdays;
                    // 共舱：优先保留已存在的非空值
                    if (!existing[6] && carriers) existing[6] = carriers;
                    // 补充缺失的关键字段：计划开航、预计到港、目的港码头
                    if (!existing[10] && plan) existing[10] = plan;
                    if (!existing[12] && eta) existing[12] = eta;
                    if (!existing[14] && podWharf) existing[14] = podWharf;
                    // 启运港码头：如果新记录有而旧记录没有，则补充
                    if (!existing[13] && polWharf) existing[13] = polWharf;
                    // 船型：保留已有的
                    // 实际离港：保留已有的
                }
            }
            
            const finalMerged = [header, ...Array.from(finalDeduplicationMap.values())];
            const afterCount = finalMerged.length - 1; // 排除表头
            const mergedCount = beforeCount - afterCount;
            
            if (mergedCount > 0) {
                log(`✅ 去重完成：合并了 ${mergedCount} 条重复记录（从 ${beforeCount} 条减少到 ${afterCount} 条）`, '#0a7d33');
            }
            
            // 重新生成质量报告
            const finalReport = generateQualityReport(finalMerged);
            
            output = finalMerged;
            displayQualityReport(finalReport, true);
            renderPreviewLocal(finalMerged.slice(1));
            downloadBtn.disabled = finalMerged.length <= 1;
            summary.textContent = `完成：${ok} 文件，${warn} 提醒，合并后 ${finalMerged.length - 1} 条。`;
        });
    });

    /**
     * 显示数据质量检查报告
     * @param {Object} qualityReport - 质量报告对象
     * @param {boolean} skipDuplicates - 是否跳过重复船名航次的显示（因为已经处理过了）
     */
    function displayQualityReport(qualityReport, skipDuplicates = false) {
        if (qualityReport.hasIssues) {
            log(`\n📊 数据质量检查报告：`, '#0a7d33');
            if (!skipDuplicates && qualityReport.duplicateVesselVoyage.length > 0) {
                log(`⚠️ 发现 ${qualityReport.duplicateVesselVoyage.length} 组可能重复的船名航次（空格差异）`, '#b36b00');
            }
            if (!skipDuplicates && qualityReport.duplicatePodWharf.length > 0) {
                log(`⚠️ 发现 ${qualityReport.duplicatePodWharf.length} 组可能重复的目的港码头（空格差异）`, '#b36b00');
            }
            if (qualityReport.missingWeekday > 0) {
                log(`⚠️ 缺失开航日：${qualityReport.missingWeekday} 条`, '#b36b00');
            }
            if (qualityReport.missingShipdays > 0) {
                log(`⚠️ 缺失航程：${qualityReport.missingShipdays} 条`, '#b36b00');
            }
            if (qualityReport.missingPlan > 0) {
                log(`⚠️ 缺失计划开航：${qualityReport.missingPlan} 条`, '#b36b00');
            }
            if (qualityReport.missingEta > 0) {
                log(`⚠️ 缺失预计到港：${qualityReport.missingEta} 条（其中 ${qualityReport.missingEtaNotBlank} 条非BLANK SAILING）`, '#b36b00');
            }
            if (qualityReport.missingPolWharf > 0) {
                log(`⚠️ 缺失启运港码头：${qualityReport.missingPolWharf} 条`, '#b36b00');
            }
            if (qualityReport.missingPodWharf > 0) {
                log(`⚠️ 缺失目的港码头：${qualityReport.missingPodWharf} 条`, '#b36b00');
            }
            if (qualityReport.podWharfOnlyShort > 0) {
                log(`⚠️ 目的港码头只有简写（缺少全称）：${qualityReport.podWharfOnlyShort} 条`, '#b36b00');
            }
        } else {
            log(`\n✅ 数据质量检查通过，未发现明显问题`, '#0a7d33');
        }
    }

    downloadBtn.addEventListener('click', () => {
        if (!output || output.length <= 1) return;
        const csv = '\uFEFF' + rowsToCsv(output);
        downloadBlob(csv, generateTimestampFilename('weiyun-schedule'), 'text/csv;charset=utf-8');
    });
})();
    </script>
</body>
</html>

