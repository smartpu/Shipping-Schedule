<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç»´è¿ç½‘ èˆ¹æœŸè§£æå·¥å…·</title>
    <link rel="stylesheet" href="vendor/auth.css">
    <link rel="stylesheet" href="vendor/common-styles.css">
    <link rel="stylesheet" href="vendor/tool-styles.css">
    <link rel="stylesheet" href="vendor/parser-styles.css">
    <style>
        /* é¡µé¢ç‰¹å®šæ ·å¼ï¼ˆä¿ç•™ä¸å…¬å…±æ ·å¼ä¸åŒçš„éƒ¨åˆ†ï¼‰ */
    </style>
</head>
<body data-page="001-02-schedule-parser.html">
    <!-- ç”¨æˆ·éªŒè¯æ¨¡æ€æ¡† -->
    <div id="authOverlay" class="auth-overlay">
        <div class="auth-modal">
            <h2>ğŸ” è®¿é—®éªŒè¯</h2>
            <p>ä¸ºäº†äº†è§£å·¥å…·ä½¿ç”¨æƒ…å†µï¼Œè¯·å¡«å†™ä»¥ä¸‹ä¿¡æ¯</p>
            <form id="authForm">
                <div class="auth-form-group">
                    <label for="userName">å§“å *</label>
                    <input type="text" id="userName" name="userName" placeholder="è¯·è¾“å…¥æ‚¨çš„å§“å" required autocomplete="name">
                    <div class="auth-error" id="nameError">è¯·è¾“å…¥æ‚¨çš„å§“å</div>
                </div>
                <div class="auth-form-group">
                    <label for="userPhone">æ‰‹æœºå· *</label>
                    <input type="tel" id="userPhone" name="userPhone" placeholder="è¯·è¾“å…¥æ‚¨çš„æ‰‹æœºå·" required autocomplete="tel">
                    <div class="auth-error" id="phoneError">è¯·è¾“å…¥æœ‰æ•ˆçš„æ‰‹æœºå·</div>
                </div>
                <div class="auth-form-group">
                    <label for="userEmail">é‚®ç®± *</label>
                    <input type="email" id="userEmail" name="userEmail" placeholder="è¯·è¾“å…¥æ‚¨çš„é‚®ç®±åœ°å€" required autocomplete="email">
                    <div class="auth-error" id="emailError">è¯·è¾“å…¥æœ‰æ•ˆçš„é‚®ç®±åœ°å€</div>
                </div>
                <button type="submit" class="auth-submit-btn">ç¡®è®¤å¹¶ç»§ç»­</button>
            </form>
        </div>
    </div>
    <div class="container">
        <div class="header">
            <a href="index.html?tab=tools001" class="back-home-btn">â† è¿”å›é¦–é¡µ</a>
            <a href="001-02-schedule-parser-README.html" class="readme-btn">ä½¿ç”¨è¯´æ˜ â†’</a>
            <h1>ç»´è¿ç½‘ èˆ¹æœŸè§£æå·¥å…·</h1>
            <p>è‡ªåŠ¨è§£æç»´è¿ç½‘èˆ¹æœŸç½‘é¡µï¼Œæå–èˆ¹æœŸä¿¡æ¯å¹¶å¯¼å‡ºä¸º CSV æ–‡ä»¶</p>
        </div>

        <div class="instructions">
            <h3>ğŸ“‹ ä½¿ç”¨è¯´æ˜</h3>
            <ol>
                <li><strong>å‡†å¤‡å·¥ä½œ</strong>ï¼šé¦–å…ˆéœ€è¦ä½¿ç”¨"ç»´è¿ç½‘ èˆ¹æœŸç½‘é¡µæ‰‹åŠ¨ä¸‹è½½å·¥å…·"ä¸‹è½½å¹¶ä¿å­˜æ‰€æœ‰èˆ¹æœŸç½‘é¡µåˆ° <strong>001-view-source</strong> æ–‡ä»¶å¤¹ä¸­</li>
                <li><strong>é€‰æ‹©æ–‡ä»¶å¤¹</strong>ï¼šç‚¹å‡»"é€‰æ‹© view-source æ–‡ä»¶å¤¹"æŒ‰é’®ï¼Œé€‰æ‹©åŒ…å«æ‰€æœ‰ HTML æ–‡ä»¶çš„ <strong>001-view-source</strong> æ–‡ä»¶å¤¹</li>
                <li><strong>å¼€å§‹è§£æ</strong>ï¼šé€‰æ‹©æ–‡ä»¶å¤¹åï¼Œç‚¹å‡»"å¼€å§‹è§£æ"æŒ‰é’®ï¼Œå·¥å…·ä¼šè‡ªåŠ¨è§£ææ‰€æœ‰ HTML æ–‡ä»¶ä¸­çš„èˆ¹æœŸä¿¡æ¯</li>
                <li><strong>æŸ¥çœ‹ç»“æœ</strong>ï¼šè§£æå®Œæˆåï¼Œå¯ä»¥åœ¨ä¸‹æ–¹é¢„è§ˆè¡¨æ ¼ä¸­æŸ¥çœ‹è§£æç»“æœï¼ˆæœ€å¤šæ˜¾ç¤ºå‰50æ¡ï¼‰</li>
                <li><strong>ä¸‹è½½ CSV</strong>ï¼šç¡®è®¤è§£æç»“æœæ— è¯¯åï¼Œç‚¹å‡»"ä¸‹è½½ CSV"æŒ‰é’®ï¼Œå°†æ•°æ®ä¿å­˜ä¸º CSV æ–‡ä»¶</li>
                <li><strong>ç»“æœè¯´æ˜</strong>ï¼šCSV æ–‡ä»¶åŒ…å«ä»¥ä¸‹åˆ—ï¼šå¯è¿æ¸¯ã€ç›®çš„æ¸¯ã€èˆªçº¿IDã€æ¸¯å£IDã€å¼€èˆªæ—¥ã€èˆªç¨‹ã€å…±èˆ±èˆ¹å…¬å¸ã€èˆ¹åã€èˆªæ¬¡ã€èˆ¹å‹ã€è®¡åˆ’å¼€èˆªã€å®é™…ç¦»æ¸¯ã€é¢„è®¡åˆ°æ¸¯ã€å¯è¿æ¸¯ç å¤´ã€ç›®çš„æ¸¯ç å¤´</li>
                <li><strong>æ³¨æ„äº‹é¡¹</strong>ï¼šå·¥å…·ä¼šè‡ªåŠ¨åˆå¹¶é‡å¤çš„èˆ¹æœŸè®°å½•ï¼ˆç›¸åŒå¯è¿æ¸¯+ç›®çš„æ¸¯+èˆªçº¿ID+æ¸¯å£ID+èˆ¹å+èˆªæ¬¡ï¼‰ï¼Œå…±èˆ±èˆ¹å…¬å¸ä¿¡æ¯ä¼šä»ç½‘é¡µä¸­è‡ªåŠ¨æå–</li>
            </ol>
        </div>

        <div class="content">
            <div class="card">
                <div class="controls">
                    <label class="file-btn">
                        é€‰æ‹© view-source æ–‡ä»¶å¤¹
                        <input id="picker" type="file" webkitdirectory multiple accept=".html,.htm">
                    </label>
                    <button id="run" class="btn" disabled>å¼€å§‹è§£æ</button>
                    <button id="download" class="btn" disabled>ä¸‹è½½ CSV</button>
                    <span id="summary"></span>
                </div>
                <div id="log" class="log" aria-live="polite"></div>
                <div id="preview" class="hidden">
                    <table id="table"></table>
                </div>
            </div>
        </div>

        <div class="footer">
            <p>æç¤ºï¼šè§£æè¿‡ç¨‹ä¸­è¯·å‹¿å…³é—­é¡µé¢ï¼Œè§£æå®Œæˆåä¼šè‡ªåŠ¨æ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯</p>
        </div>
    </div>

    <!-- ä½¿ç”¨ Gist å­˜å‚¨ç³»ç»Ÿï¼ˆç”¨æˆ·ç™½åå• + è®¿é—®è®°å½•ï¼‰ -->
    <script src="vendor/auth-gist.js"></script>
    <script src="vendor/parser-utils.js"></script>
    <script>

(function(){
    /**
     * DOM é€‰æ‹©å™¨è¾…åŠ©å‡½æ•°
     * @param {string} selector - CSS é€‰æ‹©å™¨
     * @returns {HTMLElement|null} æ‰¾åˆ°çš„å…ƒç´ 
     */
    const selectElement = (selector) => document.querySelector(selector);
    const log = createLogger('#log');

    /** CSV utils - ä½¿ç”¨ parser-utils.js ä¸­çš„å‡½æ•° */
    /** DOM helpers - ä½¿ç”¨ parser-utils.js ä¸­çš„å‡½æ•° (text, find, findAll) */

    /**
     * ç»Ÿä¸€æ¸…æ´—ï¼šå»é™¤å‰åç©ºç™½ï¼Œå‹ç¼©å†…éƒ¨ç©ºç™½åˆ°å•ç©ºæ ¼ï¼Œç§»é™¤æ¢è¡Œä¸åˆ¶è¡¨
     * @param {any} value - è¦æ¸…æ´—çš„å€¼
     * @returns {string} æ¸…æ´—åçš„å­—ç¬¦ä¸²
     */
    function clean(value) {
        if (value == null) return '';
        const cleanedString = String(value)
            .replace(/[\r\n\t]+/g, ' ')
            .replace(/\s+/g, ' ')
            .trim();
        return cleanedString;
    }

    /** ç‰¹å®šç å¤´åç§°ä¿®æ­£æ˜ å°„ */
    const WHARF_NAME_CORRECTIONS = {
        'TER MINAL': 'TERMINAL',
        'SEA PORT': 'SEAPORT',
        'PANJA NG': 'PANJANG',
        'GUDA NG': 'GUDANG'
    };

    /**
     * åˆå¹¶ç›¸é‚»çš„ç å¤´åç§°ç‰‡æ®µ
     * @param {string} current - å½“å‰ç‰‡æ®µ
     * @param {string} next - ä¸‹ä¸€ä¸ªç‰‡æ®µ
     * @returns {boolean} æ˜¯å¦åº”è¯¥åˆå¹¶
     */
    function shouldMergeTokens(current, next) {
        // è‹¥ä¸‹ä¸€ä¸ªæ˜¯å•ä¸ªå¤§å†™å­—æ¯ï¼Œä¸”å½“å‰ä¸ºå…¨å¤§å†™å­—æ¯ï¼ˆå¦‚ TERMINA + Lï¼‰-> åˆå¹¶
        if (/^[A-Z]+$/.test(current) && /^[A-Z]$/.test(next)) {
            return true;
        }
        // è‹¥ä¸¤è¾¹å‡ä¸º 1-2 ä½çš„å¤§å†™å­—æ¯ç¼©å†™ï¼ˆå¦‚ QQ + CTï¼‰-> åˆå¹¶
        if (/^[A-Z]{1,2}$/.test(current) && /^[A-Z]{1,2}$/.test(next)) {
            return true;
        }
        return false;
    }

    /**
     * åº”ç”¨ç‰¹å®šè¯ä¿®æ­£
     * @param {string} text - è¦ä¿®æ­£çš„æ–‡æœ¬
     * @returns {string} ä¿®æ­£åçš„æ–‡æœ¬
     */
    function applyWharfNameCorrections(text) {
        let correctedText = text;
        for (const [wrong, correct] of Object.entries(WHARF_NAME_CORRECTIONS)) {
            const regex = new RegExp(`\\b${wrong}\\b`, 'g');
            correctedText = correctedText.replace(regex, correct);
        }
        return correctedText;
    }

    /**
     * ç å¤´åæ¸…æ´—ï¼šä¿®å¤è¢«é”™è¯¯æ–­å¼€çš„ç¼©å†™/å•è¯ï¼Œå¦‚ "QQ CT" -> "QQCT", "TERMINA L" -> "TERMINAL"
     * @param {string} name - åŸå§‹ç å¤´åç§°
     * @returns {string} æ¸…æ´—åçš„ç å¤´åç§°
     */
    function normalizeWharfTokens(name) {
        const cleanedName = clean(name);
        if (!cleanedName) return cleanedName;
        
        const parts = cleanedName.split(' ');
        const mergedParts = [];
        
        for (let i = 0; i < parts.length; i++) {
            const currentPart = parts[i];
            if (!currentPart) {
                continue;
            }
            
            // æ£€æŸ¥æ˜¯å¦åº”è¯¥ä¸ä¸‹ä¸€ä¸ªç‰‡æ®µåˆå¹¶
            if (i + 1 < parts.length) {
                const nextPart = parts[i + 1];
                if (shouldMergeTokens(currentPart, nextPart)) {
                    mergedParts.push(currentPart + nextPart);
                    i++; // è·³è¿‡ä¸‹ä¸€ä¸ªç‰‡æ®µï¼Œå› ä¸ºå·²ç»åˆå¹¶
                    continue;
                }
            }
            
            mergedParts.push(currentPart);
        }
        
        const joinedText = mergedParts.join(' ');
        return applyWharfNameCorrections(joinedText);
    }

    /** æœç´¢èŒƒå›´å¸¸é‡ */
    const SEARCH_RANGES = {
        BEFORE_HREF: 500,    // å‘å‰æŸ¥æ‰¾ <a æ ‡ç­¾çš„å¼€å§‹
        AFTER_HREF: 1000,    // å‘åæŸ¥æ‰¾ > æ ‡ç­¾çš„ç»“æŸ
        BEFORE_SUFFIX: 2000, // åœ¨ suffix å‰åæœç´¢çš„èŒƒå›´
        AFTER_SUFFIX: 2000,
        TAG_CONTENT: 3000,   // æ ‡ç­¾å†…å®¹æœ€å¤§é•¿åº¦
        AFTER_TAG: 1500       // <a> æ ‡ç­¾åæŸ¥æ‰¾ title çš„èŒƒå›´
    };

    /** Title å±æ€§åŒ¹é…æ¨¡å¼ */
    const TITLE_PATTERNS = [
        /title=(["'])((?:(?!\1)[\s\S])*?)\1/i,        // title="..." æˆ– title='...'
        /title\s*=\s*(["'])((?:(?!\1)[\s\S])*?)\1/i,  // title = "..." (æœ‰ç©ºæ ¼)
        /title\s*:\s*(["'])((?:(?!\1)[\s\S])*?)\1/i   // title: "..." (JSONæ ¼å¼)
    ];

    /**
     * è½¬ä¹‰ title å€¼ä¸­çš„è½¬ä¹‰åºåˆ—
     * @param {string} titleValue - åŸå§‹ title å€¼
     * @returns {string} è½¬ä¹‰åçš„ title å€¼
     */
    function unescapeTitleValue(titleValue) {
        return titleValue
            .replace(/\\"/g, '"')
            .replace(/\\'/g, "'")
            .replace(/\\n/g, ' ')
            .replace(/\\t/g, ' ')
            .replace(/\\r/g, '');
    }

    /**
     * ä»æ ‡ç­¾å†…å®¹ä¸­æå– title å€¼
     * @param {string} tagContent - æ ‡ç­¾å†…å®¹
     * @returns {string|null} æå–çš„ title å€¼ï¼Œå¦‚æœæœªæ‰¾åˆ°åˆ™è¿”å› null
     */
    function extractTitleFromTagContent(tagContent) {
        for (const titlePattern of TITLE_PATTERNS) {
            const titleMatch = tagContent.match(titlePattern);
            if (titleMatch && titleMatch[2]) {
                const unescapedTitle = unescapeTitleValue(titleMatch[2]);
                const cleanedTitle = clean(unescapedTitle);
                if (cleanedTitle) {
                    return cleanedTitle;
                }
            }
        }
        return null;
    }

    /**
     * ç­–ç•¥1ï¼šé€šè¿‡ href å®šä½æ‰¾åˆ°å¯¹åº”çš„ <a> æ ‡ç­¾å¹¶æå– title
     * @param {string} searchText - è¦æœç´¢çš„æ–‡æœ¬
     * @param {string} suffix - åç¼€ï¼ˆ_fleetId_fleetIdPortï¼‰
     * @param {string} escapedSuffix - è½¬ä¹‰åçš„åç¼€
     * @returns {string|null} æ‰¾åˆ°çš„ title å€¼ï¼Œå¦‚æœæœªæ‰¾åˆ°åˆ™è¿”å› null
     */
    function findTitleByHrefLocation(searchText, suffix, escapedSuffix) {
        const hrefPattern = new RegExp(`href=["']([^"']*${escapedSuffix})["']`, 'gi');
        let hrefMatch;
        
        while ((hrefMatch = hrefPattern.exec(searchText)) !== null) {
            const hrefValue = hrefMatch[1];
            if (!hrefValue || !hrefValue.endsWith(suffix)) {
                continue;
            }
            
            const hrefStart = hrefMatch.index;
            const hrefEnd = hrefMatch.index + hrefMatch[0].length;
            
            // å‘å‰æŸ¥æ‰¾ <a æ ‡ç­¾çš„å¼€å§‹
            const searchStart = Math.max(0, hrefStart - SEARCH_RANGES.BEFORE_HREF);
            const beforeHref = searchText.substring(searchStart, hrefStart);
            const tagStart = beforeHref.lastIndexOf('<a');
            if (tagStart === -1) {
                continue;
            }
            const actualTagStart = searchStart + tagStart;
            
            // å‘åæŸ¥æ‰¾ > æ ‡ç­¾çš„ç»“æŸ
            const searchEnd = Math.min(searchText.length, hrefEnd + SEARCH_RANGES.AFTER_HREF);
            const afterHref = searchText.substring(hrefEnd, searchEnd);
            const tagEnd = afterHref.indexOf('>');
            if (tagEnd === -1) {
                continue;
            }
            const actualTagEnd = hrefEnd + tagEnd;
            
            // æå–æ•´ä¸ªæ ‡ç­¾å†…å®¹
            const tagContent = searchText.substring(actualTagStart, actualTagEnd + 1);
            const title = extractTitleFromTagContent(tagContent);
            if (title) {
                return title;
            }
        }
        
        return null;
    }

    /**
     * ç­–ç•¥2ï¼šä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼ç›´æ¥åŒ¹é…æ•´ä¸ª <a> æ ‡ç­¾
     * @param {string} searchText - è¦æœç´¢çš„æ–‡æœ¬
     * @param {string} suffix - åç¼€
     * @param {string} escapedSuffix - è½¬ä¹‰åçš„åç¼€
     * @returns {string|null} æ‰¾åˆ°çš„ title å€¼ï¼Œå¦‚æœæœªæ‰¾åˆ°åˆ™è¿”å› null
     */
    function findTitleByRegexMatch(searchText, suffix, escapedSuffix) {
        const patterns = [
            new RegExp(`<a[\\s\\S]{0,${SEARCH_RANGES.TAG_CONTENT}}?href=["']([^"']*${escapedSuffix})["'][\\s\\S]{0,${SEARCH_RANGES.TAG_CONTENT}}?title=(["'])([\\s\\S]*?)\\2`, 'i'),
            new RegExp(`<a[\\s\\S]{0,${SEARCH_RANGES.TAG_CONTENT}}?title=(["'])([\\s\\S]*?)\\1[\\s\\S]{0,${SEARCH_RANGES.TAG_CONTENT}}?href=["']([^"']*${escapedSuffix})["']`, 'i')
        ];
        
        for (const pattern of patterns) {
            let match;
            while ((match = pattern.exec(searchText)) !== null) {
                if (match && match.length >= 4) {
                    let hrefValue, titleValue;
                    if (pattern === patterns[0]) {
                        hrefValue = match[1];
                        titleValue = match[3];
                    } else {
                        titleValue = match[2];
                        hrefValue = match[3];
                    }
                    
                    if (hrefValue && titleValue && hrefValue.endsWith(suffix)) {
                        const unescapedTitle = unescapeTitleValue(titleValue);
                        const cleanedTitle = clean(unescapedTitle);
                        if (cleanedTitle) {
                            return cleanedTitle;
                        }
                    }
                }
            }
        }
        
        return null;
    }

    /**
     * ç­–ç•¥3ï¼šæ›´æ¿€è¿›çš„æœç´¢ - ç›´æ¥æœç´¢åŒ…å« suffix çš„æ–‡æœ¬ç‰‡æ®µ
     * @param {string} searchText - è¦æœç´¢çš„æ–‡æœ¬
     * @param {string} suffix - åç¼€
     * @returns {string|null} æ‰¾åˆ°çš„ title å€¼ï¼Œå¦‚æœæœªæ‰¾åˆ°åˆ™è¿”å› null
     */
    function findTitleBySuffixSearch(searchText, suffix) {
        let searchIndex = 0;
        
        while (true) {
            const suffixIndex = searchText.indexOf(suffix, searchIndex);
            if (suffixIndex === -1) {
                break;
            }
            searchIndex = suffixIndex + 1;
            
            // éªŒè¯ suffix åœ¨ href å±æ€§ä¸­
            const beforeSuffix = searchText.substring(
                Math.max(0, suffixIndex - SEARCH_RANGES.BEFORE_SUFFIX),
                suffixIndex
            );
            const hrefMatch = beforeSuffix.match(/href\s*=\s*["']/i);
            if (!hrefMatch) {
                continue;
            }
            
            // åœ¨ suffix å‰åå„2000å­—ç¬¦èŒƒå›´å†…æœç´¢
            const searchStart = Math.max(0, suffixIndex - SEARCH_RANGES.BEFORE_SUFFIX);
            const searchEnd = Math.min(
                searchText.length,
                suffixIndex + suffix.length + SEARCH_RANGES.AFTER_SUFFIX
            );
            const context = searchText.substring(searchStart, searchEnd);
            
            // åœ¨è¿™ä¸ªä¸Šä¸‹æ–‡ä¸­æŸ¥æ‰¾ <a> æ ‡ç­¾å’Œ title
            const aTagMatch = context.match(/<a[\s\S]{0,3000}?>/i);
            if (aTagMatch) {
                const aTagStartInContext = context.indexOf(aTagMatch[0]);
                const aTagEnd = searchStart + aTagStartInContext + aTagMatch[0].length;
                // åœ¨ <a> æ ‡ç­¾åæŸ¥æ‰¾ title
                const afterTag = searchText.substring(
                    aTagEnd,
                    Math.min(searchText.length, aTagEnd + SEARCH_RANGES.AFTER_TAG)
                );
                const titleMatch = afterTag.match(/title\s*=\s*(["'])((?:(?!\1)[\s\S])*?)\1/i);
                if (titleMatch && titleMatch[2]) {
                    const unescapedTitle = unescapeTitleValue(titleMatch[2]);
                    const cleanedTitle = clean(unescapedTitle);
                    if (cleanedTitle) {
                        return cleanedTitle;
                    }
                }
            }
        }
        
        return null;
    }

    /**
     * ç­–ç•¥4ï¼šDOM è§£æå›é€€æ–¹æ¡ˆ
     * @param {string} decodedHtml - è§£ç åçš„ HTML
     * @param {string} suffix - åç¼€
     * @returns {string|null} æ‰¾åˆ°çš„ title å€¼ï¼Œå¦‚æœæœªæ‰¾åˆ°åˆ™è¿”å› null
     */
    function findTitleByDomParsing(decodedHtml, suffix) {
        try {
            const doc = new DOMParser().parseFromString(decodedHtml, 'text/html');
            const links = Array.from(doc.querySelectorAll('a[href]'));
            
            for (const link of links) {
                const href = link.getAttribute('href') || '';
                if (href && href.endsWith(suffix) && link.hasAttribute('title')) {
                    const title = clean(link.getAttribute('title'));
                    if (title) {
                        return title;
                    }
                }
            }
        } catch (error) {
            // DOM è§£æå¤±è´¥ï¼Œé™é»˜è¿”å› null
        }
        
        return null;
    }

    /**
     * æ ¹æ®"_èˆªçº¿ID_æ¸¯å£ID"åç¼€ç²¾å‡†å®šä½ <a ... title="...">
     * è¦æ±‚ï¼šhref å¿…é¡»ä»¥ "_èˆªçº¿ID_æ¸¯å£ID" ç»“å°¾ï¼ˆå¯èƒ½å‰é¢æœ‰ #1_ ç­‰å‰ç¼€ï¼‰
     * @param {string} decodedHtml - è§£ç åçš„ HTML
     * @param {string} fleetId - èˆªçº¿ID
     * @param {string} fleetIdPort - æ¸¯å£ID
     * @param {string} originalHtml - åŸå§‹ HTMLï¼ˆå¯é€‰ï¼‰
     * @returns {string} æ‰¾åˆ°çš„å…±èˆ±èˆ¹å…¬å¸æ ‡é¢˜ï¼Œå¦‚æœæœªæ‰¾åˆ°åˆ™è¿”å›ç©ºå­—ç¬¦ä¸²
     */
    function findCosTitle(decodedHtml, fleetId, fleetIdPort, originalHtml) {
        const suffix = `_${fleetId}_${fleetIdPort}`;
        const escapedSuffix = suffix.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        
        // åœ¨å¤šä¸ªæ–‡æœ¬æºä¸­æœç´¢
        const searchTexts = [decodedHtml];
        if (originalHtml && originalHtml !== decodedHtml) {
            searchTexts.push(originalHtml);
        }
        
        // æŒ‰ä¼˜å…ˆçº§å°è¯•å„ç§ç­–ç•¥
        for (const searchText of searchTexts) {
            // ç­–ç•¥1ï¼šé€šè¿‡ href å®šä½
            const title1 = findTitleByHrefLocation(searchText, suffix, escapedSuffix);
            if (title1) return title1;
            
            // ç­–ç•¥2ï¼šæ­£åˆ™è¡¨è¾¾å¼ç›´æ¥åŒ¹é…
            const title2 = findTitleByRegexMatch(searchText, suffix, escapedSuffix);
            if (title2) return title2;
            
            // ç­–ç•¥3ï¼šæ¿€è¿›æœç´¢
            const title3 = findTitleBySuffixSearch(searchText, suffix);
            if (title3) return title3;
        }
        
        // ç­–ç•¥4ï¼šDOM è§£æï¼ˆåªåœ¨è§£ç åçš„HTMLä¸­å°è¯•ï¼‰
        const title4 = findTitleByDomParsing(decodedHtml, suffix);
        if (title4) return title4;
        
        return '';
    }

    /**
     * æŠŠ self.__next_f.push([1,"..."]) é‡Œçš„å­—ç¬¦ä¸²è§£ç æ‹¼æ¥ï¼Œå¾—åˆ°å¯è§£ææ–‡æœ¬
     * @param {string} html - åŸå§‹ HTML
     * @returns {string} è§£ç åçš„æ–‡æœ¬
     */
    function extractDecodedPayload(html) {
        let output = '';
        const pushPattern = /self\.__next_f\.push\(\[\d+\s*,\s*(["'])([\s\S]*?)\1\]\)/g;
        let match;
        
        while ((match = pushPattern.exec(html))) {
            try {
                // åˆ©ç”¨ JSON.parse è§£ç è½¬ä¹‰åºåˆ—
                const escapedString = match[2].replace(/\\"/g, '\\"');
                output += JSON.parse('"' + escapedString + '"');
            } catch (error) {
                // é€€åŒ–å¤„ç†å¸¸è§è½¬ä¹‰
                output += match[2]
                    .replace(/\\n/g, '\n')
                    .replace(/\\t/g, '\t')
                    .replace(/\\"/g, '"');
            }
            output += '\n';
        }
        
        // å¦‚æœæ²¡æŠ“åˆ° push ç‰‡æ®µï¼Œå°±ç›´æ¥ç”¨åŸ html
        return output || html;
    }

    /**
     * æ¸…ç† JSON å­—ç¬¦ä¸²ä¸­çš„æ— æ•ˆæ§åˆ¶å­—ç¬¦
     * åªæ¸…ç†å­—ç¬¦ä¸²å€¼ä¸­çš„æ§åˆ¶å­—ç¬¦ï¼Œä¸å½±å“ JSON ç»“æ„
     * @param {string} jsonString - åŸå§‹ JSON å­—ç¬¦ä¸²
     * @returns {string} æ¸…ç†åçš„ JSON å­—ç¬¦ä¸²
     */
    function sanitizeJsonString(jsonString) {
        // åŒ¹é…å­—ç¬¦ä¸²å€¼ï¼ˆåœ¨å¼•å·å†…çš„å†…å®¹ï¼‰ï¼ŒåŒ…æ‹¬è½¬ä¹‰åºåˆ—
        return jsonString.replace(/"([^"\\]|\\.)*"/g, (match) => {
            // æå–å­—ç¬¦ä¸²å†…å®¹ï¼ˆå»æ‰å¼•å·ï¼‰
            let content = match.slice(1, -1);
            let result = '';
            let i = 0;
            
            while (i < content.length) {
                const char = content[i];
                const code = char.charCodeAt(0);
                
                // å¦‚æœæ˜¯è½¬ä¹‰åºåˆ—ï¼Œä¿ç•™åŸæ ·
                if (char === '\\' && i + 1 < content.length) {
                    result += char + content[i + 1];
                    i += 2;
                    continue;
                }
                
                // å¦‚æœæ˜¯æ§åˆ¶å­—ç¬¦ï¼ˆ0x00-0x1Fï¼‰ï¼Œè½¬ä¹‰å®ƒ
                if (code >= 0x00 && code <= 0x1F) {
                    // å¸¸è§å­—ç¬¦ä½¿ç”¨ç®€å†™å½¢å¼
                    if (code === 0x0A) { // \n
                        result += '\\n';
                    } else if (code === 0x0D) { // \r
                        result += '\\r';
                    } else if (code === 0x09) { // \t
                        result += '\\t';
                    } else {
                        // å…¶ä»–æ§åˆ¶å­—ç¬¦ä½¿ç”¨ Unicode è½¬ä¹‰
                        result += '\\u' + ('0000' + code.toString(16)).slice(-4);
                    }
                } else {
                    result += char;
                }
                i++;
            }
            
            return '"' + result + '"';
        });
    }

    /**
     * æ„å»º label -> å¯¹è±¡/æ•°ç»„ çš„ç´¢å¼•ï¼ˆå…¨é¡µï¼‰
     * @param {string} html - HTML æ–‡æœ¬
     * @returns {Object} åŒ…å« objects å’Œ arrays ä¸¤ä¸ª Map çš„å¯¹è±¡
     */
    function buildLabelIndex(html) {
        const objects = new Map();
        const arrays = new Map();
        const objRe = /([A-Za-z0-9_]+)\s*:\s*\{([\s\S]*?)\}\s*(?=\n|\r|\]|,|<|$)/g;
        let objMatch;
        while ((objMatch = objRe.exec(html))) {
            const label = objMatch[1];
            let raw = '{' + objMatch[2].replace(/,\s*\}/g, '}') + '}';
            
            try {
                // å…ˆå°è¯•ç›´æ¥è§£æ
                const parsedObject = JSON.parse(raw);
                objects.set(label, parsedObject);
            } catch (error) {
                // å¦‚æœå¤±è´¥ï¼Œå°è¯•æ¸…ç†æ§åˆ¶å­—ç¬¦åå†è§£æ
                try {
                    raw = sanitizeJsonString(raw);
                    const parsedObject = JSON.parse(raw);
                    objects.set(label, parsedObject);
                } catch (secondError) {
                    // å¦‚æœä»ç„¶å¤±è´¥ï¼Œé™é»˜è·³è¿‡ï¼ˆè¿™äº›å¯èƒ½æ˜¯éå…³é”®æ•°æ®ï¼‰
                    // ä¸è¾“å‡ºé”™è¯¯ä¿¡æ¯ï¼Œé¿å…æ§åˆ¶å°è¢«å¤§é‡é”™è¯¯ä¿¡æ¯æ·¹æ²¡
                    // è¿™äº›å¤±è´¥çš„è§£æé€šå¸¸ä¸å½±å“æœ€ç»ˆç»“æœ
                }
            }
        }
        
        const arrRe = /([A-Za-z0-9_]+)\s*:\s*\[([\s\S]*?)\]\s*(?=\n|\r|\}|,|<|$)/g;
        let arrMatch;
        while ((arrMatch = arrRe.exec(html))) {
            const label = arrMatch[1];
            const body = arrMatch[2];
            const items = [];
            const itemRe = /"\$?([A-Za-z0-9_]+)"/g;
            let itemMatch;
            while ((itemMatch = itemRe.exec(body))) {
                items.push(itemMatch[1]);
            }
            arrays.set(label, items);
        }
        return {objects, arrays};
    }

    /**
     * è§£å¼•ç”¨ notices/scheduleNotices/scheduleNoticeShare -> èˆ¹æœŸå¯¹è±¡æ•°ç»„
     * @param {Object} labelIndex - æ ‡ç­¾ç´¢å¼•å¯¹è±¡
     * @param {string} label - æ ‡ç­¾å
     * @returns {Array} èˆ¹æœŸå¯¹è±¡æ•°ç»„
     */
    function derefList(labelIndex, label) {
        if (!label) return [];
        const key = String(label).replace(/^\$/, '');
        const labelArray = labelIndex.arrays.get(key) || [];
        const out = [];
        for (const labelItem of labelArray) {
            const vesselObject = labelIndex.objects.get(labelItem);
            if (vesselObject && (vesselObject.vslName || vesselObject.voyNo)) {
                out.push(vesselObject);
            }
        }
        return out;
    }

    /**
     * ä»æ•´é¡µæå–"fleetå— + å¯¹åº”èˆ¹æœŸ"å¯¹
     * @param {string} html - HTML æ–‡æœ¬
     * @param {Object} labelIndex - æ ‡ç­¾ç´¢å¼•å¯¹è±¡
     * @returns {Array} fleet å¯¹è±¡æ•°ç»„
     */
    function extractFleetAndVessels(html, labelIndex) {
        const fleets = [];
        // æ”¹è¿›æ­£åˆ™ï¼šå…è®¸å­—æ®µé¡ºåºä»»æ„ï¼Œæ”¯æŒåµŒå¥—å¯¹è±¡
        const fleetPattern = /\{[^}]*?"fleetId"\s*:\s*(\d+)[\s\S]*?"fleetIdPort"\s*:\s*(\d+)[\s\S]*?\}/g;
        let fleetMatch;
        
        while ((fleetMatch = fleetPattern.exec(html))) {
            const segment = fleetMatch[0];
            const fleetId = fleetMatch[1];
            // æ¸¯å£IDï¼šä¼˜å…ˆä» fleetIdPortï¼Œå¦‚æœå¤±è´¥åˆ™å°è¯•ä»å…¶ä»–ä½ç½®
            let fleetIdPort = fleetMatch[2];
            // å¦‚æœ fleetIdPort ä¸ºç©ºæˆ–æ— æ•ˆï¼Œå°è¯•ä»æ•´ä¸ªç‰‡æ®µä¸­æŸ¥æ‰¾
            if (!fleetIdPort || fleetIdPort === '0') {
                const portIdAlt = /"fleetIdPort"\s*:\s*(\d+)/.exec(segment);
                if (portIdAlt && portIdAlt[1] && portIdAlt[1] !== '0') {
                    fleetIdPort = portIdAlt[1];
                }
            }
            
            const carrierMatch = /("carrierShortName"\s*:\s*"([^"]*)")/.exec(segment);
            const carrierShortName = carrierMatch ? carrierMatch[2] : '';
            const svcCodeMatch = /("svcCode"\s*:\s*"([^"]*)")/.exec(segment);
            const svcCode = svcCodeMatch ? svcCodeMatch[2] : '';
            
            // å¼€èˆªæ—¥ï¼šå°è¯•å¤šä¸ªå­—æ®µ
            let weekday = (/("weekdayOfETDFormatter"\s*:\s*"([^"]*)")/.exec(segment) || [])[2] || '';
            if (!weekday) {
                weekday = (/("weekday"\s*:\s*"([^"]*)")/.exec(segment) || [])[2] || '';
            }
            if (!weekday) {
                weekday = (/("etdWeekday"\s*:\s*"([^"]*)")/.exec(segment) || [])[2] || '';
            }
            
            // èˆªç¨‹ï¼šå°è¯•å¤šä¸ªå­—æ®µå’Œæ ¼å¼
            let shipdays = (/("shipdays"\s*:\s*(\d+))/.exec(segment) || [])[2] || '';
            if (!shipdays) {
                shipdays = (/("shipDays"\s*:\s*(\d+))/.exec(segment) || [])[2] || '';
            }
            if (!shipdays) {
                shipdays = (/("duration"\s*:\s*(\d+))/.exec(segment) || [])[2] || '';
            }
            // å°è¯•å­—ç¬¦ä¸²æ ¼å¼
            if (!shipdays) {
                const shipdaysStr = (/("shipdays"\s*:\s*"(\d+)")/.exec(segment) || [])[2] || '';
                if (shipdaysStr) shipdays = shipdaysStr;
            }
            
            // å¯è¿æ¸¯ç å¤´ï¼šå°è¯•å¤šä¸ªå­—æ®µï¼Œä¼˜å…ˆé¡ºåº
            let polWharf = (/("wharfName"\s*:\s*"([^"]*)")/.exec(segment) || [])[2] || '';
            if (!polWharf) {
                polWharf = (/("startPortWharfEnShortName"\s*:\s*"([^"]*)")/.exec(segment) || [])[2] || '';
            }
            if (!polWharf) {
                polWharf = (/("startPortWharfEnFullName"\s*:\s*"([^"]*)")/.exec(segment) || [])[2] || '';
            }
            if (!polWharf) {
                polWharf = (/("polWharf"\s*:\s*"([^"]*)")/.exec(segment) || [])[2] || '';
            }
            if (!polWharf) {
                polWharf = (/("startPortTerminal"\s*:\s*"([^"]*)")/.exec(segment) || [])[2] || '';
            }
            
            // ç›®çš„æ¸¯ç å¤´ï¼šåŒæ—¶æå–ç¼©å†™å’Œå…¨ç§°
            let podShort = (/("destPortWharfEnShortName"\s*:\s*"([^"]*)")/.exec(segment) || [])[2] || '';
            let podFull = (/("destPortWharfEnFullName"\s*:\s*"([^"]*)")/.exec(segment) || [])[2] || '';
            // å¦‚æœåªæœ‰å…¶ä¸­ä¸€ä¸ªï¼Œå°è¯•å…¶ä»–å­—æ®µ
            if (!podShort && !podFull) {
                podShort = (/("podWharf"\s*:\s*"([^"]*)")/.exec(segment) || [])[2] || '';
            }
            if (!podShort && !podFull) {
                podFull = (/("destPortTerminal"\s*:\s*"([^"]*)")/.exec(segment) || [])[2] || '';
            }
            
            // åº”ç”¨ç å¤´åè§„èŒƒåŒ–
            polWharf = normalizeWharfTokens(polWharf);
            podShort = normalizeWharfTokens(podShort);
            podFull = normalizeWharfTokens(podFull);
            
            const startPortEnMatch = /("startPortEnName"\s*:\s*"([^"]*)")/.exec(segment);
            const startPortCnMatch = /("startPortCnName"\s*:\s*"([^"]*)")/.exec(segment);
            const destPortEnMatch = /("destPortEnName"\s*:\s*"([^"]*)")/.exec(segment);
            const destPortCnMatch = /("destPortCnName"\s*:\s*"([^"]*)")/.exec(segment);
            const scheduleNoticesMatch = /("scheduleNotices"\s*:\s*"\$?([A-Za-z0-9_]+)")/.exec(segment);
            const label1 = scheduleNoticesMatch ? scheduleNoticesMatch[2] : '';
            const noticesMatch = /("notices"\s*:\s*"\$?([A-Za-z0-9_]+)")/.exec(segment);
            const label2 = noticesMatch ? noticesMatch[2] : '';
            const scheduleNoticeShareMatch = /("scheduleNoticeShare"\s*:\s*"\$?([A-Za-z0-9_]+)")/.exec(segment);
            const label3 = scheduleNoticeShareMatch ? scheduleNoticeShareMatch[2] : '';

            let vessels = [];
            vessels = derefList(labelIndex, label1);
            if (!vessels.length) vessels = derefList(labelIndex, label2);
            if (!vessels.length) vessels = derefList(labelIndex, label3);

            const origin = startPortEnMatch && startPortCnMatch
                ? `${startPortEnMatch[2]}(${startPortCnMatch[2]})`
                : '';
            const dest = destPortEnMatch && destPortCnMatch
                ? `${destPortEnMatch[2]}(${destPortCnMatch[2]})`
                : '';
            fleets.push({
                fleetId,
                fleetIdPort,
                carrierShortName,
                svcCode,
                weekday,
                shipdays,
                polWharf,
                podShort,
                podFull,
                origin,
                dest,
                vessels
            });
        }
        return fleets;
    }

    /**
     * æå–å¯è¿æ¸¯å’Œç›®çš„æ¸¯
     * ä¼˜å…ˆï¼šåœ¨ä»»æ„å¯¹è±¡ç‰‡æ®µä¸­æŸ¥æ‰¾ start/dest å››ä¸ªå­—æ®µï¼ˆé€‚é… fc:{...} ç»“æ„ï¼‰
     * æ¬¡çº§ï¼šDOM ä¸Šæ–¹æç¤ºæ¡
     * å…œåº•ï¼šæ­£åˆ™åŒ¹é…"ç”±...å‘å¾€..."
     * @param {string} html - HTML æ–‡æœ¬
     * @returns {Object} åŒ…å« origin å’Œ dest çš„å¯¹è±¡
     */
    function extractOriginDest(html) {
        const jsonMatch = html.match(/"startPortEnName"\s*:\s*"([^"]+)"[\s\S]*?"startPortCnName"\s*:\s*"([^"]+)"[\s\S]*?"destPortEnName"\s*:\s*"([^"]+)"[\s\S]*?"destPortCnName"\s*:\s*"([^"]+)"/);
        if (jsonMatch) {
            const origin = `${jsonMatch[1]}(${jsonMatch[2]})`;
            const dest = `${jsonMatch[3]}(${jsonMatch[4]})`;
            return { origin, dest };
        }
        try {
            const doc = new DOMParser().parseFromString(html, 'text/html');
            const bar = doc.querySelector('span.flex.items-center.text-\\[12px\\]');
            if (bar) {
                const strongs = Array.from(bar.querySelectorAll('span.font-bold'));
                const originText = strongs[0] ? (strongs[0].textContent || '').trim() : '';
                const destText = strongs[1] ? (strongs[1].textContent || '').trim() : '';
                if (originText && destText) {
                    return { origin: originText, dest: destText };
                }
            }
        } catch (error) {
            // DOM è§£æå¤±è´¥ï¼Œç»§ç»­å°è¯•å…¶ä»–æ–¹æ³•
        }
        const textMatchPattern = new RegExp(
            '>\\s*([A-Z][A-Z\\s]+)<!-- -->\\(<!-- -->([\\u4e00-\\u9fa5]+)<!-- -->\\)</span>å‘å¾€</span[^>]*>\\s*([A-Z][A-Z\\s]+)<!-- -->\\(<!-- -->([\\u4e00-\\u9fa5]+)<!-- -->\\)\\s*</span>'
        );
        const textMatch = html.match(textMatchPattern);
        if (textMatch) {
            return {
                origin: `${textMatch[1].trim()}(${textMatch[2]})`,
                dest: `${textMatch[3].trim()}(${textMatch[4]})`
            };
        }
        return { origin: '', dest: '' };
    }

    /**
     * ä»å­—ç¬¦ä¸²ä¸­æå–æ—¥æœŸéƒ¨åˆ†ï¼ˆYYYY/MM/DD æ ¼å¼ï¼‰
     * @param {string} dateString - åŒ…å«æ—¥æœŸçš„å­—ç¬¦ä¸²
     * @returns {string} æå–çš„æ—¥æœŸå­—ç¬¦ä¸²ï¼Œå¦‚æœæœªæ‰¾åˆ°åˆ™è¿”å›ç©ºå­—ç¬¦ä¸²
     */
    function datePart(dateString) {
        if (!dateString) return '';
        const dateMatch = String(dateString).match(/(\d{4}\/\d{2}\/\d{2})/);
        return dateMatch ? dateMatch[1] : '';
    }

    /**
     * ä»å¯¹è±¡ä¸­æå–èˆ¹åï¼ˆå°è¯•å¤šä¸ªå­—æ®µåï¼‰
     * @param {Object} obj - å¯¹è±¡
     * @returns {string} èˆ¹å
     */
    function extractVesselName(obj) {
        if (!obj) return '';
        return obj.vslName 
            || obj.vesselName 
            || obj.vslNameEn 
            || obj.vesselNameEn
            || obj.shipName
            || obj.name
            || '';
    }

    /**
     * ä»å¯¹è±¡ä¸­æå–èˆªæ¬¡ï¼ˆå°è¯•å¤šä¸ªå­—æ®µåï¼‰
     * @param {Object} obj - å¯¹è±¡
     * @returns {string} èˆªæ¬¡
     */
    function extractVoyage(obj) {
        if (!obj) return '';
        return obj.voyNo 
            || obj.voyageNo 
            || obj.voyNoEn
            || obj.voyage
            || obj.voy
            || '';
    }

    /**
     * ä»å¯¹è±¡ä¸­æå–è®¡åˆ’å¼€èˆªæ—¥æœŸï¼ˆå°è¯•å¤šä¸ªå­—æ®µåå’Œæ ¼å¼ï¼‰
     * @param {Object} obj - å¯¹è±¡
     * @returns {string} è®¡åˆ’å¼€èˆªæ—¥æœŸï¼ˆYYYY/MM/DDæ ¼å¼ï¼‰
     */
    function extractPlanDate(obj) {
        if (!obj) return '';
        // å°è¯•å¤šä¸ªå­—æ®µå
        const dateStr = obj.etdFormatter 
            || obj.portSailingDateFormatter
            || obj.etd
            || obj.sailingDate
            || obj.portSailingDate
            || obj.etdDate
            || obj.planDate
            || obj.planEtd
            || '';
        return datePart(dateStr);
    }

    /**
     * ä»å¯¹è±¡ä¸­æå–é¢„è®¡åˆ°æ¸¯æ—¥æœŸï¼ˆå°è¯•å¤šä¸ªå­—æ®µåå’Œæ ¼å¼ï¼‰
     * @param {Object} obj - å¯¹è±¡
     * @returns {string} é¢„è®¡åˆ°æ¸¯æ—¥æœŸï¼ˆYYYY/MM/DDæ ¼å¼ï¼‰
     */
    function extractEtaDate(obj) {
        if (!obj) return '';
        // å°è¯•å¤šä¸ªå­—æ®µå
        const dateStr = obj.etaFormatter 
            || obj.eta
            || obj.etaDate
            || obj.estimatedArrivalDate
            || obj.arrivalDate
            || '';
        return datePart(dateStr);
    }

    /**
     * ä»HTMLæ–‡æœ¬ä¸­è¡¥å……ç¼ºå¤±çš„èˆ¹åã€èˆªæ¬¡ã€æ—¥æœŸç­‰ä¿¡æ¯ï¼ˆä¼˜åŒ–ç‰ˆæœ¬ï¼‰
     * @param {string} decodedHtml - è§£ç åçš„HTMLæ–‡æœ¬
     * @param {string} lineId - èˆªçº¿ID
     * @param {string} portId - æ¸¯å£ID
     * @param {Object} missingData - ç¼ºå¤±çš„æ•°æ®å¯¹è±¡ {vesselName, voyage, plan, eta, weekday, shipdays, podWharf}
     * @returns {Object} è¡¥å……åçš„æ•°æ®å¯¹è±¡
     */
    function supplementMissingData(decodedHtml, lineId, portId, missingData) {
        const result = {...missingData};
        
        // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰å…³é”®æ•°æ®éƒ½å·²å­˜åœ¨ï¼ˆå…è®¸éƒ¨åˆ†å­—æ®µä¸ºç©ºï¼‰
        const hasAllCritical = result.vesselName && result.voyage && result.plan && result.eta;
        if (hasAllCritical && result.weekday && result.shipdays && result.podWharf) {
            return result;
        }

        // ä¼˜åŒ–ï¼šåªåœ¨éœ€è¦æ—¶æ‰æœç´¢ï¼Œå‡å°‘æœç´¢èŒƒå›´
        // å°è¯•ä»åŒ…å«èˆªçº¿IDå’Œæ¸¯å£IDçš„ä¸Šä¸‹æ–‡ä¸­æå–ï¼ˆç¼©å°æœç´¢èŒƒå›´ï¼‰
        const contextPattern = new RegExp(
            `"fleetId"\\s*:\\s*${lineId}[\\s\\S]{0,3000}"fleetIdPort"\\s*:\\s*${portId}[\\s\\S]{0,5000}`,
            'i'
        );
        const contextMatch = decodedHtml.match(contextPattern);
        if (contextMatch) {
            const context = contextMatch[0];
            
            // ä¸€æ¬¡æ€§åŒ¹é…æ‰€æœ‰éœ€è¦çš„å­—æ®µï¼Œå‡å°‘å¾ªç¯æ¬¡æ•°
            if (!result.vesselName) {
                const match = context.match(/"vslName"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"vesselName"\s*:\s*"([^"]+)"/i);
                if (match && match[1]) {
                    result.vesselName = clean(match[1]);
                }
            }
            
            if (!result.voyage) {
                const match = context.match(/"voyNo"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"voyageNo"\s*:\s*"([^"]+)"/i);
                if (match && match[1]) {
                    result.voyage = clean(match[1]);
                }
            }
            
            if (!result.plan) {
                const match = context.match(/"etdFormatter"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"portSailingDateFormatter"\s*:\s*"([^"]+)"/i);
                if (match && match[1]) {
                    result.plan = datePart(match[1]);
                }
            }
            
            if (!result.eta) {
                const match = context.match(/"etaFormatter"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"eta"\s*:\s*"([^"]+)"/i);
                if (match && match[1]) {
                    result.eta = datePart(match[1]);
                }
            }
            
            // è¡¥å……å¼€èˆªæ—¥ï¼ˆweekdayï¼‰
            if (!result.weekday) {
                const match = context.match(/"weekdayOfETDFormatter"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"weekday"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"etdWeekday"\s*:\s*"([^"]+)"/i);
                if (match && match[1]) {
                    result.weekday = clean(match[1]);
                }
            }
            
            // è¡¥å……èˆªç¨‹ï¼ˆshipdaysï¼‰
            if (!result.shipdays) {
                const match = context.match(/"shipdays"\s*:\s*(\d+)/i) ||
                             context.match(/"shipDays"\s*:\s*(\d+)/i) ||
                             context.match(/"duration"\s*:\s*(\d+)/i) ||
                             context.match(/"shipdays"\s*:\s*"(\d+)"/i);
                if (match && match[1]) {
                    result.shipdays = clean(match[1]);
                }
            }
            
            // è¡¥å……ç›®çš„æ¸¯ç å¤´ï¼ˆpodWharfï¼‰
            if (!result.podWharf) {
                // å°è¯•æå–ç›®çš„æ¸¯ç å¤´çš„ç¼©å†™å’Œå…¨ç§°
                const podShortMatch = context.match(/"destPortWharfEnShortName"\s*:\s*"([^"]+)"/i);
                const podFullMatch = context.match(/"destPortWharfEnFullName"\s*:\s*"([^"]+)"/i);
                let podShort = podShortMatch ? clean(podShortMatch[1]) : '';
                let podFull = podFullMatch ? clean(podFullMatch[1]) : '';
                
                // å¦‚æœéƒ½æ²¡æœ‰ï¼Œå°è¯•å…¶ä»–å­—æ®µ
                if (!podShort && !podFull) {
                    const podMatch = context.match(/"podWharf"\s*:\s*"([^"]+)"/i) ||
                                   context.match(/"destPortTerminal"\s*:\s*"([^"]+)"/i);
                    if (podMatch && podMatch[1]) {
                        podShort = clean(podMatch[1]);
                    }
                }
                
                // è§„èŒƒåŒ–å¹¶ç»„åˆ
                podShort = normalizeWharfTokens(podShort);
                podFull = normalizeWharfTokens(podFull);
                
                if (podShort && podFull) {
                    result.podWharf = `${podShort}/${podFull}`;
                } else if (podShort) {
                    result.podWharf = podShort;
                } else if (podFull) {
                    result.podWharf = podFull;
                }
            }
        }
        
        // å¦‚æœä»ç„¶ç¼ºå¤±ï¼Œåªåœ¨å¿…è¦æ—¶è¿›è¡Œå…¨å±€æœç´¢ï¼ˆé™åˆ¶æœç´¢æ¬¡æ•°ï¼‰
        if ((!result.vesselName || !result.voyage || !result.plan || !result.eta) && decodedHtml) {
            // ä¼˜åŒ–ï¼šåªæœç´¢å‰5ä¸ªåŒ¹é…çš„å¯¹è±¡ï¼Œé¿å…éå†æ•´ä¸ªHTML
            const vesselObjPattern = /\{[^{}]*?"(?:vslName|vesselName)"\s*:\s*"[^"]+"[\s\S]{0,2000}?"(?:voyNo|voyageNo)"\s*:\s*"[^"]+"[\s\S]*?\}/g;
            let count = 0;
            let vesselObjMatch;
            while ((vesselObjMatch = vesselObjPattern.exec(decodedHtml)) !== null && count < 5) {
                count++;
                try {
                    const objText = vesselObjMatch[0].replace(/,\s*\}/g, '}');
                    const vesselObj = JSON.parse(objText);
                    
                    if (!result.vesselName) {
                        const name = extractVesselName(vesselObj);
                        if (name) result.vesselName = clean(name);
                    }
                    if (!result.voyage) {
                        const voy = extractVoyage(vesselObj);
                        if (voy) result.voyage = clean(voy);
                    }
                    if (!result.plan) {
                        const plan = extractPlanDate(vesselObj);
                        if (plan) result.plan = plan;
                    }
                    if (!result.eta) {
                        const eta = extractEtaDate(vesselObj);
                        if (eta) result.eta = eta;
                    }
                    if (!result.weekday) {
                        const weekday = vesselObj.weekdayOfETDFormatter || vesselObj.weekday || vesselObj.etdWeekday || '';
                        if (weekday) result.weekday = clean(weekday);
                    }
                    if (!result.shipdays) {
                        const shipdays = vesselObj.shipdays || vesselObj.shipDays || vesselObj.duration || '';
                        if (shipdays) {
                            const numMatch = String(shipdays).match(/(\d+)/);
                            if (numMatch) result.shipdays = clean(numMatch[1]);
                        }
                    }
                    if (!result.podWharf) {
                        const podShort = normalizeWharfTokens(vesselObj.destPortWharfEnShortName || '');
                        const podFull = normalizeWharfTokens(vesselObj.destPortWharfEnFullName || '');
                        if (podShort && podFull) {
                            result.podWharf = `${podShort}/${podFull}`;
                        } else if (podShort) {
                            result.podWharf = podShort;
                        } else if (podFull) {
                            result.podWharf = podFull;
                        }
                    }
                    
                    // å¦‚æœæ‰€æœ‰å…³é”®æ•°æ®éƒ½å·²è¡¥å……ï¼Œæå‰é€€å‡º
                    if (result.vesselName && result.voyage && result.plan && result.eta && 
                        result.weekday && result.shipdays && result.podWharf) {
                        break;
                    }
                } catch (error) {
                    continue;
                }
            }
        }
        
        return result;
    }

    function parseFile(name, html){
        const decoded = extractDecodedPayload(html);
        // æˆªæ–­ï¼šå‡ºç°"ä¸­è½¬"æˆ–"æ¥äºŒç¨‹"åé¢çš„å†…å®¹å¿½ç•¥
        const cutMarkers = [
            'text-[14px] font-bold">ä¸­è½¬',
            'lineTypeShowName":"æ¥äºŒç¨‹"'
        ];
        let cutPos = -1;
        for (const marker of cutMarkers) {
            const markerPos = decoded.indexOf(marker);
            if (markerPos >= 0 && (cutPos === -1 || markerPos < cutPos)) {
                cutPos = markerPos;
            }
        }
        const mainText = cutPos>0 ? decoded.slice(0, cutPos) : decoded;

        const labelIndex = buildLabelIndex(mainText);
        const fleets = extractFleetAndVessels(mainText, labelIndex);
        const odTop = extractOriginDest(decoded);

        const rows = [];
        for (const fleet of fleets) {
            const lineId = fleet.fleetId;
            // æ¸¯å£IDï¼šä¼˜å…ˆä½¿ç”¨ fleet ä¸­çš„ï¼Œå¦‚æœæ— æ•ˆåˆ™å°è¯•ä» vessel ä¸­æå–
            let portId = fleet.fleetIdPort;
            if (!portId || portId === '0' || portId === '') {
                // å°è¯•ä» vessel å¯¹è±¡ä¸­æå–
                for (const vessel of fleet.vessels) {
                    if (vessel.fleetIdPort && vessel.fleetIdPort !== '0') {
                        portId = vessel.fleetIdPort;
                        break;
                    }
                }
            }
            
            // å…±èˆ±èˆ¹å…¬å¸ï¼šåœ¨å®Œæ•´è§£ç æ–‡æœ¬å’ŒåŸå§‹HTMLä¸­æŸ¥æ‰¾ _lineId_portId å¯¹åº”çš„ <a> çš„ title
            let carriers = findCosTitle(decoded, lineId, portId, html);
            if (!carriers) {
                carriers = [
                    fleet.carrierShortName && fleet.svcCode
                        ? `${fleet.carrierShortName}(${fleet.svcCode})`
                        : fleet.carrierShortName
                ].filter(Boolean).join('');
            }
            
            // ç›®çš„æ¸¯ç å¤´ï¼šæ”¹è¿›ç»„åˆé€»è¾‘ï¼Œç¡®ä¿æ˜¾ç¤ºå®Œæ•´ä¿¡æ¯
            let podCombined = '';
            if (fleet.podShort && fleet.podFull) {
                // ä¸¤è€…éƒ½æœ‰ï¼Œç”¨ / åˆ†éš”
                podCombined = `${fleet.podShort}/${fleet.podFull}`;
            } else if (fleet.podShort) {
                // åªæœ‰ç¼©å†™
                podCombined = fleet.podShort;
            } else if (fleet.podFull) {
                // åªæœ‰å…¨ç§°
                podCombined = fleet.podFull;
            }
            
            const origin = fleet.origin || odTop.origin || '';
            const dest = fleet.dest || odTop.dest || '';
            
            // ä» fleet çº§åˆ«æå–çš„é»˜è®¤å€¼
            let defaultWeekday = fleet.weekday || '';
            let defaultShipdays = fleet.shipdays || '';
            let defaultPolWharf = fleet.polWharf || '';
            
            for (const vessel of fleet.vessels) {
                // ä½¿ç”¨å¢å¼ºçš„æå–å‡½æ•°ï¼Œå°è¯•å¤šä¸ªå­—æ®µå
                const vesselName = extractVesselName(vessel);
                const voyage = extractVoyage(vessel);
                const shipType = vessel.shipCapacity || '';
                const plan = extractPlanDate(vessel);
                const atd = datePart(vessel.atdFormatter || '');
                const eta = extractEtaDate(vessel);
                
                // æ³¨æ„ï¼šè¡¥å……æœºåˆ¶å»¶è¿Ÿåˆ°åˆå¹¶åç»Ÿä¸€å¤„ç†ï¼Œä»¥æé«˜æ€§èƒ½
                
                // å¼€èˆªæ—¥ï¼šä¼˜å…ˆä» vesselï¼Œå…¶æ¬¡ä» fleet
                let weekday = defaultWeekday;
                if (!weekday) {
                    weekday = vessel.weekdayOfETDFormatter || vessel.weekday || vessel.etdWeekday || '';
                }
                
                // èˆªç¨‹ï¼šä¼˜å…ˆä» vesselï¼Œå…¶æ¬¡ä» fleet
                let shipdays = defaultShipdays;
                if (!shipdays) {
                    shipdays = vessel.shipdays || vessel.shipDays || vessel.duration || '';
                }
                // å¦‚æœæ˜¯å­—ç¬¦ä¸²ï¼Œè½¬æ¢ä¸ºæ•°å­—
                if (shipdays && typeof shipdays === 'string') {
                    const numMatch = shipdays.match(/(\d+)/);
                    if (numMatch) shipdays = numMatch[1];
                }
                
                // èµ·è¿æ¸¯ç å¤´ï¼šä¼˜å…ˆä» vesselï¼Œå…¶æ¬¡ä» fleet
                let polWharf = defaultPolWharf;
                if (!polWharf) {
                    polWharf = vessel.wharfName
                        || vessel.startPortWharfEnShortName
                        || vessel.startPortWharfEnFullName
                        || vessel.polWharf
                        || '';
                    polWharf = normalizeWharfTokens(polWharf);
                }
                
                // ç›®çš„æ¸¯ç å¤´ï¼šå¦‚æœ vessel ä¸­æœ‰ï¼Œä¼˜å…ˆä½¿ç”¨
                let vesselPodCombined = podCombined;
                if (vessel.destPortWharfEnShortName || vessel.destPortWharfEnFullName) {
                    const vPodShort = normalizeWharfTokens(vessel.destPortWharfEnShortName || '');
                    const vPodFull = normalizeWharfTokens(vessel.destPortWharfEnFullName || '');
                    if (vPodShort && vPodFull) {
                        vesselPodCombined = `${vPodShort}/${vPodFull}`;
                    } else if (vPodShort) {
                        vesselPodCombined = vPodShort;
                    } else if (vPodFull) {
                        vesselPodCombined = vPodFull;
                    }
                }
                
                rows.push([
                    clean(origin),                      // å¯è¿æ¸¯
                    clean(dest),                        // ç›®çš„æ¸¯
                    clean(lineId),                      // èˆªçº¿ID
                    clean(portId),                      // æ¸¯å£ID
                    clean(weekday),                     // å¼€èˆªæ—¥
                    clean(shipdays),                    // èˆªç¨‹
                    clean(carriers),                    // å…±èˆ±èˆ¹å…¬å¸
                    clean(vesselName),                  // èˆ¹å
                    clean(voyage),                      // èˆªæ¬¡
                    clean(shipType),                    // èˆ¹å‹
                    clean(plan),                        // è®¡åˆ’å¼€èˆª
                    clean(atd),                         // å®é™…ç¦»æ¸¯
                    clean(eta),                         // é¢„è®¡åˆ°æ¸¯
                    clean(polWharf),                    // å¯è¿æ¸¯ç å¤´
                    clean(vesselPodCombined)            // ç›®çš„æ¸¯ç å¤´
                ]);
            }
        }
        // å…¨å±€å…œåº•ï¼šè‹¥ä»æ— èˆ¹æœŸï¼Œä»æ•´é¡µç›´æ¥æŠ“å–å« vslName çš„å¯¹è±¡
        if (rows.length === 0) {
            const vesselPattern = /\{[^{}]*?"(?:vslName|vesselName)"\s*:\s*"[^"]+"[\s\S]*?\}/g;
            let vesselMatch;
            while ((vesselMatch = vesselPattern.exec(mainText))) {
                const objText = vesselMatch[0].replace(/,\s*\}/g, '}');
                try {
                    const vessel = JSON.parse(objText);
                    const vesselName = extractVesselName(vessel);
                    const voyage = extractVoyage(vessel);
                    if (!vesselName && !voyage) continue;
                    const shipType = vessel.shipCapacity || '';
                    const plan = extractPlanDate(vessel);
                    const atd = datePart(vessel.atdFormatter || '');
                    const eta = extractEtaDate(vessel);
                    rows.push([
                        clean(odTop.origin || ''),
                        clean(odTop.dest || ''),
                        '', '', '', '', '',
                        clean(vesselName),
                        clean(voyage),
                        clean(shipType),
                        clean(plan),
                        clean(atd),
                        clean(eta),
                        '', ''
                    ]);
                } catch (error) {
                    console.warn('Failed to parse vessel object from fallback extraction:', error);
                }
            }
        }
        
        // æ³¨æ„ï¼šè¡¥å……æœºåˆ¶å»¶è¿Ÿåˆ°åˆå¹¶åç»Ÿä¸€å¤„ç†ï¼Œä»¥æé«˜æ€§èƒ½
        
        return rows;
    }

    /**
     * æ¸²æŸ“é¢„è§ˆè¡¨æ ¼ - ä½¿ç”¨ parser-utils.js ä¸­çš„å‡½æ•°
     * @param {Array<Array>} rows - è¡Œæ•°æ®æ•°ç»„
     */
    function renderPreviewLocal(rows) {
        const headers = [
            'å¯è¿æ¸¯', 'ç›®çš„æ¸¯', 'èˆªçº¿ID', 'æ¸¯å£ID', 'å¼€èˆªæ—¥', 'èˆªç¨‹', 'å…±èˆ±èˆ¹å…¬å¸',
            'èˆ¹å', 'èˆªæ¬¡', 'èˆ¹å‹', 'è®¡åˆ’å¼€èˆª', 'å®é™…ç¦»æ¸¯', 'é¢„è®¡åˆ°æ¸¯', 'å¯è¿æ¸¯ç å¤´', 'ç›®çš„æ¸¯ç å¤´'
        ];
        renderPreview(rows, '#preview', '#table', headers, 50);
    }

    const picker = selectElement('#picker');
    const runBtn = selectElement('#run');
    const downloadBtn = selectElement('#download');
    const summary = selectElement('#summary');
    const logBox = selectElement('#log');
    let files = [];
    let output = [];

    picker.addEventListener('change', () => {
        if (logBox) logBox.innerHTML = '';
        output = [];
        summary.textContent = '';
        files = Array.from(picker.files)
            .filter(file => /\.html?$/i.test(file.name))
            .sort((a, b) => a.name.localeCompare(b.name));
        if (!files.length) {
            log('æœªé€‰æ‹©åˆ° HTML æ–‡ä»¶ï¼Œè¯·é‡æ–°é€‰æ‹© view-sourceã€‚', '#b00020');
            runBtn.disabled = true;
            downloadBtn.disabled = true;
            return;
        }
        log(`å·²é€‰æ‹© ${files.length} ä¸ª HTML æ–‡ä»¶ã€‚`, '#0a7d33');
        runBtn.disabled = false;
        downloadBtn.disabled = true;
        const preview = selectElement('#preview');
        if (preview) preview.classList.add('hidden');
    });

    runBtn.addEventListener('click', async () => {
        runBtn.disabled = true;
        downloadBtn.disabled = true;
        output = [];
        const preview = selectElement('#preview');
        if (preview) preview.classList.add('hidden');
        const header = [
            'å¯è¿æ¸¯', 'ç›®çš„æ¸¯', 'èˆªçº¿ID', 'æ¸¯å£ID', 'å¼€èˆªæ—¥', 'èˆªç¨‹', 'å…±èˆ±èˆ¹å…¬å¸',
            'èˆ¹å', 'èˆªæ¬¡', 'èˆ¹å‹', 'è®¡åˆ’å¼€èˆª', 'å®é™…ç¦»æ¸¯', 'é¢„è®¡åˆ°æ¸¯', 'å¯è¿æ¸¯ç å¤´', 'ç›®çš„æ¸¯ç å¤´'
        ];
        const rows = [header];
        const htmlCache = new Map(); // ç¼“å­˜è§£ç åçš„HTMLå†…å®¹ï¼ˆkey: è¡Œç´¢å¼•, value: è§£ç åçš„HTMLï¼‰
        let ok = 0;
        let warn = 0;
        for (const file of files) {
            try {
                const html = await file.text();
                const parsedRows = parseFile(file.name, html);
                if (!parsedRows.length) {
                    warn++;
                    log(`[æ— èˆ¹æœŸ] ${file.name}`, '#b36b00');
                } else {
                    ok++;
                    log(`[OK] ${file.name} -> ${parsedRows.length} è¡Œ`, '#0a7d33');
                    // ç¼“å­˜è§£ç åçš„HTMLï¼Œé¿å…é‡å¤è§£ç 
                    const decodedHtml = extractDecodedPayload(html);
                    const startIndex = rows.length;
                    for (let j = 0; j < parsedRows.length; j++) {
                        const row = parsedRows[j];
                        if (row.length > 0 && row[0] !== 'å¯è¿æ¸¯') { // è·³è¿‡è¡¨å¤´
                            htmlCache.set(startIndex + j, decodedHtml); // å­˜å‚¨è§£ç åçš„HTML
                        }
                    }
                    rows.push(...parsedRows);
                }
            } catch (error) {
                warn++;
                const errorMessage = error && error.message ? error.message : error;
                log(`[å¤±è´¥] ${file.name}: ${errorMessage}`, '#b00020');
            }
        }
        // å»é‡åˆå¹¶ï¼šé”® = å¯è¿æ¸¯ + ç›®çš„æ¸¯ + èˆªçº¿ID + æ¸¯å£ID + èˆ¹å + èˆªæ¬¡ï¼›å…±èˆ±èˆ¹å…¬å¸åˆå¹¶å»é‡
        const deduplicationMap = new Map();
        const mergedHtmlCache = new Map(); // å­˜å‚¨åˆå¹¶åè®°å½•çš„HTMLå¼•ç”¨ï¼ˆkey: åˆå¹¶åçš„key, value: HTMLå†…å®¹ï¼‰
        for (let i = 1; i < rows.length; i++) {
            const [
                origin,
                dest,
                lineId,
                portId,
                weekday,
                shipdays,
                carriers,
                vesselName,
                voyage,
                shipType,
                plan,
                atd,
                eta,
                polWharf,
                podWharf
            ] = rows[i].map(clean);
            
            const key = [origin, dest, lineId, portId, vesselName, voyage].join('|');
            if (!deduplicationMap.has(key)) {
                deduplicationMap.set(key, [
                    origin,
                    dest,
                    lineId,
                    portId,
                    weekday,
                    shipdays,
                    carriers,
                    vesselName,
                    voyage,
                    shipType,
                    plan,
                    atd,
                    eta,
                    polWharf,
                    podWharf
                ]);
                // ä¿å­˜è§£ç åçš„HTMLå¼•ç”¨ï¼ˆå·²åœ¨è§£ææ—¶è§£ç ï¼‰
                if (htmlCache.has(i)) {
                    mergedHtmlCache.set(key, htmlCache.get(i));
                }
            } else {
                const existing = deduplicationMap.get(key);
                // åˆå¹¶å¼€èˆªæ—¥/èˆªç¨‹ï¼ˆä¿ç•™å·²æœ‰ï¼Œè‹¥ç©ºåˆ™è¡¥ï¼‰
                if (!existing[4] && weekday) existing[4] = weekday;
                if (!existing[5] && shipdays) existing[5] = shipdays;
                // å…±èˆ±ï¼šæŒ‰éœ€æ±‚ä½¿ç”¨ <a title> çš„æ–‡æœ¬ï¼Œä¸å†æ‹¼æ¥åˆå¹¶ï¼›ä¼˜å…ˆä¿ç•™å·²å­˜åœ¨çš„éç©ºå€¼
                if (!existing[6] && carriers) existing[6] = carriers;
                // è¡¥å……ç¼ºå¤±çš„å…³é”®å­—æ®µï¼šèˆ¹åã€èˆªæ¬¡ã€è®¡åˆ’å¼€èˆªã€é¢„è®¡åˆ°æ¸¯ã€ç›®çš„æ¸¯ç å¤´
                if (!existing[7] && vesselName) existing[7] = vesselName;
                if (!existing[8] && voyage) existing[8] = voyage;
                if (!existing[10] && plan) existing[10] = plan;
                if (!existing[12] && eta) existing[12] = eta;
                if (!existing[14] && podWharf) existing[14] = podWharf;
                // å…¶ä»–å­—æ®µä»¥é¦–æ¡ä¸ºå‡†ï¼Œå¦‚ATD/å¯è¿æ¸¯ç å¤´ä¸€èˆ¬ä¸€è‡´
                // å¦‚æœå½“å‰è¡Œæœ‰HTMLå¼•ç”¨ä½†å·²æœ‰è®°å½•æ²¡æœ‰ï¼Œåˆ™ä¿å­˜ï¼ˆä¼˜å…ˆä½¿ç”¨æœ‰æ›´å¤šæ•°æ®çš„è®°å½•ï¼‰
                if (htmlCache.has(i) && !mergedHtmlCache.has(key)) {
                    mergedHtmlCache.set(key, htmlCache.get(i));
                }
            }
        }
        const merged = [header, ...Array.from(deduplicationMap.values())];
        
        // åˆå¹¶åçš„è¡¥å……æœºåˆ¶ï¼šå¯¹ä»ç„¶ç¼ºå¤±çš„å­—æ®µè¿›è¡Œè¡¥å……ï¼ˆä¼˜åŒ–ï¼šæ‰¹é‡å¤„ç†ï¼Œå‡å°‘é‡å¤æœç´¢ï¼‰
        const needSupplement = [];
        for (let i = 1; i < merged.length; i++) {
            const row = merged[i];
            const [
                origin, dest, lineId, portId, weekday, shipdays, carriers,
                vesselName, voyage, shipType, plan, atd, eta, polWharf, podWharf
            ] = row;
            
            // æ£€æŸ¥æ˜¯å¦æœ‰ä»»ä½•å…³é”®å­—æ®µç¼ºå¤±
            const hasMissing = !vesselName || !voyage || !plan || !eta || 
                              !weekday || !shipdays || !podWharf;
            
            // åªå¯¹çœŸæ­£ç¼ºå¤±å…³é”®å­—æ®µçš„è¡Œè¿›è¡Œè¡¥å……
            if (hasMissing && lineId && portId) {
                const rowKey = [origin, dest, lineId, portId, vesselName, voyage].join('|');
                if (mergedHtmlCache.has(rowKey)) {
                    needSupplement.push({
                        row: row,
                        rowKey: rowKey,
                        lineId: lineId,
                        portId: portId,
                        missing: {
                            vesselName: !vesselName,
                            voyage: !voyage,
                            plan: !plan,
                            eta: !eta,
                            weekday: !weekday,
                            shipdays: !shipdays,
                            podWharf: !podWharf
                        }
                    });
                }
            }
        }
        
        // æ‰¹é‡è¡¥å……ï¼šä½¿ç”¨ç¼“å­˜çš„è§£ç HTMLï¼Œé¿å…é‡å¤è§£ç 
        if (needSupplement.length > 0) {
            log(`æ­£åœ¨è¡¥å…… ${needSupplement.length} æ¡ç¼ºå¤±æ•°æ®...`, '#0a7d33');
            for (const item of needSupplement) {
                const decodedHtml = mergedHtmlCache.get(item.rowKey);
                if (decodedHtml) {
                    const supplemented = supplementMissingData(decodedHtml, item.lineId, item.portId, {
                        vesselName: item.row[7] || '',
                        voyage: item.row[8] || '',
                        plan: item.row[10] || '',
                        eta: item.row[12] || '',
                        weekday: item.row[4] || '',
                        shipdays: item.row[5] || '',
                        podWharf: item.row[14] || ''
                    });
                    
                    // åªæ›´æ–°ç¼ºå¤±çš„å­—æ®µ
                    if (item.missing.vesselName && supplemented.vesselName) {
                        item.row[7] = clean(supplemented.vesselName);
                    }
                    if (item.missing.voyage && supplemented.voyage) {
                        item.row[8] = clean(supplemented.voyage);
                    }
                    if (item.missing.plan && supplemented.plan) {
                        item.row[10] = clean(supplemented.plan);
                    }
                    if (item.missing.eta && supplemented.eta) {
                        item.row[12] = clean(supplemented.eta);
                    }
                    if (item.missing.weekday && supplemented.weekday) {
                        item.row[4] = clean(supplemented.weekday);
                    }
                    if (item.missing.shipdays && supplemented.shipdays) {
                        item.row[5] = clean(supplemented.shipdays);
                    }
                    if (item.missing.podWharf && supplemented.podWharf) {
                        item.row[14] = clean(supplemented.podWharf);
                    }
                }
            }
        }
        output = merged;
        renderPreviewLocal(merged.slice(1));
        downloadBtn.disabled = merged.length <= 1;
        summary.textContent = `å®Œæˆï¼š${ok} æ–‡ä»¶ï¼Œ${warn} æé†’ï¼Œåˆå¹¶å ${merged.length - 1} æ¡ã€‚`;
    });

    downloadBtn.addEventListener('click', () => {
        if (!output || output.length <= 1) return;
        const csv = '\uFEFF' + rowsToCsv(output);
        downloadBlob(csv, generateTimestampFilename('weiyun-schedule'), 'text/csv;charset=utf-8');
    });
})();
</script>
    </div>
    <div class="page-footer">
        <h2>ç»´è¿ç½‘ èˆ¹æœŸè§£æå·¥å…·ä½¿ç”¨å£°æ˜</h2>
        <p>æœ¬å·¥å…·ç”¨äºè§£æä»ç»´è¿ç½‘ï¼ˆweiyun.comï¼‰ä¸‹è½½çš„èˆ¹æœŸç½‘é¡µï¼Œæå–èˆªçº¿ã€èˆ¹åã€èˆªæ¬¡ã€å¼€èˆ¹æ—¥æœŸç­‰æ•°æ®å¹¶å¯¼å‡ºä¸º CSV æ–‡ä»¶ã€‚</p>
        <p>æ‰€æœ‰æ•°æ®æ¥æºäºç»´è¿ç½‘å…¬å¼€ä¿¡æ¯ï¼Œè§£æç»“æœä»…ä¾›å†…éƒ¨ä½¿ç”¨ï¼Œè¯·éµå®ˆç»´è¿ç½‘çš„ä½¿ç”¨æ¡æ¬¾å’Œç‰ˆæƒè§„å®šã€‚</p>
    </div>
</body>
</html>

</html>
