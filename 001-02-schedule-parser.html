<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>维运网 船期解析工具</title>
    <link rel="stylesheet" href="vendor/theme-styles.css">
    <script src="vendor/auth-gist.js"></script>
</head>
<body data-page="001-02-schedule-parser.html">
    <div class="dashboard-container">
        <!-- 左侧导航栏占位容器（将由sidebar-loader.js动态加载） -->
        <div id="sidebar-placeholder"></div>

        <!-- 右侧内容 -->
        <main class="dashboard-content">
            <div class="container">
                <!-- 顶部介绍卡片，沿用 dashboard 风格 -->
                <div class="section-intro">
                    <div class="section-intro-header">
                        <div class="section-intro-content">
                            <h2>维运网 船期解析工具</h2>
                            <p>自动解析维运网船期网页，解析过程中请勿关闭页面，解析完成后会自动显示统计信息。</p>
                        </div>
                        <div class="section-intro-actions">
                            <a href="dashboard.html?tab=tools001" class="tool-link" aria-label="返回工具集首页">← 返回首页</a>
                            <a href="001-02-schedule-parser-README.html" class="tool-link secondary" aria-label="查看使用说明文档">使用说明 →</a>
                        </div>
                    </div>
                </div>

                <!-- 解析工具主区域 -->
                <div class="card-white mt-20">
                    <div class="controls">
                        <label class="file-btn" aria-label="选择包含HTML文件的文件夹">
                            选择 view-full 文件夹
                            <input id="picker" type="file" webkitdirectory multiple accept=".html,.htm" aria-label="选择文件夹">
                        </label>
                        <button id="run" class="btn btn-sweep-blue" disabled aria-label="开始解析HTML文件">开始解析</button>
                        <button id="download" class="btn btn-sweep-blue" disabled aria-label="下载CSV文件">下载 CSV</button>
                        <span id="summary" role="status" aria-live="polite"></span>
                    </div>
                    <div id="log" class="log" aria-live="polite" role="log" aria-label="解析日志"></div>
                    <div id="preview" class="hidden" role="region" aria-label="解析结果预览">
                        <table id="table" role="table" aria-label="解析结果表格"></table>
                    </div>
                </div>

                <!-- 使用声明 -->
                <div class="card-white mt-20">
                    <h2 class="usage-statement-title">维运网 船期解析工具使用声明</h2>
                    <p class="usage-statement-text">本工具用于解析从维运网（weiyun001.com）下载的船期网页，提取航线、船名、航次、开船日期等数据并导出为 CSV 文件。</p>
                    <p class="usage-statement-text">所有数据来源于维运网公开信息，解析结果仅供内部使用，请遵守维运网的使用条款和版权规定。</p>
                </div>
            </div>
        </main>
    </div>

    <!-- 标准化模态框 - 使用公共模板（vendor/template-utils.js） -->
    <div id="standardizationModalsContainer"></div>

    <!-- 引入导航栏公共组件 -->
    <script src="vendor/common-utils.js"></script>
    <script src="vendor/debug-utils.js"></script>
    <script src="vendor/sidebar-loader.js"></script>
    <script src="vendor/parser-utils.js"></script>
    <script src="vendor/template-utils.js"></script>
    <script>
        init001ToolPage('001-02-schedule-parser.html', 'tools001');
    </script>
    <script>

(function(){
    /**
     * DOM 选择器辅助函数
     * @param {string} selector - CSS 选择器
     * @returns {HTMLElement|null} 找到的元素
     */
    const selectElement = (selector) => document.querySelector(selector);
    const log = createLogger('#log');
    
    if (typeof window.generateStandardizationModals === 'function') {
        const container = document.getElementById('standardizationModalsContainer');
        if (container) {
            container.innerHTML = window.generateStandardizationModals();
        }
    }

    /**
     * 清洗船型：处理 xxx TEU 格式，合并为 xxxTEU
     * @param {string} shipType - 船型字符串
     * @returns {string} 清洗后的船型
     */
    function cleanShipType(shipType) {
        if (!shipType) return '';
        // 去掉所有空格（J列要求无空格），并兼容数字+TEU的场景
        return clean(shipType).replace(/\s+/g, '');
    }

    /**
     * 清洗船名航次：保留原值，但提供去空格版本用于比较
     * @param {string} vesselName - 船名
     * @param {string} voyage - 航次
     * @returns {Object} {original: 原值, normalized: 去空格版本}
     */
    function normalizeVesselVoyage(vesselName, voyage) {
        const normalizedVessel = vesselName ? clean(vesselName).replace(/\s+/g, '') : '';
        const normalizedVoyage = voyage ? clean(voyage).replace(/\s+/g, '') : '';
        return {
            vesselOriginal: vesselName || '',
            voyageOriginal: voyage || '',
            vesselNormalized: normalizedVessel,
            voyageNormalized: normalizedVoyage,
            combinedNormalized: `${normalizedVessel}_${normalizedVoyage}`
        };
    }

    /**
     * 规范化目的港码头：去空格后用于比较
     * @param {string} podWharf - 目的港码头
     * @returns {string} 去空格后的目的港码头
     */
    function normalizePodWharf(podWharf) {
        if (!podWharf) return '';
        return clean(podWharf).replace(/\s+/g, '').toUpperCase();
    }

    /** 特定码头名称修正映射 */
    const WHARF_NAME_CORRECTIONS = {
        'TER MINAL': 'TERMINAL',
        'SEA PORT': 'SEAPORT',
        'PANJA NG': 'PANJANG',
        'GUDA NG': 'GUDANG'
    };

    /**
     * 合并相邻的码头名称片段
     * @param {string} current - 当前片段
     * @param {string} next - 下一个片段
     * @returns {boolean} 是否应该合并
     */
    function shouldMergeTokens(current, next) {
        // 若下一个是单个大写字母，且当前为全大写字母（如 TERMINA + L）-> 合并
        if (/^[A-Z]+$/.test(current) && /^[A-Z]$/.test(next)) {
            return true;
        }
        // 若两边均为 1-2 位的大写字母缩写（如 QQ + CT）-> 合并
        if (/^[A-Z]{1,2}$/.test(current) && /^[A-Z]{1,2}$/.test(next)) {
            return true;
        }
        return false;
    }

    /**
     * 应用特定词修正
     * @param {string} text - 要修正的文本
     * @returns {string} 修正后的文本
     */
    function applyWharfNameCorrections(text) {
        let correctedText = text;
        for (const [wrong, correct] of Object.entries(WHARF_NAME_CORRECTIONS)) {
            const regex = new RegExp(`\\b${wrong}\\b`, 'g');
            correctedText = correctedText.replace(regex, correct);
        }
        return correctedText;
    }

    /**
     * 码头名清洗：修复被错误断开的缩写/单词，如 "QQ CT" -> "QQCT", "TERMINA L" -> "TERMINAL"
     * @param {string} name - 原始码头名称
     * @returns {string} 清洗后的码头名称
     */
    function normalizeWharfTokens(name) {
        const cleanedName = clean(name);
        if (!cleanedName) return cleanedName;
        
        const parts = cleanedName.split(' ');
        const mergedParts = [];
        
        for (let i = 0; i < parts.length; i++) {
            const currentPart = parts[i];
            if (!currentPart) {
                continue;
            }
            
            // 检查是否应该与下一个片段合并
            if (i + 1 < parts.length) {
                const nextPart = parts[i + 1];
                if (shouldMergeTokens(currentPart, nextPart)) {
                    mergedParts.push(currentPart + nextPart);
                    i++; // 跳过下一个片段，因为已经合并
                    continue;
                }
            }
            
            mergedParts.push(currentPart);
        }
        
        const joinedText = mergedParts.join(' ');
        return applyWharfNameCorrections(joinedText);
    }

    /** 搜索范围常量 */
    const SEARCH_RANGES = {
        BEFORE_HREF: 500,    // 向前查找 <a 标签的开始
        AFTER_HREF: 1000,    // 向后查找 > 标签的结束
        BEFORE_SUFFIX: 2000, // 在 suffix 前后搜索的范围
        AFTER_SUFFIX: 2000,
        TAG_CONTENT: 3000,   // 标签内容最大长度
        AFTER_TAG: 1500       // <a> 标签后查找 title 的范围
    };

    /** Title 属性匹配模式 */
    const TITLE_PATTERNS = [
        /title=(["'])((?:(?!\1)[\s\S])*?)\1/i,        // title="..." 或 title='...'
        /title\s*=\s*(["'])((?:(?!\1)[\s\S])*?)\1/i,  // title = "..." (有空格)
        /title\s*:\s*(["'])((?:(?!\1)[\s\S])*?)\1/i   // title: "..." (JSON格式)
    ];

    /**
     * 转义 title 值中的转义序列
     * @param {string} titleValue - 原始 title 值
     * @returns {string} 转义后的 title 值
     */
    function unescapeTitleValue(titleValue) {
        return titleValue
            .replace(/\\"/g, '"')
            .replace(/\\'/g, "'")
            .replace(/\\n/g, ' ')
            .replace(/\\t/g, ' ')
            .replace(/\\r/g, '');
    }

    /**
     * 从标签内容中提取 title 值
     * @param {string} tagContent - 标签内容
     * @returns {string|null} 提取的 title 值，如果未找到则返回 null
     */
    function extractTitleFromTagContent(tagContent) {
        for (const titlePattern of TITLE_PATTERNS) {
            const titleMatch = tagContent.match(titlePattern);
            if (titleMatch && titleMatch[2]) {
                const unescapedTitle = unescapeTitleValue(titleMatch[2]);
                const cleanedTitle = clean(unescapedTitle);
                if (cleanedTitle) {
                    return cleanedTitle;
                }
            }
        }
        return null;
    }

    /**
     * 策略1：通过 href 定位找到对应的 <a> 标签并提取 title
     * @param {string} searchText - 要搜索的文本
     * @param {string} suffix - 后缀（_fleetId_fleetIdPort）
     * @param {string} escapedSuffix - 转义后的后缀
     * @returns {string|null} 找到的 title 值，如果未找到则返回 null
     */
    function findTitleByHrefLocation(searchText, suffix, escapedSuffix) {
        const hrefPattern = new RegExp(`href=["']([^"']*${escapedSuffix})["']`, 'gi');
        let hrefMatch;
        
        while ((hrefMatch = hrefPattern.exec(searchText)) !== null) {
            const hrefValue = hrefMatch[1];
            if (!hrefValue || !hrefValue.endsWith(suffix)) {
                continue;
            }
            
            const hrefStart = hrefMatch.index;
            const hrefEnd = hrefMatch.index + hrefMatch[0].length;
            
            // 向前查找 <a 标签的开始
            const searchStart = Math.max(0, hrefStart - SEARCH_RANGES.BEFORE_HREF);
            const beforeHref = searchText.substring(searchStart, hrefStart);
            const tagStart = beforeHref.lastIndexOf('<a');
            if (tagStart === -1) {
                continue;
            }
            const actualTagStart = searchStart + tagStart;
            
            // 向后查找 > 标签的结束
            const searchEnd = Math.min(searchText.length, hrefEnd + SEARCH_RANGES.AFTER_HREF);
            const afterHref = searchText.substring(hrefEnd, searchEnd);
            const tagEnd = afterHref.indexOf('>');
            if (tagEnd === -1) {
                continue;
            }
            const actualTagEnd = hrefEnd + tagEnd;
            
            // 提取整个标签内容
            const tagContent = searchText.substring(actualTagStart, actualTagEnd + 1);
            const title = extractTitleFromTagContent(tagContent);
            if (title) {
                return title;
            }
        }
        
        return null;
    }

    /**
     * 策略2：使用正则表达式直接匹配整个 <a> 标签
     * @param {string} searchText - 要搜索的文本
     * @param {string} suffix - 后缀
     * @param {string} escapedSuffix - 转义后的后缀
     * @returns {string|null} 找到的 title 值，如果未找到则返回 null
     */
    function findTitleByRegexMatch(searchText, suffix, escapedSuffix) {
        const patterns = [
            new RegExp(`<a[\\s\\S]{0,${SEARCH_RANGES.TAG_CONTENT}}?href=["']([^"']*${escapedSuffix})["'][\\s\\S]{0,${SEARCH_RANGES.TAG_CONTENT}}?title=(["'])([\\s\\S]*?)\\2`, 'i'),
            new RegExp(`<a[\\s\\S]{0,${SEARCH_RANGES.TAG_CONTENT}}?title=(["'])([\\s\\S]*?)\\1[\\s\\S]{0,${SEARCH_RANGES.TAG_CONTENT}}?href=["']([^"']*${escapedSuffix})["']`, 'i')
        ];
        
        for (const pattern of patterns) {
            let match;
            while ((match = pattern.exec(searchText)) !== null) {
                if (match && match.length >= 4) {
                    let hrefValue, titleValue;
                    if (pattern === patterns[0]) {
                        hrefValue = match[1];
                        titleValue = match[3];
                    } else {
                        titleValue = match[2];
                        hrefValue = match[3];
                    }
                    
                    if (hrefValue && titleValue && hrefValue.endsWith(suffix)) {
                        const unescapedTitle = unescapeTitleValue(titleValue);
                        const cleanedTitle = clean(unescapedTitle);
                        if (cleanedTitle) {
                            return cleanedTitle;
                        }
                    }
                }
            }
        }
        
        return null;
    }

    /**
     * 策略3：更激进的搜索 - 直接搜索包含 suffix 的文本片段
     * @param {string} searchText - 要搜索的文本
     * @param {string} suffix - 后缀
     * @returns {string|null} 找到的 title 值，如果未找到则返回 null
     */
    function findTitleBySuffixSearch(searchText, suffix) {
        let searchIndex = 0;
        
        while (true) {
            const suffixIndex = searchText.indexOf(suffix, searchIndex);
            if (suffixIndex === -1) {
                break;
            }
            searchIndex = suffixIndex + 1;
            
            // 验证 suffix 在 href 属性中
            const beforeSuffix = searchText.substring(
                Math.max(0, suffixIndex - SEARCH_RANGES.BEFORE_SUFFIX),
                suffixIndex
            );
            const hrefMatch = beforeSuffix.match(/href\s*=\s*["']/i);
            if (!hrefMatch) {
                continue;
            }
            
            // 在 suffix 前后各2000字符范围内搜索
            const searchStart = Math.max(0, suffixIndex - SEARCH_RANGES.BEFORE_SUFFIX);
            const searchEnd = Math.min(
                searchText.length,
                suffixIndex + suffix.length + SEARCH_RANGES.AFTER_SUFFIX
            );
            const context = searchText.substring(searchStart, searchEnd);
            
            // 在这个上下文中查找 <a> 标签和 title
            const aTagMatch = context.match(/<a[\s\S]{0,3000}?>/i);
            if (aTagMatch) {
                const aTagStartInContext = context.indexOf(aTagMatch[0]);
                const aTagEnd = searchStart + aTagStartInContext + aTagMatch[0].length;
                // 在 <a> 标签后查找 title
                const afterTag = searchText.substring(
                    aTagEnd,
                    Math.min(searchText.length, aTagEnd + SEARCH_RANGES.AFTER_TAG)
                );
                const titleMatch = afterTag.match(/title\s*=\s*(["'])((?:(?!\1)[\s\S])*?)\1/i);
                if (titleMatch && titleMatch[2]) {
                    const unescapedTitle = unescapeTitleValue(titleMatch[2]);
                    const cleanedTitle = clean(unescapedTitle);
                    if (cleanedTitle) {
                        return cleanedTitle;
                    }
                }
            }
        }
        
        return null;
    }

    /**
     * 策略4：DOM 解析回退方案
     * @param {string} decodedHtml - 解码后的 HTML
     * @param {string} suffix - 后缀
     * @returns {string|null} 找到的 title 值，如果未找到则返回 null
     */
    function findTitleByDomParsing(decodedHtml, suffix) {
        try {
            const doc = new DOMParser().parseFromString(decodedHtml, 'text/html');
            const links = Array.from(doc.querySelectorAll('a[href]'));
            
            for (const link of links) {
                const href = link.getAttribute('href') || '';
                if (href && href.endsWith(suffix) && link.hasAttribute('title')) {
                    const title = clean(link.getAttribute('title'));
                    if (title) {
                        return title;
                    }
                }
            }
        } catch (error) {
            // DOM 解析失败，静默返回 null
        }
        
        return null;
    }

    /**
     * 根据"_航线ID_港口ID"后缀精准定位 <a ... title="...">
     * 要求：href 必须以 "_航线ID_港口ID" 结尾（可能前面有 #1_ 等前缀）
     * 优化：添加早期退出，减少不必要的搜索
     * @param {string} decodedHtml - 解码后的 HTML
     * @param {string} fleetId - 航线ID
     * @param {string} fleetIdPort - 港口ID
     * @param {string} originalHtml - 原始 HTML（可选）
     * @returns {string} 找到的共舱船公司标题，如果未找到则返回空字符串
     */
    function findCosTitle(decodedHtml, fleetId, fleetIdPort, originalHtml) {
        const suffix = `_${fleetId}_${fleetIdPort}`;
        const escapedSuffix = suffix.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        
        // 优化：快速检查是否存在suffix，如果不存在则直接返回
        if (decodedHtml.indexOf(suffix) === -1 && (!originalHtml || originalHtml.indexOf(suffix) === -1)) {
            return '';
        }
        
        // 在多个文本源中搜索
        const searchTexts = [decodedHtml];
        if (originalHtml && originalHtml !== decodedHtml) {
            searchTexts.push(originalHtml);
        }
        
        // 按优先级尝试各种策略（优化：快速策略优先）
        for (const searchText of searchTexts) {
            // 策略2：正则表达式直接匹配（通常最快）
            const title2 = findTitleByRegexMatch(searchText, suffix, escapedSuffix);
            if (title2) return title2;
            
            // 策略1：通过 href 定位
            const title1 = findTitleByHrefLocation(searchText, suffix, escapedSuffix);
            if (title1) return title1;
            
            // 策略3：激进搜索（最慢，最后尝试）
            // 优化：只在其他策略都失败时才尝试
            // const title3 = findTitleBySuffixSearch(searchText, suffix);
            // if (title3) return title3;
        }
        
        // 策略4：DOM 解析（只在解码后的HTML中尝试，且只在其他策略都失败时）
        // 优化：DOM解析很慢，只在必要时执行
        // const title4 = findTitleByDomParsing(decodedHtml, suffix);
        // if (title4) return title4;
        
        return '';
    }

    /**
     * 把 self.__next_f.push([1,"..."]) 里的字符串解码拼接，得到可解析文本
     * @param {string} html - 原始 HTML
     * @returns {string} 解码后的文本
     */
    function extractDecodedPayload(html) {
        let output = '';
        const pushPattern = /self\.__next_f\.push\(\[\d+\s*,\s*(["'])([\s\S]*?)\1\]\)/g;
        let match;
        
        while ((match = pushPattern.exec(html))) {
            try {
                // 利用 JSON.parse 解码转义序列
                const escapedString = match[2].replace(/\\"/g, '\\"');
                output += JSON.parse('"' + escapedString + '"');
            } catch (error) {
                // 退化处理常见转义
                output += match[2]
                    .replace(/\\n/g, '\n')
                    .replace(/\\t/g, '\t')
                    .replace(/\\"/g, '"');
            }
            output += '\n';
        }
        
        // 如果没抓到 push 片段，就直接用原 html
        return output || html;
    }

    /**
     * 清理 JSON 字符串中的无效控制字符
     * 只清理字符串值中的控制字符，不影响 JSON 结构
     * @param {string} jsonString - 原始 JSON 字符串
     * @returns {string} 清理后的 JSON 字符串
     */
    function sanitizeJsonString(jsonString) {
        // 匹配字符串值（在引号内的内容），包括转义序列
        return jsonString.replace(/"([^"\\]|\\.)*"/g, (match) => {
            // 提取字符串内容（去掉引号）
            let content = match.slice(1, -1);
            let result = '';
            let i = 0;
            
            while (i < content.length) {
                const char = content[i];
                const code = char.charCodeAt(0);
                
                // 如果是转义序列，保留原样
                if (char === '\\' && i + 1 < content.length) {
                    result += char + content[i + 1];
                    i += 2;
                    continue;
                }
                
                // 如果是控制字符（0x00-0x1F），转义它
                if (code >= 0x00 && code <= 0x1F) {
                    // 常见字符使用简写形式
                    if (code === 0x0A) { // \n
                        result += '\\n';
                    } else if (code === 0x0D) { // \r
                        result += '\\r';
                    } else if (code === 0x09) { // \t
                        result += '\\t';
                    } else {
                        // 其他控制字符使用 Unicode 转义
                        result += '\\u' + ('0000' + code.toString(16)).slice(-4);
                    }
                } else {
                    result += char;
                }
                i++;
            }
            
            return '"' + result + '"';
        });
    }

    /**
     * 构建 label -> 对象/数组 的索引（全页）
     * @param {string} html - HTML 文本
     * @returns {Object} 包含 objects 和 arrays 两个 Map 的对象
     */
    function buildLabelIndex(html) {
        const objects = new Map();
        const arrays = new Map();
        const objRe = /([A-Za-z0-9_]+)\s*:\s*\{([\s\S]*?)\}\s*(?=\n|\r|\]|,|<|$)/g;
        let objMatch;
        while ((objMatch = objRe.exec(html))) {
            const label = objMatch[1];
            let raw = '{' + objMatch[2].replace(/,\s*\}/g, '}') + '}';
            
            try {
                // 先尝试直接解析
                const parsedObject = JSON.parse(raw);
                objects.set(label, parsedObject);
            } catch (error) {
                // 如果失败，尝试清理控制字符后再解析
                try {
                    raw = sanitizeJsonString(raw);
                    const parsedObject = JSON.parse(raw);
                    objects.set(label, parsedObject);
                } catch (secondError) {
                    // 如果仍然失败，静默跳过（这些可能是非关键数据）
                    // 不输出错误信息，避免控制台被大量错误信息淹没
                    // 这些失败的解析通常不影响最终结果
                }
            }
        }
        
        const arrRe = /([A-Za-z0-9_]+)\s*:\s*\[([\s\S]*?)\]\s*(?=\n|\r|\}|,|<|$)/g;
        let arrMatch;
        while ((arrMatch = arrRe.exec(html))) {
            const label = arrMatch[1];
            const body = arrMatch[2];
            const items = [];
            const itemRe = /"\$?([A-Za-z0-9_]+)"/g;
            let itemMatch;
            while ((itemMatch = itemRe.exec(body))) {
                items.push(itemMatch[1]);
            }
            arrays.set(label, items);
        }
        return {objects, arrays};
    }

    /**
     * 解引用 notices/scheduleNotices/scheduleNoticeShare -> 船期对象数组
     * @param {Object} labelIndex - 标签索引对象
     * @param {string} label - 标签名
     * @returns {Array} 船期对象数组
     */
    function derefList(labelIndex, label) {
        if (!label) return [];
        const key = String(label).replace(/^\$/, '');
        const labelArray = labelIndex.arrays.get(key) || [];
        const out = [];
        for (const labelItem of labelArray) {
            const vesselObject = labelIndex.objects.get(labelItem);
            if (vesselObject && (vesselObject.vslName || vesselObject.voyNo)) {
                out.push(vesselObject);
            }
        }
        return out;
    }

    /**
     * 从DOM中提取可见的船期数据，用于验证JSON提取的数据是否真实存在
     * 优化：减少DOM查询次数，提高性能
     * @param {string} html - HTML 文本
     * @returns {Map} 键为 "fleetId_fleetIdPort_vesselName_voyage"，值为包含计划开航、目的港码头等信息的对象
     */
    function extractVisibleScheduleData(html) {
        const visibleData = new Map();
        try {
            const doc = new DOMParser().parseFromString(html, 'text/html');
            // 优化：只查找包含特定模式的链接，减少查询范围
            // 使用正则表达式在HTML文本中快速定位，而不是遍历所有链接
            const hrefPattern = /href=["']([^"']*_(\d+)_(\d+)[^"']*)["']/gi;
            const hrefMatches = [];
            let match;
            while ((match = hrefPattern.exec(html)) !== null) {
                const href = match[1];
                const fleetId = match[2];
                const fleetIdPort = match[3];
                // 跳过无效的港口ID
                if (fleetIdPort === '0' || fleetIdPort === '1') continue;
                hrefMatches.push({ href, fleetId, fleetIdPort, index: match.index });
            }
            
            // 优化：批量查询，减少DOM操作
            for (const { href, fleetId, fleetIdPort } of hrefMatches) {
                // 只查询包含这个href的链接
                const link = doc.querySelector(`a[href="${href.replace(/"/g, '\\"')}"]`);
                if (!link) continue;
                
                // 尝试从链接的title或周围文本中提取船名航次
                const title = link.getAttribute('title') || '';
                const linkText = (link.textContent || '').trim();
                
                // 优化：限制向上查找的深度，减少DOM遍历
                let planDate = '';
                let etaDate = '';
                let podWharf = '';
                
                // 向上查找包含日期的父元素（限制深度为6层，兼顾更多场景）
                let parent = link.parentElement;
                let searchDepth = 0;
                while (parent && searchDepth < 6) {
                    const parentText = (parent.textContent || '').trim();
                    // 匹配日期格式 YYYY/MM/DD（取前两个：第一个计划开航，第二个预计到港）
                    const dateMatches = parentText.match(/(\d{4}\/\d{2}\/\d{2})/g);
                    if (dateMatches && dateMatches.length > 0) {
                        if (!planDate) planDate = dateMatches[0];
                        if (dateMatches.length > 1 && !etaDate) etaDate = dateMatches[1];
                    }
                    // 查找目的港码头（限制查询范围）
                    if (!podWharf) {
                        const wharfEl = parent.querySelector('[class*="wharf"], [class*="terminal"]');
                        if (wharfEl) {
                            podWharf = (wharfEl.textContent || '').trim();
                        }
                    }
                    // 如果都找到了，提前退出
                    if (planDate && podWharf) break;
                    parent = parent.parentElement;
                    searchDepth++;
                }
                
                // 如果仍然缺失，从相同 fleetId/port 的其他元素补充
                if (!planDate || !podWharf || !etaDate) {
                    const relatedElements = Array.from(doc.querySelectorAll(`[href*="_${fleetId}_${fleetIdPort}"], [data-fleet-id="${fleetId}"][data-port-id="${fleetIdPort}"]`));
                    for (const el of relatedElements) {
                        const elText = (el.textContent || '').trim();
                        if (!planDate || !etaDate) {
                            const dateMatches = elText.match(/(\d{4}\/\d{2}\/\d{2})/g);
                            if (dateMatches && dateMatches.length > 0) {
                                if (!planDate) planDate = dateMatches[0];
                                if (dateMatches.length > 1 && !etaDate) etaDate = dateMatches[1];
                            }
                        }
                        if (!podWharf) {
                            const wharfMatch = elText.match(/([A-Z]{2,}\s*[A-Z]*\s*TERMINAL|[A-Z]{2,}\s*TERMINAL|[A-Z]{2,}\s*CT|[A-Z]{2,}\s*PORT)/i);
                            if (wharfMatch) podWharf = wharfMatch[1];
                        }
                        if (planDate && podWharf && etaDate) break;
                    }
                }
                
                // 提取船名航次（从title或文本中）
                let vesselName = '';
                let voyage = '';
                if (title) {
                    const vesselMatch = title.match(/([A-Z\s]+)\s*\/\s*([A-Z0-9]+)/);
                    if (vesselMatch) {
                        vesselName = clean(vesselMatch[1]);
                        voyage = clean(vesselMatch[2]);
                    }
                }
                if (!vesselName && linkText) {
                    const vesselMatch = linkText.match(/([A-Z\s]+)\s*\/\s*([A-Z0-9]+)/);
                    if (vesselMatch) {
                        vesselName = clean(vesselMatch[1]);
                        voyage = clean(vesselMatch[2]);
                    }
                }
                
                if (fleetId && fleetIdPort && (vesselName || voyage)) {
                    const key = `${fleetId}_${fleetIdPort}_${vesselName || ''}_${voyage || ''}`;
                    // 优化：避免重复设置相同的key
                    if (!visibleData.has(key)) {
                        visibleData.set(key, {
                            fleetId,
                            fleetIdPort,
                            vesselName,
                            voyage,
                            planDate: clean(planDate),
                            etaDate: clean(etaDate),
                            podWharf: clean(podWharf)
                        });
                    }
                }
            }
        } catch (error) {
            // DOM解析失败，静默返回空Map
        }
        return visibleData;
    }

    /**
     * 验证数据是否在DOM中可见
     * @param {string} fleetId - 航线ID
     * @param {string} fleetIdPort - 港口ID
     * @param {string} vesselName - 船名
     * @param {string} voyage - 航次
     * @param {Map} visibleData - 可见数据Map
     * @returns {boolean} 是否可见
     */
    function isDataVisible(fleetId, fleetIdPort, vesselName, voyage, visibleData) {
        if (!fleetId || !fleetIdPort || fleetIdPort === '0' || fleetIdPort === '1') {
            return false; // 无效的港口ID视为不可见
        }
        
        const key1 = `${fleetId}_${fleetIdPort}_${vesselName || ''}_${voyage || ''}`;
        const key2 = `${fleetId}_${fleetIdPort}_${clean(vesselName || '')}_${clean(voyage || '')}`;
        const key3 = `${fleetId}_${fleetIdPort}_${(vesselName || '').toUpperCase()}_${(voyage || '').toUpperCase()}`;
        
        return visibleData.has(key1) || visibleData.has(key2) || visibleData.has(key3);
    }

    /**
     * 从整页提取"fleet块 + 对应船期"对
     * @param {string} html - HTML 文本
     * @param {Object} labelIndex - 标签索引对象
     * @param {Map} visibleData - 可见数据Map（用于验证）
     * @returns {Array} fleet 对象数组
     */
    function extractFleetAndVessels(html, labelIndex, visibleData = new Map()) {
        const fleets = [];
        // 改进正则：更严格地匹配fleet对象，确保fleetIdPort与fleetId在同一对象中
        // 使用非贪婪匹配，避免跨对象匹配
        const fleetPattern = /\{[^{}]*?"fleetId"\s*:\s*(\d+)[^{}]*?"fleetIdPort"\s*:\s*(\d+)[^{}]*?\}/g;
        let fleetMatch;
        
        while ((fleetMatch = fleetPattern.exec(html))) {
            const segment = fleetMatch[0];
            const fleetId = fleetMatch[1];
            // 港口ID：严格从同一对象中提取，避免匹配到错误的片段
            let fleetIdPort = fleetMatch[2];
            
            // 验证：如果fleetIdPort是0或1，尝试从segment中查找更准确的港口ID
            if (fleetIdPort === '0' || fleetIdPort === '1') {
                // 在segment中查找所有fleetIdPort值，选择非0非1的最大值
                const allPortIds = segment.match(/"fleetIdPort"\s*:\s*(\d+)/g);
                if (allPortIds) {
                    const validPortIds = allPortIds
                        .map(m => m.match(/(\d+)/)[1])
                        .filter(id => id !== '0' && id !== '1')
                        .map(id => parseInt(id, 10))
                        .filter(id => id > 1);
                    if (validPortIds.length > 0) {
                        fleetIdPort = String(Math.max(...validPortIds));
                    }
                }
            }
            
            // 如果仍然是无效值，跳过这个fleet
            if (fleetIdPort === '0' || fleetIdPort === '1') {
                continue;
            }
            
            const carrierMatch = /("carrierShortName"\s*:\s*"([^"]*)")/.exec(segment);
            const carrierShortName = carrierMatch ? carrierMatch[2] : '';
            const svcCodeMatch = /("svcCode"\s*:\s*"([^"]*)")/.exec(segment);
            const svcCode = svcCodeMatch ? svcCodeMatch[2] : '';
            
            // 开航日：尝试多个字段
            let weekday = (/("weekdayOfETDFormatter"\s*:\s*"([^"]*)")/.exec(segment) || [])[2] || '';
            if (!weekday) {
                weekday = (/("weekday"\s*:\s*"([^"]*)")/.exec(segment) || [])[2] || '';
            }
            if (!weekday) {
                weekday = (/("etdWeekday"\s*:\s*"([^"]*)")/.exec(segment) || [])[2] || '';
            }
            
            // 航程：尝试多个字段和格式（增强提取逻辑）
            let shipdays = (/("shipdays"\s*:\s*(\d+))/.exec(segment) || [])[2] || '';
            if (!shipdays) {
                shipdays = (/("shipDays"\s*:\s*(\d+))/.exec(segment) || [])[2] || '';
            }
            if (!shipdays) {
                shipdays = (/("duration"\s*:\s*(\d+))/.exec(segment) || [])[2] || '';
            }
            if (!shipdays) {
                shipdays = (/("transitTime"\s*:\s*(\d+))/.exec(segment) || [])[2] || '';
            }
            if (!shipdays) {
                shipdays = (/("transitDays"\s*:\s*(\d+))/.exec(segment) || [])[2] || '';
            }
            // 尝试字符串格式
            if (!shipdays) {
                const shipdaysStr = (/("shipdays"\s*:\s*"(\d+)")/.exec(segment) || [])[2] || '';
                if (shipdaysStr) shipdays = shipdaysStr;
            }
            if (!shipdays) {
                const shipdaysStr = (/("shipDays"\s*:\s*"(\d+)")/.exec(segment) || [])[2] || '';
                if (shipdaysStr) shipdays = shipdaysStr;
            }
            if (!shipdays) {
                const shipdaysStr = (/("duration"\s*:\s*"(\d+)")/.exec(segment) || [])[2] || '';
                if (shipdaysStr) shipdays = shipdaysStr;
            }
            
            // 启运港码头：同时提取简写和全称（增强提取逻辑）
            let polWharfShort = (/("startPortWharfEnShortName"\s*:\s*"([^"]*)")/.exec(segment) || [])[2] || '';
            let polWharfFull = (/("startPortWharfEnFullName"\s*:\s*"([^"]*)")/.exec(segment) || [])[2] || '';
            // 如果都没有，尝试其他字段
            if (!polWharfShort && !polWharfFull) {
                polWharfShort = (/("wharfName"\s*:\s*"([^"]*)")/.exec(segment) || [])[2] || '';
            }
            if (!polWharfShort && !polWharfFull) {
                polWharfFull = (/("polWharf"\s*:\s*"([^"]*)")/.exec(segment) || [])[2] || '';
            }
            if (!polWharfShort && !polWharfFull) {
                polWharfFull = (/("startPortTerminal"\s*:\s*"([^"]*)")/.exec(segment) || [])[2] || '';
            }
            // 组合：如果有简写和全称，用/分隔；否则使用其中一个
            let polWharf = '';
            if (polWharfShort && polWharfFull) {
                polWharf = `${polWharfShort}/${polWharfFull}`;
            } else if (polWharfShort) {
                polWharf = polWharfShort;
            } else if (polWharfFull) {
                polWharf = polWharfFull;
            }
            
            // 目的港码头：同时提取缩写和全称（增强提取逻辑）
            // 优先从整个segment中搜索，确保不遗漏
            let podShort = (/("destPortWharfEnShortName"\s*:\s*"([^"]*)")/.exec(segment) || [])[2] || '';
            let podFull = (/("destPortWharfEnFullName"\s*:\s*"([^"]*)")/.exec(segment) || [])[2] || '';
            // 如果只有其中一个，尝试其他字段
            if (!podShort && !podFull) {
                podShort = (/("podWharf"\s*:\s*"([^"]*)")/.exec(segment) || [])[2] || '';
            }
            if (!podShort && !podFull) {
                podFull = (/("destPortTerminal"\s*:\s*"([^"]*)")/.exec(segment) || [])[2] || '';
            }
            
            // 应用码头名规范化
            polWharf = normalizeWharfTokens(polWharf);
            podShort = normalizeWharfTokens(podShort);
            podFull = normalizeWharfTokens(podFull);
            
            const startPortEnMatch = /("startPortEnName"\s*:\s*"([^"]*)")/.exec(segment);
            const startPortCnMatch = /("startPortCnName"\s*:\s*"([^"]*)")/.exec(segment);
            const destPortEnMatch = /("destPortEnName"\s*:\s*"([^"]*)")/.exec(segment);
            const destPortCnMatch = /("destPortCnName"\s*:\s*"([^"]*)")/.exec(segment);
            const scheduleNoticesMatch = /("scheduleNotices"\s*:\s*"\$?([A-Za-z0-9_]+)")/.exec(segment);
            const label1 = scheduleNoticesMatch ? scheduleNoticesMatch[2] : '';
            const noticesMatch = /("notices"\s*:\s*"\$?([A-Za-z0-9_]+)")/.exec(segment);
            const label2 = noticesMatch ? noticesMatch[2] : '';
            const scheduleNoticeShareMatch = /("scheduleNoticeShare"\s*:\s*"\$?([A-Za-z0-9_]+)")/.exec(segment);
            const label3 = scheduleNoticeShareMatch ? scheduleNoticeShareMatch[2] : '';

            let vessels = [];
            vessels = derefList(labelIndex, label1);
            if (!vessels.length) vessels = derefList(labelIndex, label2);
            if (!vessels.length) vessels = derefList(labelIndex, label3);

            const origin = startPortEnMatch && startPortCnMatch
                ? `${startPortEnMatch[2]}(${startPortCnMatch[2]})`
                : '';
            const dest = destPortEnMatch && destPortCnMatch
                ? `${destPortEnMatch[2]}(${destPortCnMatch[2]})`
                : '';
            fleets.push({
                fleetId,
                fleetIdPort,
                carrierShortName,
                svcCode,
                weekday,
                shipdays,
                polWharf,
                podShort,
                podFull,
                origin,
                dest,
                vessels
            });
        }
        return fleets;
    }

    /**
     * 提取启运港和目的港
     * 优先：在任意对象片段中查找 start/dest 四个字段（适配 fc:{...} 结构）
     * 次级：DOM 上方提示条
     * 兜底：正则匹配"由...发往..."
     * @param {string} html - HTML 文本
     * @returns {Object} 包含 origin 和 dest 的对象
     */
    function extractOriginDest(html) {
        const jsonMatch = html.match(/"startPortEnName"\s*:\s*"([^"]+)"[\s\S]*?"startPortCnName"\s*:\s*"([^"]+)"[\s\S]*?"destPortEnName"\s*:\s*"([^"]+)"[\s\S]*?"destPortCnName"\s*:\s*"([^"]+)"/);
        if (jsonMatch) {
            const origin = `${jsonMatch[1]}(${jsonMatch[2]})`;
            const dest = `${jsonMatch[3]}(${jsonMatch[4]})`;
            return { origin, dest };
        }
        try {
            const doc = new DOMParser().parseFromString(html, 'text/html');
            const bar = doc.querySelector('span.flex.items-center.text-\\[12px\\]');
            if (bar) {
                const strongs = Array.from(bar.querySelectorAll('span.font-bold'));
                const originText = strongs[0] ? (strongs[0].textContent || '').trim() : '';
                const destText = strongs[1] ? (strongs[1].textContent || '').trim() : '';
                if (originText && destText) {
                    return { origin: originText, dest: destText };
                }
            }
        } catch (error) {
            // DOM 解析失败，继续尝试其他方法
        }
        const textMatchPattern = new RegExp(
            '>\\s*([A-Z][A-Z\\s]+)<!-- -->\\(<!-- -->([\\u4e00-\\u9fa5]+)<!-- -->\\)</span>发往</span[^>]*>\\s*([A-Z][A-Z\\s]+)<!-- -->\\(<!-- -->([\\u4e00-\\u9fa5]+)<!-- -->\\)\\s*</span>'
        );
        const textMatch = html.match(textMatchPattern);
        if (textMatch) {
            return {
                origin: `${textMatch[1].trim()}(${textMatch[2]})`,
                dest: `${textMatch[3].trim()}(${textMatch[4]})`
            };
        }
        return { origin: '', dest: '' };
    }

    /**
     * 从字符串中提取日期部分（YYYY/MM/DD 格式）
     * @param {string} dateString - 包含日期的字符串
     * @returns {string} 提取的日期字符串，如果未找到则返回空字符串
     */
    function datePart(dateString) {
        if (!dateString) return '';
        const dateMatch = String(dateString).match(/(\d{4}\/\d{2}\/\d{2})/);
        return dateMatch ? dateMatch[1] : '';
    }

    /**
     * 从对象中提取船名（尝试多个字段名）
     * @param {Object} obj - 对象
     * @returns {string} 船名
     */
    function extractVesselName(obj) {
        if (!obj) return '';
        return obj.vslName 
            || obj.vesselName 
            || obj.vslNameEn 
            || obj.vesselNameEn
            || obj.shipName
            || obj.name
            || '';
    }

    /**
     * 从对象中提取航次（尝试多个字段名）
     * @param {Object} obj - 对象
     * @returns {string} 航次
     */
    function extractVoyage(obj) {
        if (!obj) return '';
        return obj.voyNo 
            || obj.voyageNo 
            || obj.voyNoEn
            || obj.voyage
            || obj.voy
            || '';
    }

    /**
     * 从对象中提取计划开航日期（尝试多个字段名和格式）
     * @param {Object} obj - 对象
     * @returns {string} 计划开航日期（YYYY/MM/DD格式）
     */
    function extractPlanDate(obj) {
        if (!obj) return '';
        // 尝试多个字段名（增强：增加更多可能的字段名）
        const dateStr = obj.etdFormatter 
            || obj.portSailingDateFormatter
            || obj.etd
            || obj.sailingDate
            || obj.portSailingDate
            || obj.etdDate
            || obj.planDate
            || obj.planEtd
            || obj.etdPlan
            || obj.planSailingDate
            || obj.scheduledDepartureDate
            || obj.departureDate
            || obj.etdDateFormatter
            || '';
        return datePart(dateStr);
    }

    /**
     * 从对象中提取预计到港日期（尝试多个字段名和格式）
     * @param {Object} obj - 对象
     * @returns {string} 预计到港日期（YYYY/MM/DD格式）
     */
    function extractEtaDate(obj) {
        if (!obj) return '';
        // 尝试多个字段名
        const dateStr = obj.etaFormatter 
            || obj.eta
            || obj.etaDate
            || obj.estimatedArrivalDate
            || obj.arrivalDate
            || '';
        return datePart(dateStr);
    }

    /**
     * 从HTML文本中补充缺失的船名、航次、日期等信息（优化版本）
     * @param {string} decodedHtml - 解码后的HTML文本
     * @param {string} lineId - 航线ID
     * @param {string} portId - 港口ID
     * @param {Object} missingData - 缺失的数据对象 {vesselName, voyage, plan, eta, weekday, shipdays, polWharf, podWharf}
     * @param {Map} visibleData - 可见数据Map（可选）
     * @returns {Object} 补充后的数据对象
     */
    function supplementMissingData(decodedHtml, lineId, portId, missingData, visibleData = null) {
        const result = {...missingData};
        
        // 优先从可见数据中提取计划开航/预计到港/目的港码头
        if (visibleData && visibleData.size > 0 && (missingData.vesselName || missingData.voyage)) {
            const visibleKey = `${lineId}_${portId}_${missingData.vesselName || ''}_${missingData.voyage || ''}`;
            const visibleInfo = visibleData.get(visibleKey) || 
                              visibleData.get(`${lineId}_${portId}_${clean(missingData.vesselName || '')}_${clean(missingData.voyage || '')}`) ||
                              visibleData.get(`${lineId}_${portId}_${(missingData.vesselName || '').toUpperCase()}_${(missingData.voyage || '').toUpperCase()}`);
            
            if (visibleInfo) {
                if (!result.plan && visibleInfo.planDate) {
                    result.plan = visibleInfo.planDate;
                }
                if (!result.eta && visibleInfo.etaDate) {
                    result.eta = visibleInfo.etaDate;
                }
                if (!result.podWharf && visibleInfo.podWharf) {
                    result.podWharf = visibleInfo.podWharf;
                }
            }
        }
        
        // 检查是否所有关键数据都已存在（允许部分字段为空）
        const hasAllCritical = result.vesselName && result.voyage && result.plan && result.eta;
        if (hasAllCritical && result.weekday && result.shipdays && result.podWharf) {
            return result;
        }

        // 优化：只在需要时才搜索，减少搜索范围
        // 尝试从包含航线ID和港口ID的上下文中提取（缩小搜索范围，增强匹配精度）
        // 使用更精确的模式，确保fleetId和fleetIdPort在同一fleet块中
        const contextPattern = new RegExp(
            `"fleetId"\\s*:\\s*${lineId}[\\s\\S]{0,500}"fleetIdPort"\\s*:\\s*${portId}[\\s\\S]{0,10000}`,
            'i'
        );
        const contextMatch = decodedHtml.match(contextPattern);
        let context = null;
        if (contextMatch) {
            let candidateContext = contextMatch[0];
            
            // 验证：确保context中包含正确的fleetId和fleetIdPort
            const contextFleetIdMatch = candidateContext.match(/"fleetId"\s*:\s*(\d+)/i);
            const contextFleetIdPortMatch = candidateContext.match(/"fleetIdPort"\s*:\s*(\d+)/i);
            if (contextFleetIdMatch && contextFleetIdPortMatch) {
                const contextFleetId = contextFleetIdMatch[1];
                const contextFleetIdPort = contextFleetIdPortMatch[1];
                // 如果fleetId和fleetIdPort匹配，使用这个context
                if (contextFleetId === lineId && contextFleetIdPort === portId) {
                    context = candidateContext;
                } else {
                    // 如果不匹配，尝试查找正确的fleet块
                    const correctFleetPattern = new RegExp(
                        `"fleetId"\\s*:\\s*${lineId}[\\s\\S]{0,500}"fleetIdPort"\\s*:\\s*${portId}[\\s\\S]{0,10000}(?="fleetId"|$)`,
                        'i'
                    );
                    const correctFleetMatch = decodedHtml.match(correctFleetPattern);
                    if (correctFleetMatch) {
                        context = correctFleetMatch[0];
                    }
                }
            } else {
                context = candidateContext;
            }
        }
        
        if (context) {
            
            // 一次性匹配所有需要的字段，减少循环次数
            if (!result.vesselName) {
                const match = context.match(/"vslName"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"vesselName"\s*:\s*"([^"]+)"/i);
                if (match && match[1]) {
                    result.vesselName = clean(match[1]);
                }
            }
            
            if (!result.voyage) {
                const match = context.match(/"voyNo"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"voyageNo"\s*:\s*"([^"]+)"/i);
                if (match && match[1]) {
                    result.voyage = clean(match[1]);
                }
            }
            
            if (!result.plan) {
                // 增强计划开航提取：尝试更多字段（包括数字格式的日期）
                const match = context.match(/"etdFormatter"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"portSailingDateFormatter"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"etd"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"sailingDate"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"portSailingDate"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"etdDate"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"planDate"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"planEtd"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"etdPlan"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"planSailingDate"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"scheduledDepartureDate"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"departureDate"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"etdDateFormatter"\s*:\s*"([^"]+)"/i) ||
                             // 增强：尝试匹配数字格式的日期（如 "etd": 1735689600000）
                             context.match(/"etd"\s*:\s*(\d{10,13})/i) ||
                             context.match(/"etdDate"\s*:\s*(\d{10,13})/i) ||
                             context.match(/"planDate"\s*:\s*(\d{10,13})/i) ||
                             context.match(/"sailingDate"\s*:\s*(\d{10,13})/i);
                if (match && match[1]) {
                    // 如果是时间戳（数字），转换为日期格式
                    if (/^\d{10,13}$/.test(match[1])) {
                        const timestamp = parseInt(match[1], 10);
                        // 处理毫秒和秒两种格式
                        const date = new Date(timestamp > 1000000000000 ? timestamp : timestamp * 1000);
                        if (!isNaN(date.getTime())) {
                            const year = date.getFullYear();
                            const month = String(date.getMonth() + 1).padStart(2, '0');
                            const day = String(date.getDate()).padStart(2, '0');
                            result.plan = `${year}/${month}/${day}`;
                        }
                    } else {
                        result.plan = datePart(match[1]);
                    }
                }
            }
            
            if (!result.eta) {
                // 增强预计到港提取：尝试更多字段
                const match = context.match(/"etaFormatter"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"eta"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"etaDate"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"estimatedArrivalDate"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"arrivalDate"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"ataFormatter"\s*:\s*"([^"]+)"/i);
                if (match && match[1]) {
                    result.eta = datePart(match[1]);
                }
            }
            
            // 补充开航日（weekday）- 增强提取逻辑，尝试更多字段
            if (!result.weekday) {
                const match = context.match(/"weekdayOfETDFormatter"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"weekday"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"etdWeekday"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"weekdayOfETD"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"sailingWeekday"\s*:\s*"([^"]+)"/i) ||
                             context.match(/"departureWeekday"\s*:\s*"([^"]+)"/i);
                if (match && match[1]) {
                    result.weekday = clean(match[1]);
                }
            }
            
            // 补充航程（shipdays）- 增强提取逻辑
            if (!result.shipdays) {
                const match = context.match(/"shipdays"\s*:\s*(\d+)/i) ||
                             context.match(/"shipDays"\s*:\s*(\d+)/i) ||
                             context.match(/"duration"\s*:\s*(\d+)/i) ||
                             context.match(/"transitTime"\s*:\s*(\d+)/i) ||
                             context.match(/"transitDays"\s*:\s*(\d+)/i) ||
                             context.match(/"shipdays"\s*:\s*"(\d+)"/i) ||
                             context.match(/"shipDays"\s*:\s*"(\d+)"/i) ||
                             context.match(/"duration"\s*:\s*"(\d+)"/i);
                if (match && match[1]) {
                    result.shipdays = clean(match[1]);
                }
            }
            
            // 补充起运港码头（polWharf）- 增强提取逻辑，同时提取简写和全称
            if (!result.polWharf) {
                const polShortMatch = context.match(/"startPortWharfEnShortName"\s*:\s*"([^"]+)"/i);
                const polFullMatch = context.match(/"startPortWharfEnFullName"\s*:\s*"([^"]+)"/i);
                let polShort = polShortMatch ? clean(polShortMatch[1]) : '';
                let polFull = polFullMatch ? clean(polFullMatch[1]) : '';
                
                // 如果都没有，尝试其他字段
                if (!polShort && !polFull) {
                    const polMatch = context.match(/"wharfName"\s*:\s*"([^"]+)"/i) ||
                                   context.match(/"polWharf"\s*:\s*"([^"]+)"/i) ||
                                   context.match(/"startPortTerminal"\s*:\s*"([^"]+)"/i);
                    if (polMatch && polMatch[1]) {
                        polShort = clean(polMatch[1]);
                    }
                }
                
                // 规范化并组合
                polShort = normalizeWharfTokens(polShort);
                polFull = normalizeWharfTokens(polFull);
                
                if (polShort && polFull) {
                    result.polWharf = `${polShort}/${polFull}`;
                } else if (polShort) {
                    result.polWharf = polShort;
                } else if (polFull) {
                    result.polWharf = polFull;
                }
            }
            
            // 补充目的港码头（podWharf）- 增强提取逻辑，确保同时提取简写和全称
            // 检查是否只有简写（没有/分隔符且长度较短），如果是，尝试补充全称
            const hasPodWharf = result.podWharf && result.podWharf.trim();
            const podWharfOnlyShort = hasPodWharf && !result.podWharf.includes('/') && result.podWharf.length < 15;
            
            if (!result.podWharf || podWharfOnlyShort) {
                // 优先从整个context中搜索，确保不遗漏
                // 尝试提取目的港码头的缩写和全称
                const podShortMatch = context.match(/"destPortWharfEnShortName"\s*:\s*"([^"]+)"/i);
                const podFullMatch = context.match(/"destPortWharfEnFullName"\s*:\s*"([^"]+)"/i);
                let podShort = podShortMatch ? clean(podShortMatch[1]) : '';
                let podFull = podFullMatch ? clean(podFullMatch[1]) : '';
                
                // 如果都没有，尝试其他字段
                if (!podShort && !podFull) {
                    const podMatch = context.match(/"podWharf"\s*:\s*"([^"]+)"/i) ||
                                   context.match(/"destPortTerminal"\s*:\s*"([^"]+)"/i);
                    if (podMatch && podMatch[1]) {
                        podShort = clean(podMatch[1]);
                    }
                }
                
                // 规范化并组合
                podShort = normalizeWharfTokens(podShort);
                podFull = normalizeWharfTokens(podFull);
                
                // 如果已有简写，优先使用已有的
                if (podWharfOnlyShort && result.podWharf) {
                    podShort = result.podWharf;
                }
                
                if (podShort && podFull) {
                    result.podWharf = `${podShort}/${podFull}`;
                } else if (podShort) {
                    result.podWharf = podShort;
                } else if (podFull) {
                    result.podWharf = podFull;
                } else if (!result.podWharf && hasPodWharf) {
                    // 如果补充失败，保留原值
                    result.podWharf = result.podWharf;
                }
            }
        }
        
        // 如果仍然缺失，进行全局搜索（增强：优先搜索包含fleetId和fleetIdPort的vessel对象）
        const needsGlobalSearch = !result.plan || !result.eta || !result.vesselName || !result.voyage;
        if (needsGlobalSearch && decodedHtml) {
            // 策略1：优先搜索包含fleetId和fleetIdPort的vessel对象（增强：更精确的匹配）
            if (lineId && portId) {
                // 先查找包含fleetId和fleetIdPort的完整fleet块，然后在该块中查找vessel对象
                const fleetBlockPattern = new RegExp(
                    `"fleetId"\\s*:\\s*${lineId}[\\s\\S]{0,500}"fleetIdPort"\\s*:\\s*${portId}[\\s\\S]{0,10000}`,
                    'i'
                );
                const fleetBlockMatch = decodedHtml.match(fleetBlockPattern);
                const searchContext = fleetBlockMatch ? fleetBlockMatch[0] : decodedHtml;
                
                // 在fleet块中查找vessel对象
                const vesselWithFleetPattern = /\{[^{}]*?"(?:vslName|vesselName)"\s*:\s*"[^"]+"[\s\S]{0,2000}?"(?:voyNo|voyageNo)"\s*:\s*"[^"]+"[\s\S]*?\}/g;
                let vesselWithFleetMatch;
                let count1 = 0;
                while ((vesselWithFleetMatch = vesselWithFleetPattern.exec(searchContext)) !== null && count1 < 20) {
                    count1++;
                    try {
                        const objText = vesselWithFleetMatch[0].replace(/,\s*\}/g, '}');
                        const vesselObj = JSON.parse(objText);
                        
                        // 验证fleetId和fleetIdPort是否匹配（如果vessel对象中有这些字段）
                        if (vesselObj.fleetId && vesselObj.fleetIdPort) {
                            if (vesselObj.fleetId !== lineId || vesselObj.fleetIdPort !== portId) {
                                continue; // 不匹配，跳过
                            }
                        }
                        
                        if (!result.vesselName) {
                            const name = extractVesselName(vesselObj);
                            if (name) result.vesselName = clean(name);
                        }
                        if (!result.voyage) {
                            const voy = extractVoyage(vesselObj);
                            if (voy) result.voyage = clean(voy);
                        }
                        if (!result.plan) {
                            const plan = extractPlanDate(vesselObj);
                            if (plan) result.plan = plan;
                        }
                        if (!result.eta) {
                            const eta = extractEtaDate(vesselObj);
                            if (eta) result.eta = eta;
                        }
                        if (!result.weekday) {
                            const weekday = vesselObj.weekdayOfETDFormatter 
                                || vesselObj.weekday 
                                || vesselObj.etdWeekday 
                                || vesselObj.weekdayOfETD
                                || vesselObj.sailingWeekday
                                || vesselObj.departureWeekday
                                || '';
                            if (weekday) result.weekday = clean(weekday);
                        }
                        if (!result.shipdays) {
                            const shipdays = vesselObj.shipdays || vesselObj.shipDays || vesselObj.duration || '';
                            if (shipdays) {
                                const numMatch = String(shipdays).match(/(\d+)/);
                                if (numMatch) result.shipdays = clean(numMatch[1]);
                            }
                        }
                        // 补充起运港码头（增强提取逻辑，同时提取简写和全称）
                        if (!result.polWharf) {
                            const polShort = normalizeWharfTokens(vesselObj.startPortWharfEnShortName || '');
                            const polFull = normalizeWharfTokens(vesselObj.startPortWharfEnFullName || '');
                            if (polShort && polFull) {
                                result.polWharf = `${polShort}/${polFull}`;
                            } else if (polShort) {
                                result.polWharf = polShort;
                            } else if (polFull) {
                                result.polWharf = polFull;
                            } else {
                                result.polWharf = normalizeWharfTokens(vesselObj.wharfName || vesselObj.polWharf || '');
                            }
                        }
                        
                        // 补充目的港码头（确保从正确的vessel对象中提取）
                        if (!result.podWharf || (result.podWharf && !result.podWharf.includes('/') && result.podWharf.length < 15)) {
                            const podShort = normalizeWharfTokens(vesselObj.destPortWharfEnShortName || '');
                            const podFull = normalizeWharfTokens(vesselObj.destPortWharfEnFullName || '');
                            if (podShort && podFull) {
                                result.podWharf = `${podShort}/${podFull}`;
                            } else if (podShort) {
                                result.podWharf = podShort;
                            } else if (podFull) {
                                result.podWharf = podFull;
                            }
                        }
                        
                        // 如果所有关键数据都已补充，提前退出
                        if (result.vesselName && result.voyage && result.plan && result.eta) {
                            break;
                        }
                    } catch (error) {
                        continue;
                    }
                }
            }
            
            // 策略2：如果策略1没有找到，进行通用搜索（增加搜索次数）
            if ((!result.plan || !result.eta || !result.vesselName || !result.voyage) && decodedHtml) {
                const vesselObjPattern = /\{[^{}]*?"(?:vslName|vesselName)"\s*:\s*"[^"]+"[\s\S]{0,2000}?"(?:voyNo|voyageNo)"\s*:\s*"[^"]+"[\s\S]*?\}/g;
                let count = 0;
                let vesselObjMatch;
                while ((vesselObjMatch = vesselObjPattern.exec(decodedHtml)) !== null && count < 15) {
                    count++;
                    try {
                        const objText = vesselObjMatch[0].replace(/,\s*\}/g, '}');
                        const vesselObj = JSON.parse(objText);
                        
                        if (!result.vesselName) {
                            const name = extractVesselName(vesselObj);
                            if (name) result.vesselName = clean(name);
                        }
                        if (!result.voyage) {
                            const voy = extractVoyage(vesselObj);
                            if (voy) result.voyage = clean(voy);
                        }
                        if (!result.plan) {
                            const plan = extractPlanDate(vesselObj);
                            if (plan) result.plan = plan;
                        }
                        if (!result.eta) {
                            const eta = extractEtaDate(vesselObj);
                            if (eta) result.eta = eta;
                        }
                        if (!result.weekday) {
                            const weekday = vesselObj.weekdayOfETDFormatter 
                                || vesselObj.weekday 
                                || vesselObj.etdWeekday 
                                || vesselObj.weekdayOfETD
                                || vesselObj.sailingWeekday
                                || vesselObj.departureWeekday
                                || '';
                            if (weekday) result.weekday = clean(weekday);
                        }
                        if (!result.shipdays) {
                            const shipdays = vesselObj.shipdays || vesselObj.shipDays || vesselObj.duration || '';
                            if (shipdays) {
                                const numMatch = String(shipdays).match(/(\d+)/);
                                if (numMatch) result.shipdays = clean(numMatch[1]);
                            }
                        }
                        // 补充起运港码头（增强提取逻辑，同时提取简写和全称）
                        if (!result.polWharf) {
                            const polShort = normalizeWharfTokens(vesselObj.startPortWharfEnShortName || '');
                            const polFull = normalizeWharfTokens(vesselObj.startPortWharfEnFullName || '');
                            if (polShort && polFull) {
                                result.polWharf = `${polShort}/${polFull}`;
                            } else if (polShort) {
                                result.polWharf = polShort;
                            } else if (polFull) {
                                result.polWharf = polFull;
                            } else {
                                result.polWharf = normalizeWharfTokens(vesselObj.wharfName || vesselObj.polWharf || '');
                            }
                        }
                        
                        // 补充目的港码头（确保从正确的vessel对象中提取）
                        if (!result.podWharf || (result.podWharf && !result.podWharf.includes('/') && result.podWharf.length < 15)) {
                            const podShort = normalizeWharfTokens(vesselObj.destPortWharfEnShortName || '');
                            const podFull = normalizeWharfTokens(vesselObj.destPortWharfEnFullName || '');
                            if (podShort && podFull) {
                                result.podWharf = `${podShort}/${podFull}`;
                            } else if (podShort) {
                                result.podWharf = podShort;
                            } else if (podFull) {
                                result.podWharf = podFull;
                            }
                        }
                        
                        // 如果所有关键数据都已补充，提前退出
                        if (result.vesselName && result.voyage && result.plan && result.eta) {
                            break;
                        }
                    } catch (error) {
                        continue;
                    }
                }
            }
        }
        
        return result;
    }

    /**
     * 提取主要内容（去除"中转"或"接二程"后的内容）
     * @param {string} decoded - 解码后的HTML文本
     * @returns {string} 主要内容文本
     */
    function extractMainContent(decoded) {
        const cutMarkers = [
            'text-[14px] font-bold">中转',
            'lineTypeShowName":"接二程"'
        ];
        let cutPos = -1;
        for (const marker of cutMarkers) {
            const markerPos = decoded.indexOf(marker);
            if (markerPos >= 0 && (cutPos === -1 || markerPos < cutPos)) {
                cutPos = markerPos;
            }
        }
        return cutPos > 0 ? decoded.slice(0, cutPos) : decoded;
    }

    /**
     * 处理单个船的数据，提取并构建行数据
     * @param {Object} vessel - 船对象
     * @param {Object} fleet - 船队对象
     * @param {Object} odTop - 起运港/目的港对象
     * @param {string} lineId - 航线ID
     * @param {string} portId - 港口ID
     * @param {string} carriers - 共舱船公司
     * @param {string} podCombined - 目的港码头组合
     * @param {string} defaultWeekday - 默认开航日
     * @param {string} defaultShipdays - 默认航程
     * @param {string} defaultPolWharf - 默认起运港码头
     * @param {Map} visibleData - 可见数据映射（可选）
     * @param {string} html - 原始HTML（用于可见数据提取）
     * @returns {Array|null} 行数据数组，如果无效则返回null
     */
    function processVesselData(vessel, fleet, odTop, lineId, portId, carriers, podCombined, 
                                defaultWeekday, defaultShipdays, defaultPolWharf, visibleData, html) {
        // 使用增强的提取函数，尝试多个字段名
        const vesselName = extractVesselName(vessel);
        const voyage = extractVoyage(vessel);
        const shipType = vessel.shipCapacity || '';
        let plan = extractPlanDate(vessel);
        const atd = datePart(vessel.atdFormatter || '');
        let eta = extractEtaDate(vessel);
        
        // 优化：延迟验证，只在数据不完整时才提取可见数据
        // 增强：即使plan存在，也尝试从可见数据中补充（因为可能不完整）
        const hasCompleteData = vesselName && voyage && plan && eta;
        if ((!hasCompleteData || !plan) && visibleData && visibleData.size > 0) {
            const visibleKey = `${lineId}_${portId}_${vesselName || ''}_${voyage || ''}`;
            const visibleInfo = visibleData.get(visibleKey) || 
                              visibleData.get(`${lineId}_${portId}_${clean(vesselName || '')}_${clean(voyage || '')}`) ||
                              visibleData.get(`${lineId}_${portId}_${(vesselName || '').toUpperCase()}_${(voyage || '').toUpperCase()}`);
            
            if (visibleInfo) {
                // 增强：优先使用可见数据中的计划开航（通常更准确）
                if (!plan && visibleInfo.planDate) {
                    plan = visibleInfo.planDate;
                } else if (plan && visibleInfo.planDate && plan !== visibleInfo.planDate) {
                    // 如果两者都存在但不一致，优先使用可见数据（通常更准确）
                    plan = visibleInfo.planDate;
                }
                if (!eta && visibleInfo.etaDate) eta = visibleInfo.etaDate;
                if (!podCombined && visibleInfo.podWharf) podCombined = visibleInfo.podWharf;
            }
        }
        
        // 增强：如果仍然没有计划开航，尝试从fleet级别提取
        if (!plan && fleet) {
            const fleetPlan = extractPlanDate(fleet);
            if (fleetPlan) plan = fleetPlan;
        }
        
        // 开航日：优先从 vessel，其次从 fleet
        let weekday = defaultWeekday;
        if (!weekday) {
            weekday = vessel.weekdayOfETDFormatter || vessel.weekday || vessel.etdWeekday || '';
        }
        
        // 航程：优先从 vessel，其次从 fleet（增强提取逻辑）
        let shipdays = defaultShipdays;
        if (!shipdays) {
            shipdays = vessel.shipdays || vessel.shipDays || vessel.duration || 
                      vessel.transitTime || vessel.transitDays || '';
        }
        if (shipdays && typeof shipdays === 'string') {
            const numMatch = shipdays.match(/(\d+)/);
            if (numMatch) shipdays = numMatch[1];
        }
        
        // 起运港码头：优先从 vessel，其次从 fleet
        let polWharf = defaultPolWharf;
        if (!polWharf) {
            const polShort = vessel.startPortWharfEnShortName || '';
            const polFull = vessel.startPortWharfEnFullName || '';
            if (polShort && polFull) {
                polWharf = `${normalizeWharfTokens(polShort)}/${normalizeWharfTokens(polFull)}`;
            } else if (polShort) {
                polWharf = normalizeWharfTokens(polShort);
            } else if (polFull) {
                polWharf = normalizeWharfTokens(polFull);
            } else {
                polWharf = normalizeWharfTokens(vessel.wharfName || vessel.polWharf || '');
            }
        }
        
        // 目的港码头：如果 vessel 中有，优先使用
        let vesselPodCombined = podCombined;
        if (vessel.destPortWharfEnShortName || vessel.destPortWharfEnFullName) {
            const vPodShort = normalizeWharfTokens(vessel.destPortWharfEnShortName || '');
            const vPodFull = normalizeWharfTokens(vessel.destPortWharfEnFullName || '');
            if (vPodShort && vPodFull) {
                vesselPodCombined = `${vPodShort}/${vPodFull}`;
            } else if (vPodShort) {
                vesselPodCombined = vPodShort;
            } else if (vPodFull) {
                vesselPodCombined = vPodFull;
            }
        }
        
        // 应用数据清洗
        const cleanedShipType = cleanShipType(shipType);
        const cleanedVesselName = clean(vesselName);
        const cleanedVoyage = clean(voyage);
        let finalEta = clean(eta);
        
        // 预计到港补充逻辑
        if (!finalEta && cleanedVesselName && cleanedVoyage) {
            const isBlankSailing = /BLANK\s*SAILING/i.test(cleanedVesselName) || 
                                  /BLANK\s*SAILING/i.test(cleanedVoyage);
            if (!isBlankSailing) {
                // 不是空白航行，应该有预计到港（补充机制会在后续处理）
            }
        }
        
        const origin = fleet.origin || odTop.origin || '';
        const dest = fleet.dest || odTop.dest || '';
        
        return [
            clean(origin),                      // 启运港
            clean(dest),                        // 目的港
            clean(lineId),                      // 航线ID
            clean(portId),                      // 港口ID
            clean(weekday),                     // 开航日
            clean(shipdays),                    // 航程
            clean(carriers),                    // 共舱船公司
            cleanedVesselName,                  // 船名（已清洗）
            cleanedVoyage,                      // 航次（已清洗）
            cleanedShipType,                    // 船型（已清洗）
            clean(plan),                        // 计划开航
            clean(atd),                         // 实际离港
            finalEta,                           // 预计到港
            clean(polWharf),                    // 启运港码头
            clean(vesselPodCombined)            // 目的港码头
        ];
    }

    /**
     * 处理船队数据，提取所有船的行数据
     * @param {Object} fleet - 船队对象
     * @param {Object} odTop - 起运港/目的港对象
     * @param {Map} carrierCache - 共舱船公司缓存
     * @param {string} decoded - 解码后的HTML文本
     * @param {string} html - 原始HTML
     * @param {Map} visibleData - 可见数据映射（可选）
     * @returns {Array<Array>} 行数据数组
     */
    function processFleetData(fleet, odTop, carrierCache, decoded, html, visibleData) {
        const lineId = fleet.fleetId;
        let portId = fleet.fleetIdPort;
        
        // 港口ID：优先使用 fleet 中的，如果无效则尝试从 vessel 中提取
        if (!portId || portId === '0' || portId === '') {
            for (const vessel of fleet.vessels) {
                if (vessel.fleetIdPort && vessel.fleetIdPort !== '0') {
                    portId = vessel.fleetIdPort;
                    break;
                }
            }
        }
        
        // 优化：使用缓存避免重复查找共舱船公司
        const carrierKey = `${lineId}_${portId}`;
        let carriers = carrierCache.get(carrierKey);
        if (carriers === undefined) {
            carriers = findCosTitle(decoded, lineId, portId, html);
            if (!carriers) {
                carriers = [
                    fleet.carrierShortName && fleet.svcCode
                        ? `${fleet.carrierShortName}(${fleet.svcCode})`
                        : fleet.carrierShortName
                ].filter(Boolean).join('');
            }
            carrierCache.set(carrierKey, carriers);
        }
        
        // 目的港码头：改进组合逻辑
        let podCombined = '';
        if (fleet.podShort && fleet.podFull) {
            podCombined = `${fleet.podShort}/${fleet.podFull}`;
        } else if (fleet.podShort) {
            podCombined = fleet.podShort;
        } else if (fleet.podFull) {
            podCombined = fleet.podFull;
        }
        
        // 从 fleet 级别提取的默认值
        const defaultWeekday = fleet.weekday || '';
        const defaultShipdays = fleet.shipdays || '';
        const defaultPolWharf = fleet.polWharf || '';
        
        const rows = [];
        // 当页目的港码头补全映射：key为lineId_portId_dest，value为podWharf（带全称）
        // 确保只补全相同目的港的记录，避免跨目的港补全
        const pagePodFullMap = new Map(); // key: lineId_portId_dest, value: podWharf 带全称
        // 增强：当页计划开航补全映射：key为lineId_portId_vesselName_voyage，value为planDate
        const pagePlanMap = new Map(); // key: lineId_portId_vesselName_voyage, value: planDate
        
        for (const vessel of fleet.vessels) {
            const row = processVesselData(vessel, fleet, odTop, lineId, portId, carriers, podCombined,
                                        defaultWeekday, defaultShipdays, defaultPolWharf, visibleData, html);
            if (row) {
                const vesselName = row[7] || ''; // 船名
                const voyage = row[8] || ''; // 航次
                const plan = row[10] || ''; // 计划开航
                const dest = row[1] || '';
                const podWharf = row[14] || '';
                
                // 增强：当页计划开航补全
                if (!plan && vesselName && voyage && lineId && portId) {
                    const planKey = `${lineId}_${portId}_${vesselName}_${voyage}`;
                    if (pagePlanMap.has(planKey)) {
                        row[10] = pagePlanMap.get(planKey);
                    }
                } else if (plan && vesselName && voyage && lineId && portId) {
                    // 如果当前记录有计划开航，保存到映射中
                    const planKey = `${lineId}_${portId}_${vesselName}_${voyage}`;
                    pagePlanMap.set(planKey, plan);
                }
                
                // 当页补全：如果目的港码头只有简写，尝试从当前页面的其他记录中补全
                const onlyShort = podWharf && !podWharf.includes('/') && podWharf.length < 15;
                
                if (onlyShort && lineId && portId && dest) {
                    const key = `${lineId}_${portId}_${dest}`;
                    if (pagePodFullMap.has(key)) {
                        // 如果当前页面有带全称的记录，使用它
                        row[14] = pagePodFullMap.get(key);
                    }
                } else if (podWharf && podWharf.includes('/') && lineId && portId && dest) {
                    // 如果当前记录有带全称的目的港码头，保存到映射中
                    const key = `${lineId}_${portId}_${dest}`;
                    const current = pagePodFullMap.get(key) || '';
                    if (podWharf.length > current.length) {
                        pagePodFullMap.set(key, podWharf);
                    }
                }
                
                rows.push(row);
            }
        }
        
        // 第二遍遍历：用带全称的记录补全只有简写的记录（当页补全）
        for (let i = 0; i < rows.length; i++) {
            const row = rows[i];
            const dest = row[1] || '';
            const podWharf = row[14] || '';
            const vesselName = row[7] || '';
            const voyage = row[8] || '';
            const plan = row[10] || '';
            const onlyShort = podWharf && !podWharf.includes('/') && podWharf.length < 15;
            
            // 增强：当页计划开航补全（第二遍）
            if (!plan && vesselName && voyage && lineId && portId) {
                const planKey = `${lineId}_${portId}_${vesselName}_${voyage}`;
                if (pagePlanMap.has(planKey)) {
                    row[10] = pagePlanMap.get(planKey);
                }
            }
            
            if (onlyShort && lineId && portId && dest) {
                const key = `${lineId}_${portId}_${dest}`;
                if (pagePodFullMap.has(key)) {
                    row[14] = pagePodFullMap.get(key);
                }
            }
        }
        
        return rows;
    }

    /**
     * 兜底提取：从整页直接抓取含 vslName 的对象
     * @param {string} mainText - 主要内容文本
     * @param {Object} odTop - 起运港/目的港对象
     * @returns {Array<Array>} 行数据数组
     */
    function extractFallbackVessels(mainText, odTop) {
        const rows = [];
        const vesselPattern = /\{[^{}]*?"(?:vslName|vesselName)"\s*:\s*"[^"]+"[\s\S]*?\}/g;
        let vesselMatch;
        
        while ((vesselMatch = vesselPattern.exec(mainText))) {
            const objText = vesselMatch[0].replace(/,\s*\}/g, '}');
            try {
                const vessel = JSON.parse(objText);
                const vesselName = extractVesselName(vessel);
                const voyage = extractVoyage(vessel);
                if (!vesselName && !voyage) continue;
                
                const shipType = vessel.shipCapacity || '';
                const plan = extractPlanDate(vessel);
                const atd = datePart(vessel.atdFormatter || '');
                const eta = extractEtaDate(vessel);
                
                rows.push([
                    clean(odTop.origin || ''),
                    clean(odTop.dest || ''),
                    '', '', '', '', '',
                    clean(vesselName),
                    clean(voyage),
                    clean(shipType),
                    clean(plan),
                    clean(atd),
                    clean(eta),
                    '', ''
                ]);
            } catch (error) {
                if (typeof window !== 'undefined' && typeof window.debugWarn === 'function') {
                    window.debugWarn('Failed to parse vessel object from fallback extraction:', error);
                }
            }
        }
        
        return rows;
    }

    function parseFile(name, html, decodedHtml = null){
        // 优化：如果已经解码过，直接使用，避免重复解码
        const decoded = decodedHtml || extractDecodedPayload(html);
        
        // 提取主要内容
        const mainText = extractMainContent(decoded);

        // 优化：延迟提取可见数据，只在需要验证时才执行
        let visibleData = null; // 延迟初始化

        const labelIndex = buildLabelIndex(mainText);
        const fleets = extractFleetAndVessels(mainText, labelIndex, null);
        const odTop = extractOriginDest(decoded);

        const rows = [];
        // 优化：批量查找共舱船公司，减少重复搜索
        const carrierCache = new Map();
        
        // 处理所有船队数据
        for (const fleet of fleets) {
            // 延迟初始化 visibleData（只在需要时才执行）
            let needsVisibleData = false;
            for (const vessel of fleet.vessels) {
                const vesselName = extractVesselName(vessel);
                const voyage = extractVoyage(vessel);
                const plan = extractPlanDate(vessel);
                const eta = extractEtaDate(vessel);
                if (!vesselName || !voyage || !plan || !eta) {
                    needsVisibleData = true;
                    break;
                }
            }
            
            if (needsVisibleData && visibleData === null) {
                visibleData = extractVisibleScheduleData(html);
            }
            
            const fleetRows = processFleetData(fleet, odTop, carrierCache, decoded, html, visibleData);
            rows.push(...fleetRows);
        }
        
        // 全局兜底：若仍无船期，从整页直接抓取含 vslName 的对象
        if (rows.length === 0) {
            const fallbackRows = extractFallbackVessels(mainText, odTop);
            rows.push(...fallbackRows);
        }
        
        // 注意：补充机制延迟到合并后统一处理，以提高性能
        
        return rows;
    }

    /**
     * 生成数据质量检查报告
     * @param {Array<Array>} merged - 合并后的数据（包含表头）
     * @returns {Object} 质量报告对象
     */
    /**
     * 规范化字符串（去除空格，转大写，用于比较）
     * @param {string} str - 原始字符串
     * @returns {string} 规范化后的字符串
     */
    function normalizeString(str) {
        if (!str) return '';
        return clean(str).replace(/\s+/g, '').toUpperCase();
    }

    function generateQualityReport(merged) {
        const report = {
            hasIssues: false,
            duplicateVesselVoyage: [],
            duplicateVesselVoyageMap: new Map(), // key: normalized, value: {variants: Set, count: number}
            duplicatePodWharf: [],
            duplicatePodWharfMap: new Map(), // key: normalized, value: {variants: Map<variant, count>, totalCount: number}
            duplicateOrigin: [],
            duplicateOriginMap: new Map(), // key: normalized, value: {variants: Map<variant, count>, totalCount: number}
            duplicateDest: [],
            duplicateDestMap: new Map(), // key: normalized, value: {variants: Map<variant, count>, totalCount: number}
            duplicatePolWharf: [],
            duplicatePolWharfMap: new Map(), // key: normalized, value: {variants: Map<variant, count>, totalCount: number}
            missingWeekday: 0,
            missingShipdays: 0,
            missingPlan: 0,
            missingEta: 0,
            missingEtaNotBlank: 0,
            missingPolWharf: 0,
            missingPodWharf: 0,
            podWharfOnlyShort: 0
        };
        
        if (merged.length <= 1) return report;
        
        // 船名航次去空格后的映射（用于检测重复）
        const normalizedVesselVoyageMap = new Map(); // key: normalized, value: {variants: Map<variant, count>, totalCount: number}
        // 目的港码头去空格后的映射（用于检测重复）
        const normalizedPodWharfMap = new Map(); // key: normalized, value: {variants: Map<variant, count>, totalCount: number}
        // 起运港去空格后的映射（用于检测重复）
        const normalizedOriginMap = new Map(); // key: normalized, value: {variants: Map<variant, count>, totalCount: number}
        // 目的港去空格后的映射（用于检测重复）
        const normalizedDestMap = new Map(); // key: normalized, value: {variants: Map<variant, count>, totalCount: number}
        // 起运港码头去空格后的映射（用于检测重复）
        const normalizedPolWharfMap = new Map(); // key: normalized, value: {variants: Map<variant, count>, totalCount: number}
        
        // 统计缺失字段
        for (let i = 1; i < merged.length; i++) {
            const row = merged[i];
            const [
                origin, dest, lineId, portId, weekday, shipdays, carriers,
                vesselName, voyage, shipType, plan, atd, eta, polWharf, podWharf
            ] = row;
            
            // 检查船名航次空格问题
            if (vesselName || voyage) {
                const normalized = normalizeVesselVoyage(vesselName, voyage);
                if (normalized.combinedNormalized) {
                    if (!normalizedVesselVoyageMap.has(normalized.combinedNormalized)) {
                        normalizedVesselVoyageMap.set(normalized.combinedNormalized, {
                            variants: new Map(), // key: variant, value: count
                            totalCount: 0
                        });
                    }
                    const entry = normalizedVesselVoyageMap.get(normalized.combinedNormalized);
                    entry.totalCount++;
                    // 记录所有变体（船名+航次的组合）及其数量
                    const variant = `${vesselName || ''}|${voyage || ''}`;
                    entry.variants.set(variant, (entry.variants.get(variant) || 0) + 1);
                }
            }
            
            // 检查目的港码头空格问题
            if (podWharf) {
                const normalized = normalizePodWharf(podWharf);
                if (normalized) {
                    if (!normalizedPodWharfMap.has(normalized)) {
                        normalizedPodWharfMap.set(normalized, {
                            variants: new Map(), // key: variant, value: count
                            totalCount: 0
                        });
                    }
                    const entry = normalizedPodWharfMap.get(normalized);
                    entry.totalCount++;
                    // 记录所有变体及其数量
                    entry.variants.set(podWharf, (entry.variants.get(podWharf) || 0) + 1);
                }
            }
            
            // 检查起运港空格问题
            if (origin) {
                const normalized = normalizeString(origin);
                if (normalized) {
                    if (!normalizedOriginMap.has(normalized)) {
                        normalizedOriginMap.set(normalized, {
                            variants: new Map(), // key: variant, value: count
                            totalCount: 0
                        });
                    }
                    const entry = normalizedOriginMap.get(normalized);
                    entry.totalCount++;
                    entry.variants.set(origin, (entry.variants.get(origin) || 0) + 1);
                }
            }
            
            // 检查目的港空格问题
            if (dest) {
                const normalized = normalizeString(dest);
                if (normalized) {
                    if (!normalizedDestMap.has(normalized)) {
                        normalizedDestMap.set(normalized, {
                            variants: new Map(), // key: variant, value: count
                            totalCount: 0
                        });
                    }
                    const entry = normalizedDestMap.get(normalized);
                    entry.totalCount++;
                    entry.variants.set(dest, (entry.variants.get(dest) || 0) + 1);
                }
            }
            
            // 检查起运港码头空格问题
            if (polWharf) {
                const normalized = normalizePodWharf(polWharf); // 复用目的港码头的规范化函数
                if (normalized) {
                    if (!normalizedPolWharfMap.has(normalized)) {
                        normalizedPolWharfMap.set(normalized, {
                            variants: new Map(), // key: variant, value: count
                            totalCount: 0
                        });
                    }
                    const entry = normalizedPolWharfMap.get(normalized);
                    entry.totalCount++;
                    entry.variants.set(polWharf, (entry.variants.get(polWharf) || 0) + 1);
                }
            }
            
            // 检查缺失字段
            if (!weekday) report.missingWeekday++;
            if (!shipdays) report.missingShipdays++;
            if (!plan) report.missingPlan++;
            if (!eta) {
                report.missingEta++;
                // 检查是否是非BLANK SAILING
                const isBlankSailing = /BLANK\s*SAILING/i.test(vesselName || '') || 
                                     /BLANK\s*SAILING/i.test(voyage || '');
                if (!isBlankSailing && vesselName && voyage) {
                    report.missingEtaNotBlank++;
                }
            }
            if (!polWharf) report.missingPolWharf++;
            if (!podWharf) report.missingPodWharf++;
            
            // 检查目的港码头是否只有简写（没有全称）
            if (podWharf && !podWharf.includes('/') && podWharf.length < 10) {
                // 可能是只有简写，没有全称
                report.podWharfOnlyShort++;
            }
        }
        
        // 找出重复的船名航次（去空格后相同但原始值不同）
        for (const [normalized, entry] of normalizedVesselVoyageMap.entries()) {
            if (entry.totalCount > 1 && entry.variants.size > 1) {
                // 有多个变体，需要用户选择
                const variants = Array.from(entry.variants.entries()).map(([variant, count]) => {
                    const [vName, vVoyage] = variant.split('|');
                    return { 
                        vesselName: vName, 
                        voyage: vVoyage,
                        count: count
                    };
                });
                // 按数量排序，数量多的在前
                variants.sort((a, b) => b.count - a.count);
                report.duplicateVesselVoyage.push({
                    normalized: normalized,
                    variants: variants,
                    count: entry.totalCount
                });
                report.duplicateVesselVoyageMap.set(normalized, entry);
            }
        }
        
        // 找出重复的目的港码头（去空格后相同但原始值不同）
        for (const [normalized, entry] of normalizedPodWharfMap.entries()) {
            if (entry.totalCount > 1 && entry.variants.size > 1) {
                // 有多个变体，需要用户选择
                const variants = Array.from(entry.variants.entries()).map(([variant, count]) => {
                    return { 
                        podWharf: variant,
                        count: count
                    };
                });
                // 按数量排序，数量多的在前
                variants.sort((a, b) => b.count - a.count);
                report.duplicatePodWharf.push({
                    normalized: normalized,
                    variants: variants,
                    count: entry.totalCount
                });
                report.duplicatePodWharfMap.set(normalized, entry);
            }
        }
        
        // 找出重复的起运港（去空格后相同但原始值不同）
        for (const [normalized, entry] of normalizedOriginMap.entries()) {
            if (entry.totalCount > 1 && entry.variants.size > 1) {
                const variants = Array.from(entry.variants.entries()).map(([variant, count]) => {
                    return { 
                        origin: variant,
                        count: count
                    };
                });
                variants.sort((a, b) => b.count - a.count);
                report.duplicateOrigin.push({
                    normalized: normalized,
                    variants: variants,
                    count: entry.totalCount
                });
                report.duplicateOriginMap.set(normalized, entry);
            }
        }
        
        // 找出重复的目的港（去空格后相同但原始值不同）
        for (const [normalized, entry] of normalizedDestMap.entries()) {
            if (entry.totalCount > 1 && entry.variants.size > 1) {
                const variants = Array.from(entry.variants.entries()).map(([variant, count]) => {
                    return { 
                        dest: variant,
                        count: count
                    };
                });
                variants.sort((a, b) => b.count - a.count);
                report.duplicateDest.push({
                    normalized: normalized,
                    variants: variants,
                    count: entry.totalCount
                });
                report.duplicateDestMap.set(normalized, entry);
            }
        }
        
        // 找出重复的起运港码头（去空格后相同但原始值不同）
        for (const [normalized, entry] of normalizedPolWharfMap.entries()) {
            if (entry.totalCount > 1 && entry.variants.size > 1) {
                const variants = Array.from(entry.variants.entries()).map(([variant, count]) => {
                    return { 
                        polWharf: variant,
                        count: count
                    };
                });
                variants.sort((a, b) => b.count - a.count);
                report.duplicatePolWharf.push({
                    normalized: normalized,
                    variants: variants,
                    count: entry.totalCount
                });
                report.duplicatePolWharfMap.set(normalized, entry);
            }
        }
        
        // 按数量排序
        report.duplicateVesselVoyage.sort((a, b) => b.count - a.count);
        report.duplicatePodWharf.sort((a, b) => b.count - a.count);
        report.duplicateOrigin.sort((a, b) => b.count - a.count);
        report.duplicateDest.sort((a, b) => b.count - a.count);
        report.duplicatePolWharf.sort((a, b) => b.count - a.count);
        
        // 判断是否有问题
        report.hasIssues = report.duplicateVesselVoyage.length > 0 ||
                          report.duplicatePodWharf.length > 0 ||
                          report.duplicateOrigin.length > 0 ||
                          report.duplicateDest.length > 0 ||
                          report.duplicatePolWharf.length > 0 ||
                          report.missingWeekday > 0 ||
                          report.missingShipdays > 0 ||
                          report.missingPlan > 0 ||
                          report.missingEta > 0 ||
                          report.missingPolWharf > 0 ||
                          report.missingPodWharf > 0 ||
                          report.podWharfOnlyShort > 0;
        
        return report;
    }

    /**
     * 显示船名航次标准化模态框
     * @param {Array} duplicateGroups - 重复的船名航次组
     * @returns {Promise<Object>} 返回用户选择的替换映射 {normalized: {vesselName, voyage}}
     */
    function showVesselVoyageModal(duplicateGroups) {
        return new Promise((resolve) => {
            const modal = selectElement('#vesselVoyageModal');
            const list = selectElement('#vesselVoyageList');
            const applyBtn = selectElement('#applyVesselVoyageReplace');
            const skipBtn = selectElement('#skipVesselVoyageReplace');
            
            // 清空列表
            list.innerHTML = '';
            
            // 存储用户选择
            const selections = new Map();
            
            // 为每组重复记录创建选择界面
            duplicateGroups.forEach((group, groupIndex) => {
                const groupDiv = document.createElement('div');
                groupDiv.className = 'vessel-voyage-group';
                
                const title = document.createElement('div');
                title.className = 'vessel-voyage-group-title';
                title.textContent = `第 ${groupIndex + 1} 组（共 ${group.count} 条记录，${group.variants.length} 种格式）：`;
                groupDiv.appendChild(title);
                
                // 找到最短的船名航次组合（作为默认选择）
                let shortestIndex = 0;
                let shortestLength = Infinity;
                group.variants.forEach((variant, idx) => {
                    const totalLength = (variant.vesselName || '').length + (variant.voyage || '').length;
                    if (totalLength < shortestLength) {
                        shortestLength = totalLength;
                        shortestIndex = idx;
                    }
                });
                
                // 为每个变体创建选项
                group.variants.forEach((variant, variantIndex) => {
                    const option = document.createElement('div');
                    option.className = 'vessel-voyage-option';
                    const isShortest = variantIndex === shortestIndex;
                    if (isShortest) {
                        option.classList.add('selected');
                        selections.set(group.normalized, variant);
                    }
                    
                    const radio = document.createElement('input');
                    radio.type = 'radio';
                    radio.name = `vesselVoyageGroup_${groupIndex}`;
                    radio.value = `${variant.vesselName}|${variant.voyage}`;
                    radio.checked = isShortest;
                    radio.addEventListener('change', () => {
                        // 更新选中状态
                        groupDiv.querySelectorAll('.vessel-voyage-option').forEach(opt => {
                            opt.classList.remove('selected');
                        });
                        option.classList.add('selected');
                        selections.set(group.normalized, variant);
                    });
                    
                    const label = document.createElement('label');
                    label.className = 'vessel-voyage-option-label';
                    label.textContent = `"${variant.vesselName || ''}" / "${variant.voyage || ''}"`;
                    
                    const count = document.createElement('span');
                    count.className = 'vessel-voyage-option-count';
                    count.textContent = `(${variant.count} 条)`;
                    
                    option.appendChild(radio);
                    option.appendChild(label);
                    option.appendChild(count);
                    option.addEventListener('click', () => {
                        radio.checked = true;
                        radio.dispatchEvent(new Event('change'));
                    });
                    
                    groupDiv.appendChild(option);
                });
                
                list.appendChild(groupDiv);
            });
            
            // 显示模态框
            modal.classList.remove('hidden');
            
            // 应用按钮
            applyBtn.onclick = () => {
                modal.classList.add('hidden');
                resolve(selections);
            };
            
            // 跳过按钮
            skipBtn.onclick = () => {
                modal.classList.add('hidden');
                resolve(new Map()); // 返回空映射，不进行替换
            };
        });
    }

    /**
     * 应用船名航次替换
     * @param {Array<Array>} merged - 合并后的数据（包含表头）
     * @param {Map} replacements - 替换映射 {normalized: {vesselName, voyage}}
     * @returns {Array<Array>} 替换后的数据
     */
    function applyVesselVoyageReplacements(merged, replacements) {
        if (replacements.size === 0) return merged;
        
        const result = [merged[0]]; // 保留表头
        
        for (let i = 1; i < merged.length; i++) {
            const row = [...merged[i]]; // 复制行
            const vesselName = row[7] || '';
            const voyage = row[8] || '';
            
            const normalized = normalizeVesselVoyage(vesselName, voyage);
            if (normalized.combinedNormalized && replacements.has(normalized.combinedNormalized)) {
                const replacement = replacements.get(normalized.combinedNormalized);
                row[7] = replacement.vesselName;
                row[8] = replacement.voyage;
            }
            
            result.push(row);
        }
        
        return result;
    }

    /**
     * 显示目的港码头标准化模态框
     * @param {Array} duplicateGroups - 重复的目的港码头组
     * @returns {Promise<Object>} 返回用户选择的替换映射 {normalized: podWharf}
     */
    function showPodWharfModal(duplicateGroups) {
        return new Promise((resolve) => {
            const modal = selectElement('#podWharfModal');
            const list = selectElement('#podWharfList');
            const applyBtn = selectElement('#applyPodWharfReplace');
            const skipBtn = selectElement('#skipPodWharfReplace');
            
            // 清空列表
            list.innerHTML = '';
            
            // 存储用户选择
            const selections = new Map();
            
            // 为每组重复记录创建选择界面
            duplicateGroups.forEach((group, groupIndex) => {
                const groupDiv = document.createElement('div');
                groupDiv.className = 'vessel-voyage-group';
                
                const title = document.createElement('div');
                title.className = 'vessel-voyage-group-title';
                title.textContent = `第 ${groupIndex + 1} 组（共 ${group.count} 条记录，${group.variants.length} 种格式）：`;
                groupDiv.appendChild(title);
                
                // 找到最短的目的港码头（作为默认选择）
                let shortestIndex = 0;
                let shortestLength = Infinity;
                group.variants.forEach((variant, idx) => {
                    const length = (variant.podWharf || '').length;
                    if (length < shortestLength) {
                        shortestLength = length;
                        shortestIndex = idx;
                    }
                });
                
                // 为每个变体创建选项
                group.variants.forEach((variant, variantIndex) => {
                    const option = document.createElement('div');
                    option.className = 'vessel-voyage-option';
                    const isShortest = variantIndex === shortestIndex;
                    if (isShortest) {
                        option.classList.add('selected');
                        selections.set(group.normalized, variant.podWharf);
                    }
                    
                    const radio = document.createElement('input');
                    radio.type = 'radio';
                    radio.name = `podWharfGroup_${groupIndex}`;
                    radio.value = variant.podWharf;
                    radio.checked = isShortest;
                    radio.addEventListener('change', () => {
                        // 更新选中状态
                        groupDiv.querySelectorAll('.vessel-voyage-option').forEach(opt => {
                            opt.classList.remove('selected');
                        });
                        option.classList.add('selected');
                        selections.set(group.normalized, variant.podWharf);
                    });
                    
                    const label = document.createElement('label');
                    label.className = 'vessel-voyage-option-label';
                    label.textContent = variant.podWharf || '';
                    
                    const count = document.createElement('span');
                    count.className = 'vessel-voyage-option-count';
                    count.textContent = `(${variant.count} 条)`;
                    
                    option.appendChild(radio);
                    option.appendChild(label);
                    option.appendChild(count);
                    option.addEventListener('click', () => {
                        radio.checked = true;
                        radio.dispatchEvent(new Event('change'));
                    });
                    
                    groupDiv.appendChild(option);
                });
                
                list.appendChild(groupDiv);
            });
            
            // 显示模态框
            modal.classList.remove('hidden');
            
            // 应用按钮
            applyBtn.onclick = () => {
                modal.classList.add('hidden');
                resolve(selections);
            };
            
            // 跳过按钮
            skipBtn.onclick = () => {
                modal.classList.add('hidden');
                resolve(new Map()); // 返回空映射，不进行替换
            };
        });
    }

    /**
     * 应用目的港码头替换
     * @param {Array<Array>} merged - 合并后的数据（包含表头）
     * @param {Map} replacements - 替换映射 {normalized: podWharf}
     * @returns {Array<Array>} 替换后的数据
     */
    function applyPodWharfReplacements(merged, replacements) {
        if (replacements.size === 0) return merged;
        
        const result = [merged[0]]; // 保留表头
        
        for (let i = 1; i < merged.length; i++) {
            const row = [...merged[i]]; // 复制行
            const podWharf = row[14] || '';
            
            const normalized = normalizePodWharf(podWharf);
            if (normalized && replacements.has(normalized)) {
                const replacement = replacements.get(normalized);
                row[14] = replacement;
            }
            
            result.push(row);
        }
        
        return result;
    }

    /**
     * 通用标准化模态框显示函数
     * @param {Array} duplicateGroups - 重复的组
     * @param {string} fieldName - 字段名（origin/dest/polWharf）
     * @param {string} fieldLabel - 字段标签（起运港/目的港/起运港码头）
     * @returns {Promise<Map>} 返回用户选择的替换映射 {normalized: value}
     */
    function showStandardizationModal(duplicateGroups, fieldName, fieldLabel) {
        return new Promise((resolve) => {
            const modalId = `standardizationModal_${fieldName}`;
            const listId = `standardizationList_${fieldName}`;
            const applyBtnId = `applyStandardization_${fieldName}`;
            const skipBtnId = `skipStandardization_${fieldName}`;
            
            // 创建模态框（如果不存在）
            let modal = document.getElementById(modalId);
            if (!modal) {
                modal = document.createElement('div');
                modal.id = modalId;
                modal.className = 'vessel-voyage-modal hidden';
                modal.innerHTML = `
                    <div class="vessel-voyage-modal-content">
                        <div class="vessel-voyage-modal-header">
                            <h2>🔍 ${fieldLabel}标准化</h2>
                            <p>发现以下${fieldLabel}去空格后相同但格式不同，请为每组选择一个标准格式：</p>
                        </div>
                        <div id="${listId}" class="vessel-voyage-list"></div>
                        <div class="vessel-voyage-modal-footer">
                            <button id="${applyBtnId}" class="btn btn-primary">应用替换并继续</button>
                            <button id="${skipBtnId}" class="btn btn-secondary">跳过（保留原值）</button>
                        </div>
                    </div>
                `;
                document.getElementById('standardizationModalsContainer').appendChild(modal);
            }
            
            const list = document.getElementById(listId);
            const applyBtn = document.getElementById(applyBtnId);
            const skipBtn = document.getElementById(skipBtnId);
            
            // 清空列表
            list.innerHTML = '';
            
            // 存储用户选择
            const selections = new Map();
            
            // 为每组重复记录创建选择界面
            duplicateGroups.forEach((group, groupIndex) => {
                const groupDiv = document.createElement('div');
                groupDiv.className = 'vessel-voyage-group';
                
                const title = document.createElement('div');
                title.className = 'vessel-voyage-group-title';
                title.textContent = `第 ${groupIndex + 1} 组（共 ${group.count} 条记录，${group.variants.length} 种格式）：`;
                groupDiv.appendChild(title);
                
                // 找到最短的（作为默认选择）
                let shortestIndex = 0;
                let shortestLength = Infinity;
                group.variants.forEach((variant, idx) => {
                    const value = variant[fieldName] || variant.origin || variant.dest || variant.polWharf || '';
                    const length = value.length;
                    if (length < shortestLength) {
                        shortestLength = length;
                        shortestIndex = idx;
                    }
                });
                
                // 为每个变体创建选项
                group.variants.forEach((variant, variantIndex) => {
                    const option = document.createElement('div');
                    option.className = 'vessel-voyage-option';
                    const isShortest = variantIndex === shortestIndex;
                    const value = variant[fieldName] || variant.origin || variant.dest || variant.polWharf || '';
                    
                    if (isShortest) {
                        option.classList.add('selected');
                        selections.set(group.normalized, value);
                    }
                    
                    const radio = document.createElement('input');
                    radio.type = 'radio';
                    radio.name = `${fieldName}Group_${groupIndex}`;
                    radio.value = value;
                    radio.checked = isShortest;
                    radio.addEventListener('change', () => {
                        groupDiv.querySelectorAll('.vessel-voyage-option').forEach(opt => {
                            opt.classList.remove('selected');
                        });
                        option.classList.add('selected');
                        selections.set(group.normalized, value);
                    });
                    
                    const label = document.createElement('label');
                    label.className = 'vessel-voyage-option-label';
                    label.textContent = value || '';
                    
                    const count = document.createElement('span');
                    count.className = 'vessel-voyage-option-count';
                    count.textContent = `(${variant.count} 条)`;
                    
                    option.appendChild(radio);
                    option.appendChild(label);
                    option.appendChild(count);
                    option.addEventListener('click', () => {
                        radio.checked = true;
                        radio.dispatchEvent(new Event('change'));
                    });
                    
                    groupDiv.appendChild(option);
                });
                
                list.appendChild(groupDiv);
            });
            
            // 显示模态框
            modal.classList.remove('hidden');
            
            // 应用按钮
            applyBtn.onclick = () => {
                modal.classList.add('hidden');
                resolve(selections);
            };
            
            // 跳过按钮
            skipBtn.onclick = () => {
                modal.classList.add('hidden');
                resolve(new Map());
            };
        });
    }

    /**
     * 通用标准化替换函数
     * @param {Array<Array>} merged - 合并后的数据（包含表头）
     * @param {Map} replacements - 替换映射 {normalized: value}
     * @param {number} fieldIndex - 字段索引（0=起运港, 1=目的港, 13=起运港码头）
     * @param {Function} normalizeFn - 规范化函数
     * @returns {Array<Array>} 替换后的数据
     */
    function applyStandardizationReplacements(merged, replacements, fieldIndex, normalizeFn) {
        if (replacements.size === 0) return merged;
        
        const result = [merged[0]]; // 保留表头
        
        for (let i = 1; i < merged.length; i++) {
            const row = [...merged[i]]; // 复制行
            const value = row[fieldIndex] || '';
            
            const normalized = normalizeFn ? normalizeFn(value) : normalizeString(value);
            if (normalized && replacements.has(normalized)) {
                const replacement = replacements.get(normalized);
                row[fieldIndex] = replacement;
            }
            
            result.push(row);
        }
        
        return result;
    }

    /**
     * 渲染预览表格 - 使用 parser-utils.js 中的函数
     * @param {Array<Array>} rows - 行数据数组
     */
    function renderPreviewLocal(rows) {
        const headers = [
            '启运港', '目的港', '航线ID', '港口ID', '开航日', '航程', '共舱船公司',
            '船名', '航次', '船型', '计划开航', '实际离港', '预计到港', '启运港码头', '目的港码头'
        ];
        renderPreview(rows, '#preview', '#table', headers, 50);
    }

    const picker = selectElement('#picker');
    const runBtn = selectElement('#run');
    const downloadBtn = selectElement('#download');
    const summary = selectElement('#summary');
    const logBox = selectElement('#log');
    let files = [];
    let output = [];

    picker.addEventListener('change', () => {
        if (logBox) logBox.innerHTML = '';
        output = [];
        summary.textContent = '';
        files = Array.from(picker.files)
            .filter(file => /\.html?$/i.test(file.name))
            .sort((a, b) => a.name.localeCompare(b.name));
        if (!files.length) {
            log('未选择到 HTML 文件，请重新选择 view-full。', '#b00020');
            runBtn.disabled = true;
            downloadBtn.disabled = true;
            return;
        }
        log(`已选择 ${files.length} 个 HTML 文件。`, '#0a7d33');
        runBtn.disabled = false;
        downloadBtn.disabled = true;
        const preview = selectElement('#preview');
        if (preview) preview.classList.add('hidden');
    });

    runBtn.addEventListener('click', async () => {
        runBtn.disabled = true;
        downloadBtn.disabled = true;
        output = [];
        const preview = selectElement('#preview');
        if (preview) preview.classList.add('hidden');
        const header = [
            '启运港', '目的港', '航线ID', '港口ID', '开航日', '航程', '共舱船公司',
            '船名', '航次', '船型', '计划开航', '实际离港', '预计到港', '启运港码头', '目的港码头'
        ];
        const rows = [header];
        const htmlCache = new Map(); // 缓存解码后的HTML内容（key: 行索引, value: 解码后的HTML）
        const originalHtmlCache = new Map(); // 缓存原始HTML内容（key: 行索引, value: 原始HTML）
        // 建立基于航线ID+港口ID的全局HTML映射（用于补充机制）
        const linePortHtmlGlobalMap = new Map(); // key: `${lineId}_${portId}`, value: Array<{decodedHtml, originalHtml}>
        let ok = 0;
        let warn = 0;
        for (const file of files) {
            try {
                const html = await file.text();
                // 优化：先解码一次，然后传递给 parseFile，避免重复解码
                const decodedHtml = extractDecodedPayload(html);
                const parsedRows = parseFile(file.name, html, decodedHtml);
                if (!parsedRows.length) {
                    warn++;
                    log(`[无船期] ${file.name}`, '#b36b00');
                } else {
                    ok++;
                    log(`[OK] ${file.name} -> ${parsedRows.length} 行`, '#0a7d33');
                    // 缓存解码后的HTML和原始HTML，避免重复解码
                    const startIndex = rows.length;
                    for (let j = 0; j < parsedRows.length; j++) {
                        const row = parsedRows[j];
                        if (row.length > 0 && row[0] !== '启运港') { // 跳过表头
                            htmlCache.set(startIndex + j, decodedHtml); // 存储解码后的HTML
                            originalHtmlCache.set(startIndex + j, html); // 存储原始HTML
                            
                            // 建立基于航线ID+港口ID的全局HTML映射
                            const lineId = row[2] || ''; // 航线ID
                            const portId = row[3] || ''; // 港口ID
                            if (lineId && portId) {
                                const linePortKey = `${lineId}_${portId}`;
                                if (!linePortHtmlGlobalMap.has(linePortKey)) {
                                    linePortHtmlGlobalMap.set(linePortKey, []);
                                }
                                const htmlList = linePortHtmlGlobalMap.get(linePortKey);
                                // 避免重复添加相同的HTML
                                const htmlExists = htmlList.some(h => h.decodedHtml === decodedHtml);
                                if (!htmlExists) {
                                    htmlList.push({
                                        decodedHtml: decodedHtml,
                                        originalHtml: html
                                    });
                                }
                            }
                        }
                    }
                    rows.push(...parsedRows);
                }
            } catch (error) {
                warn++;
                const errorMessage = error && error.message ? error.message : error;
                log(`[失败] ${file.name}: ${errorMessage}`, '#b00020');
            }
        }
        // 去重合并：键 = 启运港 + 目的港 + 航线ID + 港口ID + 船名 + 航次；共舱船公司合并去重
        const deduplicationMap = new Map();
        const mergedHtmlCache = new Map(); // 存储合并后记录的HTML引用（key: 合并后的key, value: 解码后的HTML）
        const mergedOriginalHtmlCache = new Map(); // 存储合并后记录的原始HTML引用（key: 合并后的key, value: 原始HTML）
        for (let i = 1; i < rows.length; i++) {
            const [
                origin,
                dest,
                lineId,
                portId,
                weekday,
                shipdays,
                carriers,
                vesselName,
                voyage,
                shipType,
                plan,
                atd,
                eta,
                polWharf,
                podWharf
            ] = rows[i].map(clean);
            
            const key = [origin, dest, lineId, portId, vesselName, voyage].join('|');
            if (!deduplicationMap.has(key)) {
                deduplicationMap.set(key, [
                    origin,
                    dest,
                    lineId,
                    portId,
                    weekday,
                    shipdays,
                    carriers,
                    vesselName,
                    voyage,
                    shipType,
                    plan,
                    atd,
                    eta,
                    polWharf,
                    podWharf
                ]);
                // 保存解码后的HTML和原始HTML引用
                if (htmlCache.has(i)) {
                    mergedHtmlCache.set(key, htmlCache.get(i));
                }
                if (originalHtmlCache.has(i)) {
                    mergedOriginalHtmlCache.set(key, originalHtmlCache.get(i));
                }
            } else {
                const existing = deduplicationMap.get(key);
                // 合并开航日/航程（保留已有，若空则补）
                if (!existing[4] && weekday) existing[4] = weekday;
                if (!existing[5] && shipdays) existing[5] = shipdays;
                // 共舱：按需求使用 <a title> 的文本，不再拼接合并；优先保留已存在的非空值
                if (!existing[6] && carriers) existing[6] = carriers;
                // 补充缺失的关键字段：船名、航次、计划开航、预计到港、目的港码头
                if (!existing[7] && vesselName) existing[7] = vesselName;
                if (!existing[8] && voyage) existing[8] = voyage;
                if (!existing[10] && plan) existing[10] = plan;
                if (!existing[12] && eta) existing[12] = eta;
                if (!existing[14] && podWharf) existing[14] = podWharf;
                // 其他字段以首条为准，如ATD/启运港码头一般一致
                // 如果当前行有HTML引用但已有记录没有，则保存（优先使用有更多数据的记录）
                if (htmlCache.has(i) && !mergedHtmlCache.has(key)) {
                    mergedHtmlCache.set(key, htmlCache.get(i));
                }
                if (originalHtmlCache.has(i) && !mergedOriginalHtmlCache.has(key)) {
                    mergedOriginalHtmlCache.set(key, originalHtmlCache.get(i));
                }
            }
        }
        const merged = [header, ...Array.from(deduplicationMap.values())];
        
        // 合并后的补充机制：对仍然缺失的字段进行补充（增强：放宽条件，支持从多个来源补充）
        // 使用全局HTML映射，确保能够从所有相同航线ID+港口ID的HTML中查找
        const needSupplement = [];
        for (let i = 1; i < merged.length; i++) {
            const row = merged[i];
            const [
                origin, dest, lineId, portId, weekday, shipdays, carriers,
                vesselName, voyage, shipType, plan, atd, eta, polWharf, podWharf
            ] = row;
            
            // 放宽条件：即使只有单个字段缺失也应该尝试补充
            // 检查目的港码头是否只有简写（没有/分隔符且长度较短）
            const podWharfOnlyShort = podWharf && !podWharf.includes('/') && podWharf.length < 15;
            
            const missing = {
                vesselName: !vesselName,
                voyage: !voyage,
                plan: !plan,
                eta: !eta,
                weekday: !weekday,
                shipdays: !shipdays,
                polWharf: !polWharf,
                podWharf: !podWharf || podWharfOnlyShort // 如果只有简写，也算缺失
            };
            
            // 检查是否有任何字段缺失
            const hasAnyMissing = Object.values(missing).some(v => v);
            
            // 只要有缺失字段且有航线ID和港口ID，就尝试补充
            if (hasAnyMissing && lineId && portId) {
                const rowKey = [origin, dest, lineId, portId, vesselName, voyage].join('|');
                // 优先使用该记录的HTML
                let decodedHtml = mergedHtmlCache.get(rowKey);
                let originalHtml = mergedOriginalHtmlCache.get(rowKey);
                
                // 如果没有该记录的HTML，从全局HTML映射中查找相同航线ID+港口ID的HTML
                if (!decodedHtml && !originalHtml) {
                    const linePortKey = `${lineId}_${portId}`;
                    const htmlList = linePortHtmlGlobalMap.get(linePortKey);
                    if (htmlList && htmlList.length > 0) {
                        // 使用第一个可用的HTML（通常这些HTML都包含相同航线ID+港口ID的信息）
                        decodedHtml = htmlList[0].decodedHtml;
                        originalHtml = htmlList[0].originalHtml;
                    }
                }
                
                // 只要有HTML（无论是该记录的还是相同航线ID+港口ID的），就尝试补充
                if (decodedHtml || originalHtml) {
                    needSupplement.push({
                        row: row,
                        rowKey: rowKey,
                        lineId: lineId,
                        portId: portId,
                        decodedHtml: decodedHtml,
                        originalHtml: originalHtml,
                        missing: missing
                    });
                }
            }
        }
        
        // 批量补充：使用缓存的解码HTML，避免重复解码（增强：支持从多个来源补充）
        if (needSupplement.length > 0) {
            log(`正在补充 ${needSupplement.length} 条缺失数据...`, '#0a7d33');
            // 优化：按HTML文件分组，减少重复的visibleData提取
            const htmlToVisibleData = new Map(); // key: HTML内容的key, value: visibleData Map
            
            // 先建立HTML到visibleData的映射（包括所有可能用到的HTML源）
            const allHtmlSources = new Set();
            for (const item of needSupplement) {
                // 添加该记录的HTML
                if (item.originalHtml || item.decodedHtml) {
                    allHtmlSources.add(item.originalHtml || item.decodedHtml);
                }
                // 添加相同航线ID+港口ID的所有HTML
                const linePortKey = `${item.lineId}_${item.portId}`;
                const htmlList = linePortHtmlGlobalMap.get(linePortKey) || [];
                for (const htmlItem of htmlList) {
                    if (htmlItem.originalHtml || htmlItem.decodedHtml) {
                        allHtmlSources.add(htmlItem.originalHtml || htmlItem.decodedHtml);
                    }
                }
            }
            
            // 为所有HTML源提取visibleData
            for (const htmlForExtraction of allHtmlSources) {
                if (htmlForExtraction) {
                    const htmlKey = htmlForExtraction.substring(0, 1000);
                    if (!htmlToVisibleData.has(htmlKey)) {
                        // 检查是否有需要visibleData的记录
                        const needsVisibleData = Array.from(needSupplement).some(item => 
                            item.missing.plan || item.missing.podWharf
                        );
                        if (needsVisibleData) {
                            const visibleData = extractVisibleScheduleData(htmlForExtraction);
                            htmlToVisibleData.set(htmlKey, visibleData);
                        } else {
                            htmlToVisibleData.set(htmlKey, null);
                        }
                    }
                }
            }
            
            // 批量补充（增强：尝试多个HTML源）
            let supplementedCount = 0;
            for (const item of needSupplement) {
                let decodedHtml = item.decodedHtml;
                let originalHtml = item.originalHtml;
                
                // 如果第一个HTML没有找到所有缺失的数据，尝试从其他相同航线ID+港口ID的HTML中查找
                const linePortKey = `${item.lineId}_${item.portId}`;
                const htmlList = linePortHtmlGlobalMap.get(linePortKey) || [];
                let htmlIndex = 0;
                
                // 记录当前缺失的字段
                const stillMissing = {...item.missing};
                
                // 尝试多个HTML源，直到找到所有缺失的数据或尝试完所有HTML
                while (htmlIndex < htmlList.length + 1) {
                    if (decodedHtml || originalHtml) {
                        const htmlForExtraction = originalHtml || decodedHtml;
                        const htmlKey = htmlForExtraction ? htmlForExtraction.substring(0, 1000) : null;
                        // 获取visibleData，如果没有则尝试提取
                        let visibleData = htmlKey ? htmlToVisibleData.get(htmlKey) : null;
                        if (visibleData === undefined && htmlForExtraction) {
                            // 如果还没有提取过，现在提取
                            const needsVisibleData = stillMissing.plan || stillMissing.podWharf;
                            if (needsVisibleData) {
                                visibleData = extractVisibleScheduleData(htmlForExtraction);
                                if (htmlKey) {
                                    htmlToVisibleData.set(htmlKey, visibleData);
                                }
                            } else {
                                visibleData = null;
                                if (htmlKey) {
                                    htmlToVisibleData.set(htmlKey, null);
                                }
                            }
                        }
                        
                        const supplemented = supplementMissingData(decodedHtml || originalHtml, item.lineId, item.portId, {
                            vesselName: item.row[7] || '',
                            voyage: item.row[8] || '',
                            plan: item.row[10] || '',
                            eta: item.row[12] || '',
                            weekday: item.row[4] || '',
                            shipdays: item.row[5] || '',
                            polWharf: item.row[13] || '',
                            podWharf: item.row[14] || ''
                        }, visibleData);
                        
                        let hasUpdate = false;
                        // 只更新仍然缺失的字段
                        if (stillMissing.vesselName && supplemented.vesselName) {
                            item.row[7] = clean(supplemented.vesselName);
                            stillMissing.vesselName = false;
                            hasUpdate = true;
                        }
                        if (stillMissing.voyage && supplemented.voyage) {
                            item.row[8] = clean(supplemented.voyage);
                            stillMissing.voyage = false;
                            hasUpdate = true;
                        }
                        if (stillMissing.plan && supplemented.plan) {
                            item.row[10] = clean(supplemented.plan);
                            stillMissing.plan = false;
                            hasUpdate = true;
                        }
                        if (stillMissing.eta && supplemented.eta) {
                            item.row[12] = clean(supplemented.eta);
                            stillMissing.eta = false;
                            hasUpdate = true;
                        }
                        if (stillMissing.weekday && supplemented.weekday) {
                            item.row[4] = clean(supplemented.weekday);
                            stillMissing.weekday = false;
                            hasUpdate = true;
                        }
                        if (stillMissing.shipdays && supplemented.shipdays) {
                            item.row[5] = clean(supplemented.shipdays);
                            stillMissing.shipdays = false;
                            hasUpdate = true;
                        }
                        if (stillMissing.polWharf && supplemented.polWharf) {
                            item.row[13] = clean(supplemented.polWharf);
                            stillMissing.polWharf = false;
                            hasUpdate = true;
                        }
                        if (stillMissing.podWharf && supplemented.podWharf) {
                            // 如果原值只有简写，新值有简写+全称，使用新值；否则使用新值
                            const currentPodWharf = item.row[14] || '';
                            const newPodWharf = clean(supplemented.podWharf);
                            if (newPodWharf.includes('/') || !currentPodWharf) {
                                item.row[14] = newPodWharf;
                                stillMissing.podWharf = false;
                                hasUpdate = true;
                            } else if (currentPodWharf && !currentPodWharf.includes('/') && newPodWharf && !newPodWharf.includes('/')) {
                                // 如果都是简写，使用新值（可能更准确）
                                item.row[14] = newPodWharf;
                                stillMissing.podWharf = false;
                                hasUpdate = true;
                            }
                        }
                        
                        if (hasUpdate) {
                            supplementedCount++;
                        }
                        
                        // 如果所有缺失的字段都已补充，提前退出
                        if (!Object.values(stillMissing).some(v => v)) {
                            break;
                        }
                    }
                    
                    // 尝试下一个HTML源
                    if (htmlIndex < htmlList.length) {
                        decodedHtml = htmlList[htmlIndex].decodedHtml;
                        originalHtml = htmlList[htmlIndex].originalHtml;
                        htmlIndex++;
                    } else {
                        break;
                    }
                }
            }
            
            if (supplementedCount > 0) {
                log(`✅ 已补充 ${supplementedCount} 条记录的缺失字段`, '#0a7d33');
            }
        }
        // 移除跨页面的目的港码头补全逻辑，避免补到不是该港口的目的港
        // 目的港码头的补全应该在当页完成（在processFleetData中）

        // 数据质量检查报告
        const qualityReport = generateQualityReport(merged);
        
        // 处理船名航次和目的港码头的标准化（按顺序处理）
        const processStandardization = async (currentMerged, currentReport) => {
            let processedMerged = currentMerged;
            let processedReport = currentReport;
            
            // 第一步：处理船名航次标准化
            if (processedReport.duplicateVesselVoyage.length > 0) {
                log(`\n🔍 发现 ${processedReport.duplicateVesselVoyage.length} 组可能重复的船名航次（空格差异），请选择标准格式...`, '#0a7d33');
                
                const replacements = await showVesselVoyageModal(processedReport.duplicateVesselVoyage);
                if (replacements.size > 0) {
                    log(`正在应用船名航次标准化替换...`, '#0a7d33');
                    processedMerged = applyVesselVoyageReplacements(processedMerged, replacements);
                    processedReport = generateQualityReport(processedMerged);
                    log(`\n✅ 已应用 ${replacements.size} 组船名航次标准化`, '#0a7d33');
                } else {
                    log(`\n⏭️ 已跳过船名航次标准化，保留原值`, '#666');
                }
            }
            
            // 第二步：处理目的港码头标准化
            if (processedReport.duplicatePodWharf.length > 0) {
                log(`\n🔍 发现 ${processedReport.duplicatePodWharf.length} 组可能重复的目的港码头（空格差异），请选择标准格式...`, '#0a7d33');
                
                const podWharfReplacements = await showPodWharfModal(processedReport.duplicatePodWharf);
                if (podWharfReplacements.size > 0) {
                    log(`正在应用目的港码头标准化替换...`, '#0a7d33');
                    processedMerged = applyPodWharfReplacements(processedMerged, podWharfReplacements);
                    processedReport = generateQualityReport(processedMerged);
                    log(`\n✅ 已应用 ${podWharfReplacements.size} 组目的港码头标准化`, '#0a7d33');
                } else {
                    log(`\n⏭️ 已跳过目的港码头标准化，保留原值`, '#666');
                }
            }
            
            // 第三步：处理起运港标准化
            if (processedReport.duplicateOrigin.length > 0) {
                log(`\n🔍 发现 ${processedReport.duplicateOrigin.length} 组可能重复的起运港（空格差异），请选择标准格式...`, '#0a7d33');
                
                const originReplacements = await showStandardizationModal(processedReport.duplicateOrigin, 'origin', '起运港');
                if (originReplacements.size > 0) {
                    log(`正在应用起运港标准化替换...`, '#0a7d33');
                    processedMerged = applyStandardizationReplacements(processedMerged, originReplacements, 0, normalizeString);
                    processedReport = generateQualityReport(processedMerged);
                    log(`\n✅ 已应用 ${originReplacements.size} 组起运港标准化`, '#0a7d33');
                } else {
                    log(`\n⏭️ 已跳过起运港标准化，保留原值`, '#666');
                }
            }
            
            // 第四步：处理目的港标准化
            if (processedReport.duplicateDest.length > 0) {
                log(`\n🔍 发现 ${processedReport.duplicateDest.length} 组可能重复的目的港（空格差异），请选择标准格式...`, '#0a7d33');
                
                const destReplacements = await showStandardizationModal(processedReport.duplicateDest, 'dest', '目的港');
                if (destReplacements.size > 0) {
                    log(`正在应用目的港标准化替换...`, '#0a7d33');
                    processedMerged = applyStandardizationReplacements(processedMerged, destReplacements, 1, normalizeString);
                    processedReport = generateQualityReport(processedMerged);
                    log(`\n✅ 已应用 ${destReplacements.size} 组目的港标准化`, '#0a7d33');
                } else {
                    log(`\n⏭️ 已跳过目的港标准化，保留原值`, '#666');
                }
            }
            
            // 第五步：处理起运港码头标准化
            if (processedReport.duplicatePolWharf.length > 0) {
                log(`\n🔍 发现 ${processedReport.duplicatePolWharf.length} 组可能重复的起运港码头（空格差异），请选择标准格式...`, '#0a7d33');
                
                const polWharfReplacements = await showStandardizationModal(processedReport.duplicatePolWharf, 'polWharf', '起运港码头');
                if (polWharfReplacements.size > 0) {
                    log(`正在应用起运港码头标准化替换...`, '#0a7d33');
                    processedMerged = applyStandardizationReplacements(processedMerged, polWharfReplacements, 13, normalizePodWharf);
                    processedReport = generateQualityReport(processedMerged);
                    log(`\n✅ 已应用 ${polWharfReplacements.size} 组起运港码头标准化`, '#0a7d33');
                } else {
                    log(`\n⏭️ 已跳过起运港码头标准化，保留原值`, '#666');
                }
            }
            
            return { merged: processedMerged, report: processedReport };
        };
        
        // 执行标准化处理
        processStandardization(merged, qualityReport).then(({ merged: standardizedMerged, report: standardizedReport }) => {
            // 第三步：按目的港+航线ID+船名+航次进行去重合并
            log(`\n🔄 正在进行去重合并（目的港+航线ID+船名+航次）...`, '#0a7d33');
            const finalDeduplicationMap = new Map();
            const beforeCount = standardizedMerged.length - 1; // 排除表头
            
            for (let i = 1; i < standardizedMerged.length; i++) {
                const row = standardizedMerged[i];
                const [
                    origin,
                    dest,
                    lineId,
                    portId,
                    weekday,
                    shipdays,
                    carriers,
                    vesselName,
                    voyage,
                    shipType,
                    plan,
                    atd,
                    eta,
                    polWharf,
                    podWharf
                ] = row.map(clean);
                
                // 新的去重键：目的港 + 航线ID + 船名 + 航次
                const dedupKey = [dest, lineId, vesselName, voyage].join('|');
                
                if (!finalDeduplicationMap.has(dedupKey)) {
                    // 首次出现，直接添加
                    finalDeduplicationMap.set(dedupKey, [
                        origin,
                        dest,
                        lineId,
                        portId,
                        weekday,
                        shipdays,
                        carriers,
                        vesselName,
                        voyage,
                        shipType,
                        plan,
                        atd,
                        eta,
                        polWharf,
                        podWharf
                    ]);
                } else {
                    // 已存在，合并数据（保留更完整的记录）
                    const existing = finalDeduplicationMap.get(dedupKey);
                    
                    // 合并启运港：如果新记录的启运港不同，保留已有的（或选择更完整的）
                    // 合并港口ID：保留已有的
                    // 合并开航日/航程（保留已有，若空则补）
                    if (!existing[4] && weekday) existing[4] = weekday;
                    if (!existing[5] && shipdays) existing[5] = shipdays;
                    // 共舱：优先保留已存在的非空值
                    if (!existing[6] && carriers) existing[6] = carriers;
                    // 补充缺失的关键字段：计划开航、预计到港、目的港码头
                    if (!existing[10] && plan) existing[10] = plan;
                    if (!existing[12] && eta) existing[12] = eta;
                    if (!existing[14] && podWharf) existing[14] = podWharf;
                    // 启运港码头：如果新记录有而旧记录没有，则补充
                    if (!existing[13] && polWharf) existing[13] = polWharf;
                    // 船型：保留已有的
                    // 实际离港：保留已有的
                }
            }
            
            const finalMerged = [header, ...Array.from(finalDeduplicationMap.values())];
            const afterCount = finalMerged.length - 1; // 排除表头
            const mergedCount = beforeCount - afterCount;
            
            if (mergedCount > 0) {
                log(`✅ 去重完成：合并了 ${mergedCount} 条重复记录（从 ${beforeCount} 条减少到 ${afterCount} 条）`, '#0a7d33');
            }
            
            // 重新生成质量报告
            const finalReport = generateQualityReport(finalMerged);
            
            output = finalMerged;
            displayQualityReport(finalReport, true);
            renderPreviewLocal(finalMerged.slice(1));
            downloadBtn.disabled = finalMerged.length <= 1;
            summary.textContent = `完成：${ok} 文件，${warn} 提醒，合并后 ${finalMerged.length - 1} 条。`;
        });
    });

    /**
     * 显示数据质量检查报告
     * @param {Object} qualityReport - 质量报告对象
     * @param {boolean} skipDuplicates - 是否跳过重复船名航次的显示（因为已经处理过了）
     */
    function displayQualityReport(qualityReport, skipDuplicates = false) {
        if (qualityReport.hasIssues) {
            log(`\n📊 数据质量检查报告：`, '#0a7d33');
            if (!skipDuplicates && qualityReport.duplicateVesselVoyage.length > 0) {
                log(`⚠️ 发现 ${qualityReport.duplicateVesselVoyage.length} 组可能重复的船名航次（空格差异）`, '#b36b00');
            }
            if (!skipDuplicates && qualityReport.duplicatePodWharf.length > 0) {
                log(`⚠️ 发现 ${qualityReport.duplicatePodWharf.length} 组可能重复的目的港码头（空格差异）`, '#b36b00');
            }
            if (qualityReport.missingWeekday > 0) {
                log(`⚠️ 缺失开航日：${qualityReport.missingWeekday} 条`, '#b36b00');
            }
            if (qualityReport.missingShipdays > 0) {
                log(`⚠️ 缺失航程：${qualityReport.missingShipdays} 条`, '#b36b00');
            }
            if (qualityReport.missingPlan > 0) {
                log(`⚠️ 缺失计划开航：${qualityReport.missingPlan} 条`, '#b36b00');
            }
            if (qualityReport.missingEta > 0) {
                log(`⚠️ 缺失预计到港：${qualityReport.missingEta} 条（其中 ${qualityReport.missingEtaNotBlank} 条非BLANK SAILING）`, '#b36b00');
            }
            if (qualityReport.missingPolWharf > 0) {
                log(`⚠️ 缺失启运港码头：${qualityReport.missingPolWharf} 条`, '#b36b00');
            }
            if (qualityReport.missingPodWharf > 0) {
                log(`⚠️ 缺失目的港码头：${qualityReport.missingPodWharf} 条`, '#b36b00');
            }
            if (qualityReport.podWharfOnlyShort > 0) {
                log(`⚠️ 目的港码头只有简写（缺少全称）：${qualityReport.podWharfOnlyShort} 条`, '#b36b00');
            }
        } else {
            log(`\n✅ 数据质量检查通过，未发现明显问题`, '#0a7d33');
        }
    }

    downloadBtn.addEventListener('click', () => {
        if (!output || output.length <= 1) return;
        const csv = '\uFEFF' + rowsToCsv(output);
        downloadBlob(csv, generateTimestampFilename('weiyun-schedule'), 'text/csv;charset=utf-8');
    });
})();
    </script>
</body>
</html>
