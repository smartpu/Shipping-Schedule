<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Market Watch Â· å¸‚åœºè§‚å¯Ÿ</title>
    <link rel="stylesheet" href="vendor/auth.css">
    <link rel="stylesheet" href="vendor/common-styles.css">
    <link rel="stylesheet" href="vendor/market-analysis-styles.css">
    <script src="vendor/lib-loader.js"></script>
    <script src="vendor/common-utils.js"></script>
    <script src="vendor/date-utils.js"></script>
    <script src="vendor/pdf-utils.js"></script>
    <script src="vendor/error-handler.js"></script>
    <script src="vendor/debug-utils.js"></script>
    <script src="vendor/ai-config.js"></script>
    <script src="vendor/ai-prompts.js"></script>
    <script src="vendor/ai-utils.js"></script>
    <script src="vendor/market-analysis-utils.js"></script>
    <script src="vendor/template-utils.js"></script>
    <style>
        /* é¡µé¢ç‰¹å®šæ ·å¼ï¼ˆä¿ç•™ä¸å…¬å…±æ ·å¼ä¸åŒçš„éƒ¨åˆ†ï¼‰ */
        /* æ³¨æ„ï¼š#marketModule æ ·å¼å·²ç§»è‡³ vendor/market-analysis-styles.css */
    </style>
</head>
<body data-page="365-04-market-watch.html">
    <!-- ç”¨æˆ·éªŒè¯æ¨¡æ€æ¡† -->
    <div id="authOverlay" class="auth-overlay">
        <div class="auth-modal">
            <h2>ğŸ” è®¿é—®éªŒè¯</h2>
            <p>ä¸ºäº†äº†è§£å·¥å…·ä½¿ç”¨æƒ…å†µï¼Œè¯·å¡«å†™ä»¥ä¸‹ä¿¡æ¯</p>
            <form id="authForm">
                <div class="auth-form-group">
                    <label for="userName">å§“å *</label>
                    <input type="text" id="userName" name="userName" placeholder="è¯·è¾“å…¥æ‚¨çš„å§“å" required autocomplete="name">
                    <div class="auth-error" id="nameError">è¯·è¾“å…¥æ‚¨çš„å§“å</div>
                </div>
                <div class="auth-form-group">
                    <label for="userPhone">æ‰‹æœºå· *</label>
                    <input type="tel" id="userPhone" name="userPhone" placeholder="è¯·è¾“å…¥æ‚¨çš„æ‰‹æœºå·" required autocomplete="tel">
                    <div class="auth-error" id="phoneError">è¯·è¾“å…¥æœ‰æ•ˆçš„æ‰‹æœºå·</div>
                </div>
                <div class="auth-form-group">
                    <label for="userEmail">é‚®ç®± *</label>
                    <input type="email" id="userEmail" name="userEmail" placeholder="è¯·è¾“å…¥æ‚¨çš„é‚®ç®±åœ°å€" required autocomplete="email">
                    <div class="auth-error" id="emailError">è¯·è¾“å…¥æœ‰æ•ˆçš„é‚®ç®±åœ°å€</div>
                </div>
                <button type="submit" class="auth-submit-btn">ç¡®è®¤å¹¶ç»§ç»­</button>
            </form>
        </div>
    </div>
    <div class="container">
        <div class="header">
            <a href="index.html?tab=tools365" class="back-home-btn">â† è¿”å›é¦–é¡µ</a>
            <a href="365-04-market-watch-README.html" class="readme-btn">ä½¿ç”¨è¯´æ˜ â†’</a>
            <h1>Market Watch Â· å¸‚åœºè§‚å¯Ÿ</h1>
            <p>ä¸€ä»½ Excel ä¸å‘¨æŠ¥å³å¯è”åŠ¨è¿ä»·è¶‹åŠ¿ã€èˆªçº¿ä¾›ç»™ä¸ AI å†³ç­–ï¼Œè½»æ¾å®Œæˆè·¨æ¿å—æ´å¯Ÿ</p>
        </div>

        <div class="content">
            <div class="card">
                <div class="controls top-controls">
                    <label class="file-btn" title="é€‰æ‹©Excelæ–‡ä»¶ï¼šåŒä¸€æ–‡ä»¶éœ€åŒæ—¶åŒ…å« market ä¸ schedule å·¥ä½œè¡¨">
                        é€‰æ‹©Excelæ–‡ä»¶
                        <input id="fileInput" type="file" accept=".xlsx,.xls">
                    </label>
                    <label class="file-btn" title="è½½å…¥å¸‚åœºå‘¨æŠ¥ï¼šæ”¯æŒä¸€æ¬¡é€‰æ‹©å¤šä»½ PDFï¼ˆå¦‚ Alphaliner_Newsletterã€Linerlytica Weekly ç­‰ï¼‰ï¼Œç”¨äºè¾…åŠ© AI åˆ†æ">
                        è½½å…¥å¸‚åœºå‘¨æŠ¥ (PDF)
                        <input id="marketReportInput" type="file" accept=".pdf" multiple>
                    </label>
                    <button type="button" class="file-btn" id="exportPdfBtn" title="å¯¼å‡ºåŒ…å«å½“å‰ç­›é€‰è§†å›¾ä¸ AI ç»“è®ºçš„æ•´é¡µ PDF">
                        å¯¼å‡ºæ•´é¡µ PDF
                    </button>
                    <span class="file-hint">
                        é€‰æ‹©Excelæ–‡ä»¶ï¼šåŒä¸€æ–‡ä»¶éœ€åŒæ—¶åŒ…å« market ä¸ schedule å·¥ä½œè¡¨ï¼›
                        è½½å…¥å¸‚åœºå‘¨æŠ¥ï¼šæ”¯æŒä¸€æ¬¡é€‰æ‹©å¤šä»½ PDFï¼ˆå¦‚ Alphaliner_Newsletterã€Linerlytica Weekly ç­‰ï¼‰ï¼Œç”¨äºè¾…åŠ© AI åˆ†æã€‚
                    </span>
                </div>
                <div class="market-report-upload">
                    <h5>å¸‚åœºå‘¨æŠ¥åˆ—è¡¨</h5>
                    <ul class="market-report-list" id="marketReportList">
                        <li>å°šæœªè½½å…¥å¸‚åœºæŠ¥å‘Š</li>
                    </ul>
                </div>
            </div>

            <section id="marketModule" class="feature-section">
                <div class="module-header">
                    <span class="module-badge">MODULE 01</span>
                    <div>
                        <h2 class="section-title">è¿è´¹èµ°åŠ¿å›¾ <span>RATE TRENDS CHART</span></h2>
                        <p class="module-desc">å¤šæ¸¯å£æŠ¥ä»·ã€åŒºé—´æç¤ºä¸æ—¶æ®µç­›é€‰ï¼Œä¸€å±æŒæ¡å¸‚åœºæ¸©åº¦</p>
                    </div>
                </div>
                <div class="card module-card hidden" data-module="market">
                    <div class="controls">
                        <div class="filter-controls hidden" id="marketFilterControls">
                            <div class="filter-group">
                                <label>é€‰æ‹©åŒºåŸŸ</label>
                                <select id="marketRegionSelect" multiple size="6" class="multi-select">
                                    <option value="">å…¨éƒ¨åŒºåŸŸ</option>
                                </select>
                            <div class="filter-actions">
                                <button type="button" class="filter-btn" id="marketRegionSelectAll">å…¨éƒ¨é€‰æ‹©</button>
                                <button type="button" class="filter-btn" id="marketRegionClear">æ¸…é™¤é€‰æ‹©</button>
                            </div>
                            <small class="multi-hint">å¯å¤šé€‰ï¼ˆç‚¹å‡»å³å¯å‹¾é€‰æˆ–å–æ¶ˆï¼‰</small>
                            </div>
                            <div class="filter-group">
                                <label>é€‰æ‹©æ¸¯å£</label>
                                <select id="marketPortSelect" multiple size="6" class="multi-select" disabled>
                                    <option value="">è¯·å…ˆåŠ è½½æ•°æ®</option>
                                </select>
                            <div class="filter-actions">
                                <button type="button" class="filter-btn" id="marketPortSelectAll">å…¨éƒ¨é€‰æ‹©</button>
                                <button type="button" class="filter-btn" id="marketPortClear">æ¸…é™¤é€‰æ‹©</button>
                            </div>
                            <small class="multi-hint">å¯å¤šé€‰ï¼ˆç‚¹å‡»å³å¯å‹¾é€‰æˆ–å–æ¶ˆï¼‰</small>
                            </div>
                        </div>
                    </div>
                    <div id="marketInfoBox" class="info-box hidden">
                        <p id="marketInfoText"></p>
                    </div>
                    <div class="chart-container hidden" id="marketChartContainer">
                        <div class="chart-header">
                            <h3 style="color:#495057;">è¿è´¹èµ°åŠ¿å›¾</h3>
                        </div>
                        <div class="chart-wrapper">
                            <canvas id="marketTrendChart"></canvas>
                        </div>
                    </div>
                </div>
            </section>

            <section id="capacityModule" class="feature-section">
                <div class="module-header">
                    <span class="module-badge">MODULE 02</span>
                    <div>
                        <h2 class="section-title">èˆªçº¿è¿åŠ›åˆ†æ <span>SAILING SCHEDULE PULSE</span></h2>
                        <p class="module-desc">å››çº§ç­›é€‰è”åŠ¨è¿åŠ›ã€æ´¾èˆ¹ä¸è¶‹åŠ¿ï¼Œç²¾å‡†é”å®šå½“å‘¨+æœªæ¥å››å‘¨ä¾›ç»™</p>
                    </div>
                </div>
                <div class="card module-card hidden" data-module="capacity">
                    <div class="controls">
                        <div class="view-toggle hidden" id="viewToggle">
                            <label>æ˜¾ç¤ºæ¨¡å¼ï¼š</label>
                            <button id="btnAll" class="active">å…¨éƒ¨</button>
                            <button id="btnCapacity">è¿åŠ›</button>
                            <button id="btnShips">æ´¾èˆ¹</button>
                        </div>
                    </div>
                    <div id="destinationFilters" class="destination-filters hidden">
                        <div class="filter-group">
                            <label for="areaSelect">åŒºåŸŸ</label>
                            <select id="areaSelect" multiple size="6" class="multi-select">
                                <option value="">å…¨éƒ¨åŒºåŸŸ</option>
                            </select>
                            <div class="filter-actions">
                                <button type="button" class="filter-btn" id="areaSelectAll">å…¨éƒ¨é€‰æ‹©</button>
                                <button type="button" class="filter-btn" id="areaClearAll">æ¸…é™¤é€‰æ‹©</button>
                            </div>
                            <small class="multi-hint">å¯å¤šé€‰ï¼ˆç‚¹å‡»å³å¯å‹¾é€‰æˆ–å–æ¶ˆï¼‰</small>
                        </div>
                        <div class="filter-group">
                            <label for="subAreaSelect">å­åŒºåŸŸ</label>
                            <select id="subAreaSelect" disabled multiple size="6" class="multi-select">
                                <option value="">å…¨éƒ¨å­åŒºåŸŸ</option>
                            </select>
                            <div class="filter-actions">
                                <button type="button" class="filter-btn" id="subAreaSelectAll">å…¨éƒ¨é€‰æ‹©</button>
                                <button type="button" class="filter-btn" id="subAreaClearAll">æ¸…é™¤é€‰æ‹©</button>
                            </div>
                            <small class="multi-hint">å¯å¤šé€‰ï¼ˆç‚¹å‡»å³å¯å‹¾é€‰æˆ–å–æ¶ˆï¼‰</small>
                        </div>
                        <div class="filter-group">
                            <label for="countrySelect">å›½å®¶ / åœ°åŒº</label>
                            <select id="countrySelect" disabled multiple size="6" class="multi-select">
                                <option value="">å…¨éƒ¨å›½å®¶ / åœ°åŒº</option>
                            </select>
                            <div class="filter-actions">
                                <button type="button" class="filter-btn" id="countrySelectAll">å…¨éƒ¨é€‰æ‹©</button>
                                <button type="button" class="filter-btn" id="countryClearAll">æ¸…é™¤é€‰æ‹©</button>
                            </div>
                            <small class="multi-hint">å¯å¤šé€‰ï¼ˆç‚¹å‡»å³å¯å‹¾é€‰æˆ–å–æ¶ˆï¼‰</small>
                        </div>
                        <div class="filter-group">
                            <label for="portSelect">æ¸¯å£</label>
                            <select id="portSelect" disabled multiple size="6" class="multi-select">
                                <option value="">å…¨éƒ¨æ¸¯å£</option>
                            </select>
                            <div class="filter-actions">
                                <button type="button" class="filter-btn" id="portSelectAll">å…¨éƒ¨é€‰æ‹©</button>
                                <button type="button" class="filter-btn" id="portClearAll">æ¸…é™¤é€‰æ‹©</button>
                            </div>
                            <small class="multi-hint">å¯å¤šé€‰ï¼ˆç‚¹å‡»å³å¯å‹¾é€‰æˆ–å–æ¶ˆï¼‰</small>
                        </div>
                    </div>
                    <div id="infoBox" class="info-box hidden">
                        <p id="infoText"></p>
                    </div>
                    <div id="tableContainer" class="table-container hidden">
                        <table id="pivotTable">
                            <thead id="tableHead"></thead>
                            <tbody id="tableBody"></tbody>
                        </table>
                    </div>
                    <div id="chartContainer" class="chart-container hidden">
                        <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:20px;">
                            <h3 style="color:#1f2d3d; font-size:20px; letter-spacing:0.5px;">è¿åŠ›ä¸æ´¾èˆ¹è¶‹åŠ¿å›¾</h3>
                            <span style="color:#6c757d; font-size:13px;">é«˜åº¦ Ã—2 å±•ç¤ºï¼Œä¾¿äºå¯¹æ¯”å¤šèˆªçº¿</span>
                        </div>
                        <div id="emptyChartMessage" class="empty-chart-message hidden">
                            è¯·é€‰æ‹©åŒºåŸŸï¼ˆæˆ–æ›´ç»†åˆ†çš„å±‚çº§ï¼‰ä»¥æŸ¥çœ‹å›¾è¡¨
                        </div>
                        <div class="chart-wrapper hidden" id="chartWrapper">
                            <canvas id="trendChart"></canvas>
                        </div>
                    </div>
                </div>
            </section>

            <section id="aiModule" class="feature-section">
                <div class="module-header">
                    <span class="module-badge">MODULE 03</span>
                    <div>
                        <h2 class="section-title">AI è¶‹åŠ¿åˆ†æ <span>AI TREND ANALYSIS</span></h2>
                        <p class="module-desc">DeepSeek Ã— KIMI Ã— é€šä¹‰åƒé—® ä¸‰æ¨¡å‹äº¤å‰éªŒè¯èˆªçº¿ç­–ç•¥ã€ä¾›éœ€ä¸ä»·æ ¼å»ºè®®</p>
                    </div>
                </div>
                <div class="card module-card hidden" data-module="ai">
                    <div id="aiAnalysisContainer" class="ai-analysis-container">
                        <div class="ai-header">
                            <h3>AI èˆ¹æœŸè¶‹åŠ¿åˆ†æ</h3>
                            <p>åŒä¸€ä»½ç­›é€‰æ•°æ®å¯ç”±å¤šæ¨¡å‹å¹¶è¡Œåˆ†æï¼Œå¿«é€Ÿå¯¹æ¯”è§‚ç‚¹å¹¶äº¤å‰éªŒè¯ç»“è®º</p>
                        </div>
                        <div id="emptyAiMessage" class="empty-chart-message" style="display: none;">
                            è¯·å…ˆåŠ è½½æ•°æ®æ–‡ä»¶å¹¶é€‰æ‹©ç­›é€‰æ¡ä»¶ä»¥å¯ç”¨ AI åˆ†æ
                        </div>
                        <div id="aiConfigSection" style="display: none;">
                            <!-- å…¶ä»–å½±å“å› ç´ è¡¨æ ¼ - ä½¿ç”¨å…¬å…±æ¨¡æ¿ï¼ˆvendor/template-utils.jsï¼‰ -->
                            <div id="bookingDataTableContainer"></div>
                            <!-- å¸‚åœºæ•°æ®ä¿¡æ¯å— - ä½¿ç”¨å…¬å…±æ¨¡æ¿ï¼ˆvendor/template-utils.jsï¼‰ -->
                            <div id="marketDataInfoBlocksContainer"></div>
                            <!-- AI é…ç½®é¢æ¿ - ä½¿ç”¨å…¬å…±æ¨¡æ¿ï¼ˆvendor/template-utils.jsï¼‰ -->
                            <div id="aiConfigPanelsContainer"></div>
                            </div>
    </div>
    </div>
    <div class="page-footer">
        <h2>Market Watch Â· å¸‚åœºè§‚å¯Ÿä½¿ç”¨å£°æ˜</h2>
        <p>èµ„æ–™æ•´åˆè‡ªç”¨æˆ· Excelã€ç”¨æˆ·è½½å…¥å¸‚åœºå‘¨æŠ¥ã€Ship & Bunkerã€ä¸Šæµ·èˆªè¿äº¤æ˜“æ‰€ã€Drewryã€Freightos ç­‰å…¬å¼€æ¸ é“ï¼Œä»…ä¾›å†…éƒ¨ç ”åˆ¤ï¼Œä¸æ„æˆå¯¹å¤–æŠ¥ä»·æˆ–æŠ•èµ„å»ºè®®ã€‚</p>
        <p>AI æœåŠ¡ç”± DeepSeek / KIMI / é€šä¹‰åƒé—® API é©±åŠ¨ï¼Œæ‰€æœ‰è°ƒç”¨è´¹ç”¨ä¸åˆè§„è´£ä»»ç”±ä½¿ç”¨è€…è‡ªæ‹…ï¼Œæ¶‰åŠå®¢æˆ·æˆ–æ•æ„Ÿæ•°æ®æ—¶è¯·å…ˆå®Œæˆè„±æ•å¤„ç†ã€‚</p>
    </div>
    <!-- ä½¿ç”¨ Gist å­˜å‚¨ç³»ç»Ÿï¼ˆç”¨æˆ·ç™½åå• + è®¿é—®è®°å½•ï¼‰ -->
    <script src="vendor/auth-gist.js"></script>
    <script>

        // ==================== è°ƒè¯•æ¨¡å¼ ====================
        // è°ƒè¯•å‡½æ•°å·²ç»Ÿä¸€åˆ° vendor/debug-utils.js
        // ä½¿ç”¨ï¼šdebugLog(), debugWarn(), debugError()

        // ==================== é”™è¯¯å¤„ç† ====================
        // æ³¨æ„ï¼šErrorType å’Œ showError/showSuccess å·²åœ¨ vendor/error-handler.js ä¸­å®šä¹‰
        // è¿™é‡Œåªæ·»åŠ é¡µé¢ç‰¹å®šçš„é”™è¯¯æ¶ˆæ¯
        
        // æ·»åŠ é¡µé¢ç‰¹å®šçš„é”™è¯¯æ¶ˆæ¯ï¼ˆä½¿ç”¨ç»Ÿä¸€çš„é”™è¯¯å¤„ç†æ¨¡å—ï¼‰
        if (typeof addErrorMessage === 'function') {
            addErrorMessage(ErrorType.DATA_VALIDATION, 'NO_AREA_SELECTION', 'è¯·å…ˆé€‰æ‹©åŒºåŸŸï¼ˆè‡³å°‘ç¬¬ä¸€çº§ï¼‰');
            addErrorMessage(ErrorType.DATA_VALIDATION, 'NO_EXCEL_LOADED', 'è¯·å…ˆåŠ è½½å¹¶è§£æ Excel æ–‡ä»¶');
        }

        // è¿è´¹èµ°åŠ¿å›¾æ¨¡å—é€»è¾‘
        let marketData = [];
        let marketChart = null;
        let marketRegions = [];
        let marketRegionPortMap = {};
        let marketColumnConfig = {
            portCol: null,
            dateCol: null
        };
        let marketSelectedRegions = [];
        let marketSelectedPorts = [];
        let marketSelectorsInitialized = false;

        // è‡ªå®šä¹‰åŒºåŸŸé¡ºåºï¼ˆç”¨äºå¸‚åœºè¿ä»·ä¸è¿åŠ›åŒºåŸŸï¼‰
        const CUSTOM_REGION_ORDER = ['åŒ—ç¾æ´²', 'æ‹‰ä¸ç¾æ´²', 'æ¬§æ´²', 'ä¸­ä¸œçº¢æµ·å°å·´', 'æ¾³æ´²', 'éæ´²', 'ä¸œå—äºš'];

        let pdfJsReady = false;
        let pdfJsLoadingPromise = null;

        if (window.pdfjsLib && pdfjsLib.GlobalWorkerOptions) {
            // ä¼˜å…ˆä½¿ç”¨æœ¬åœ° workerï¼Œå¤±è´¥æ—¶ä½¿ç”¨ CDN
            try {
                pdfjsLib.GlobalWorkerOptions.workerSrc = 'vendor/pdf.worker.min.js';
            } catch (e) {
                pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
            }
            pdfJsReady = true;
        }

        const loadedScripts = new Set();
        const loadedWorkers = new Map();

        // loadScript, loadWorkerAsBlob, ensurePdfJsLoaded å·²ä» vendor/market-analysis-utils.js åŠ è½½

        let marketReports = [];
        let bunkerData = null;
        let wciData = null;
        let fbxData = null;
        const excelLoadState = { market: false, schedule: false };
        let modulesVisible = false;

        const fileInput = document.getElementById('fileInput');
        const marketRegionSelect = document.getElementById('marketRegionSelect');
        const marketPortSelect = document.getElementById('marketPortSelect');
        const marketFilterControls = document.getElementById('marketFilterControls');
        const marketChartContainer = document.getElementById('marketChartContainer');
        const marketInfoBox = document.getElementById('marketInfoBox');
        const marketInfoText = document.getElementById('marketInfoText');
        const marketStartDate = null;
        const marketEndDate = null;
        const marketDateControls = null;
        const marketReportInput = document.getElementById('marketReportInput');
        const marketReportList = document.getElementById('marketReportList');
        // çŠ¶æ€å…ƒç´ å¼•ç”¨å°†åœ¨æ¨¡æ¿ç”Ÿæˆåé‡æ–°è·å–ï¼ˆåœ¨ window.addEventListener('load') ä¸­ï¼‰
        // ä½¿ç”¨ let ä»¥ä¾¿åœ¨æ¨¡æ¿ç”Ÿæˆåæ›´æ–°
        let bunkerStatusEl = null;
        let bunkerUpdatedEl = null;
        let wciStatusEl = null;
        let wciUpdatedEl = null;
        let fbxStatusEl = null;
        let fbxUpdatedEl = null;

        // renderMarketReportList å·²ä» vendor/market-analysis-utils.js åŠ è½½
        renderMarketReportList();

        // è‡ªåŠ¨åŠ è½½ Data ç›®å½•ä¸‹çš„ Excel æ–‡ä»¶
        // ä½¿ç”¨å…¬å…±å‡½æ•°åŠ è½½ Excel æ–‡ä»¶ï¼ˆä» vendor/common-utils.jsï¼‰
        async function loadExcelFile() {
            await window.loadDefaultExcelFile('365-04-market-watch', async (file) => {
                // ç›´æ¥è°ƒç”¨å¤„ç†å‡½æ•°ï¼ˆæ¨¡æ‹Ÿæ–‡ä»¶é€‰æ‹©ï¼‰
                if (typeof XLSX === 'undefined') {
                    showError(ErrorType.FILE_LOAD, 'XLSX_NOT_LOADED');
                    return;
                }

                try {
                    // å…ˆåŠ è½½ market æ•°æ®
                    const marketDataResult = await readMarketExcelFile(file);
                    if (marketDataResult && marketDataResult.length) {
                        // å¤„ç† market æ•°æ®ï¼ˆå®Œå…¨å¤åˆ¶æ‰‹åŠ¨åŠ è½½çš„é€»è¾‘ï¼‰
                        const firstRow = marketDataResult[0] || {};
                        const columnKeys = Object.keys(firstRow);
                        const findColumn = (keywords, fallbackIndex = null) => {
                            const key = columnKeys.find(col =>
                                keywords.some(word => (col || '').toString().toLowerCase().includes(word.toLowerCase()))
                            );
                            if (key) return key;
                            if (typeof fallbackIndex === 'number' && columnKeys[fallbackIndex]) {
                                return columnKeys[fallbackIndex];
                            }
                            return null;
                        };
                        const regionCol = findColumn(['åŒºåŸŸ', 'region', 'åœ°åŒº', 'area'], 8);
                        const portCol = findColumn(['æ¸¯å£', 'port', 'ç›®çš„æ¸¯', 'ç›®çš„'], 3);
                        const dateCol = findColumn(['æ—¥æœŸ', 'date', 'æ—¶é—´', 'time'], 0);
                        if (regionCol && portCol) {
                            marketColumnConfig = { portCol, dateCol };
                            marketRegionPortMap = {};

                            marketDataResult.forEach(row => {
                                const region = String(row[regionCol] || '').trim();
                                const port = String(row[portCol] || '').trim();
                                if (!region || !port) return;
                                if (!marketRegionPortMap[region]) {
                                    marketRegionPortMap[region] = new Set();
                                }
                                marketRegionPortMap[region].add(port);
                            });

                            // ä½¿ç”¨æ ‡å‡†åŒºåŸŸé¡ºåºæ’åºï¼ˆä¸¥æ ¼æŒ‰ç…§ STANDARD_AREA_ORDER çš„é¡ºåºï¼‰
                            const allRegions = Object.keys(marketRegionPortMap);
                            // å¤„ç†åŒºåŸŸåç§°å˜ä½“ï¼ˆå¦‚"ä¸­ä¸œå°å·´çº¢æµ·" -> "ä¸­ä¸œçº¢æµ·å°å·´"ï¼‰
                            const normalizeAreaName = (areaName) => {
                                if (!areaName) return areaName;
                                // å¦‚æœåŒ…å«"ä¸­ä¸œ"ã€"å°å·´"ã€"çº¢æµ·"è¿™äº›å…³é”®è¯ï¼Œç»Ÿä¸€æ˜ å°„åˆ°"ä¸­ä¸œçº¢æµ·å°å·´"
                                if (areaName.includes('ä¸­ä¸œ') && (areaName.includes('å°å·´') || areaName.includes('çº¢æµ·'))) {
                                    return 'ä¸­ä¸œçº¢æµ·å°å·´';
                                }
                                return areaName;
                            };
                            
                            // ç¡®ä¿ä½¿ç”¨æ ‡å‡†åŒºåŸŸé¡ºåºæ’åº
                            if (typeof sortAreasByStandardOrder === 'function') {
                                marketRegions = sortAreasByStandardOrder(allRegions);
                            } else if (typeof STANDARD_AREA_ORDER !== 'undefined') {
                                // å¦‚æœ sortAreasByStandardOrder ä¸å¯ç”¨ï¼Œæ‰‹åŠ¨æ’åº
                                const areaOrderMap = new Map();
                                STANDARD_AREA_ORDER.forEach((area, index) => {
                                    areaOrderMap.set(area, index);
                                });
                                // åˆ›å»ºæ–°æ•°ç»„è¿›è¡Œæ’åºï¼Œä¸ä¿®æ”¹åŸæ•°ç»„
                                marketRegions = [...allRegions].sort((a, b) => {
                                    const normalizedA = normalizeAreaName(a);
                                    const normalizedB = normalizeAreaName(b);
                                    const indexA = areaOrderMap.has(normalizedA) ? areaOrderMap.get(normalizedA) : Infinity;
                                    const indexB = areaOrderMap.has(normalizedB) ? areaOrderMap.get(normalizedB) : Infinity;
                                    if (indexA !== Infinity && indexB !== Infinity) {
                                        return indexA - indexB;
                                    }
                                    if (indexA !== Infinity) return -1;
                                    if (indexB !== Infinity) return 1;
                                    return a.localeCompare(b, 'zh-Hans-CN');
                                });
                            } else {
                                marketRegions = [...allRegions].sort((a, b) => a.localeCompare(b, 'zh-Hans-CN'));
                            }
                            const totalPorts = marketRegions.reduce((sum, region) => sum + marketRegionPortMap[region].size, 0);
                            // å°†Setè½¬æ¢ä¸ºæ•°ç»„ï¼ˆå…³é”®æ­¥éª¤ï¼ï¼‰
                            marketRegions.forEach(region => {
                                marketRegionPortMap[region] = Array.from(marketRegionPortMap[region]).sort((a, b) => a.localeCompare(b, 'zh-Hans-CN'));
                            });

                            if (marketRegionSelect) {
                                marketRegionSelect.innerHTML = '';
                                const placeholder = document.createElement('option');
                                placeholder.value = '';
                                placeholder.textContent = 'å…¨éƒ¨åŒºåŸŸ';
                                placeholder.selected = true;
                                marketRegionSelect.appendChild(placeholder);
                                // marketRegions å·²ç»æŒ‰æ ‡å‡†é¡ºåºæ’åºï¼Œç›´æ¥ä½¿ç”¨
                                marketRegions.forEach(region => {
                                    const option = document.createElement('option');
                                    option.value = region;
                                    option.textContent = `${region} (${marketRegionPortMap[region].length}ä¸ªæ¸¯å£)`;
                                    marketRegionSelect.appendChild(option);
                                });
                            }

                            // åˆå§‹åŒ–é€‰æ‹©å™¨å¹¶æ›´æ–°æ¸¯å£é€‰é¡¹ï¼ˆå…³é”®æ­¥éª¤ï¼ï¼‰
                            initMarketSelectors();
                            marketSelectedRegions = [];
                            marketSelectedPorts = [];
                            updateMarketPortOptions();

                            marketData = marketDataResult;
                            excelLoadState.market = true;
                            
                            // æ˜¾ç¤ºä¿¡æ¯
                            marketInfoBox?.classList.remove('hidden');
                            if (marketInfoText) {
                                marketInfoText.textContent = `å·²åŠ è½½ ${marketDataResult.length} æ¡æ•°æ®ï¼Œå…± ${marketRegions.length} ä¸ªåŒºåŸŸï¼Œ${totalPorts} ä¸ªæ¸¯å£`;
                            }
                        }
                    }
                    
                    // å†åŠ è½½ schedule æ•°æ®
                    const scheduleDataResult = await readExcelFile(file);
                    if (scheduleDataResult && scheduleDataResult.length) {
                        scheduleData = scheduleDataResult;
                        generatePivotTable(scheduleData);
                        const infoText = document.getElementById('infoText');
                        const infoBox = document.getElementById('infoBox');
                        if (infoText) infoText.textContent = `å·²åŠ è½½ ${scheduleData.length} æ¡èˆ¹æœŸæ•°æ®`;
                        if (infoBox) infoBox.classList.remove('hidden');
                        excelLoadState.schedule = true;
                        tryRevealModules();
                    }
                } catch (error) {
                    showError(ErrorType.FILE_LOAD, 'FILE_READ_FAILED', { message: error.message }, error);
                    debugError(error);
                }
            });
        }
        
        // ä½¿ç”¨å…¬å…±å‡½æ•°åŠ è½½å¸‚åœºå‘¨æŠ¥ PDF æ–‡ä»¶ï¼ˆä» vendor/common-utils.jsï¼‰
        async function loadMarketReports() {
            if (marketReportList) {
                marketReportList.innerHTML = '<li>æ­£åœ¨è‡ªåŠ¨åŠ è½½å¸‚åœºå‘¨æŠ¥...</li>';
            }
            
            await window.loadDefaultMarketReports(async (file) => {
                await handleMarketReportFile(file);
                // æ£€æŸ¥æ˜¯å¦æå–åˆ° SCFI æ•°æ®
                const latestReport = marketReports[marketReports.length - 1];
                if (latestReport) {
                    if (latestReport.scfiData) {
                        scfiData = latestReport.scfiData;
                        renderScfiTable(latestReport.scfiData, file.name);
                    } else {
                        // å°è¯•æ‰‹åŠ¨æå–
                        try {
                            const fullText = latestReport.text;
                            if (fullText) {
                                const extractedScfi = parseScfiTable(fullText);
                                if (extractedScfi) {
                                    scfiData = extractedScfi;
                                    renderScfiTable(extractedScfi, file.name);
                                }
                            }
                        } catch (e) {
                            // å¿½ç•¥æå–é”™è¯¯
                        }
                    }
                }
            });
            
            // æ›´æ–°å¸‚åœºå‘¨æŠ¥åˆ—è¡¨æ˜¾ç¤º
            renderMarketReportList();
        }

        // ç­‰å¾… XLSX å’Œ PDF.js åº“åŠ è½½å®Œæˆåè‡ªåŠ¨åŠ è½½æ–‡ä»¶
        if (typeof window.ensureXlsx === 'function') {
            window.ensureXlsx().then(async () => {
                await loadExcelFile();
                // ç­‰å¾… PDF.js åŠ è½½å®Œæˆåå†åŠ è½½å¸‚åœºå‘¨æŠ¥
                if (typeof window.ensurePdfJsLoaded === 'function') {
                    await window.ensurePdfJsLoaded();
                }
                // å»¶è¿Ÿä¸€ä¸‹ï¼Œç¡®ä¿ PDF.js å®Œå…¨åˆå§‹åŒ–
                setTimeout(() => {
                    loadMarketReports();
                }, 500);
            });
        } else {
            setTimeout(async () => {
                if (typeof XLSX !== 'undefined') {
                    await loadExcelFile();
                    if (typeof window.ensurePdfJsLoaded === 'function') {
                        await window.ensurePdfJsLoaded();
                    }
                    setTimeout(() => {
                        loadMarketReports();
                    }, 500);
                }
            }, 1000);
        }

        function tryRevealModules() {
            if (modulesVisible) return;
            if (excelLoadState.market && excelLoadState.schedule) {
                // åªæ˜¾ç¤ºç­›é€‰æ§ä»¶ï¼Œæ¨¡å—æ ‡é¢˜å§‹ç»ˆæ˜¾ç¤º
                const marketFilterControls = document.getElementById('marketFilterControls');
                if (marketFilterControls) marketFilterControls.classList.remove('hidden');
                
                const destinationFiltersPanel = document.getElementById('destinationFilters');
                if (destinationFiltersPanel) destinationFiltersPanel.classList.remove('hidden');
                
                const viewToggle = document.getElementById('viewToggle');
                if (viewToggle) viewToggle.classList.remove('hidden');

                document.querySelectorAll('.module-card').forEach(card => {
                    card.classList.remove('hidden');
                });
                
                modulesVisible = true;
            }
        }

        // æŒ‰é’®äº‹ä»¶ç»‘å®šå·²ç§»è‡³ initMarketAnalysisPage å‡½æ•°ä¸­ï¼ˆæ¨¡æ¿ç”Ÿæˆåï¼‰

        const CACHE_KEYS = {
            wci: 'wciDataCache',
            fbx: 'fbxDataCache'
        };

        // escapeRegex, computePercentChange, formatPercent, loadCachedData, saveCachedData å·²ä» vendor/common-utils.js åŠ è½½
        // applyWoWFromCache, extractTextFromPdf, handleMarketReportFile, parseScfiTable, buildScfiDataSection å·²ä» vendor/market-analysis-utils.js åŠ è½½

        // æ³¨å†Œ SCFI æ•°æ®æå–å›è°ƒ
        window.onScfiDataExtracted = (data, fileName) => {
            scfiData = data;
            renderScfiTable(data, fileName);
        };

        if (marketReportInput) {
            marketReportInput.addEventListener('change', async (e) => {
                const files = Array.from(e.target.files || []);
                if (!files.length) return;
                if (marketReportList) {
                    marketReportList.innerHTML = '<li>æ­£åœ¨è§£æè½½å…¥çš„æŠ¥å‘Š...</li>';
                }
                for (const file of files) {
                    try {
                        await handleMarketReportFile(file);
                        // æ£€æŸ¥æ˜¯å¦æå–åˆ° SCFI æ•°æ®
                        const latestReport = marketReports[marketReports.length - 1];
                        if (latestReport) {
                            debugLog('å¸‚åœºæŠ¥å‘Šè§£æå®Œæˆ:', {
                                name: latestReport.name,
                                hasScfiData: !!latestReport.scfiData,
                                scfiData: latestReport.scfiData
                            });
                            if (latestReport.scfiData) {
                                scfiData = latestReport.scfiData;
                                renderScfiTable(latestReport.scfiData, file.name);
                            } else {
                                debugWarn('æœªæ‰¾åˆ° SCFI æ•°æ®ï¼Œå°è¯•æ‰‹åŠ¨æå–...');
                                // å¦‚æœè‡ªåŠ¨æå–å¤±è´¥ï¼Œå°è¯•æ‰‹åŠ¨ä»å…¨æ–‡æå–
                                try {
                                    const fullText = latestReport.text;
                                    if (fullText) {
                                        const extractedScfi = parseScfiTable(fullText);
                                        if (extractedScfi) {
                                            debugLog('æ‰‹åŠ¨æå– SCFI æ•°æ®æˆåŠŸ:', extractedScfi);
                                            scfiData = extractedScfi;
                                            latestReport.scfiData = extractedScfi;
                                            renderScfiTable(extractedScfi, file.name);
                                        } else {
                                            debugWarn('æ‰‹åŠ¨æå–ä¹Ÿå¤±è´¥ï¼Œæ–‡æœ¬å†…å®¹:', fullText.substring(0, 500));
                                        }
                                    }
                                } catch (extractError) {
                                    debugError('æ‰‹åŠ¨æå– SCFI å¤±è´¥:', extractError);
                                }
                            }
                        }
                    } catch (error) {
                        debugError('è§£æPDFå¤±è´¥:', error);
                        showError(ErrorType.FILE_PARSE, 'PARSE_FAILED', { message: error.message || String(error) }, error);
                    }
                }
                renderMarketReportList();
                marketReportInput.value = '';
            });
        }

        /**
         * æ¸²æŸ“ SCFI è¡¨æ ¼
         * @param {Object} data - SCFI æ•°æ®
         * @param {string} source - æ•°æ®æ¥æºæ–‡ä»¶å
         */
        function renderScfiTable(data, source) {
            const container = document.getElementById('scfiTableContainer');
            const sourceEl = document.getElementById('scfiSource');
            const infoContainer = document.getElementById('scfiInfoContainer');
            
            if (!container || !infoContainer) {
                debugWarn('SCFI è¡¨æ ¼å®¹å™¨æœªæ‰¾åˆ°');
                return;
            }
            
            debugLog('æ¸²æŸ“ SCFI è¡¨æ ¼ï¼Œæ•°æ®:', data);
            
            if (!data || (!data.index && (!data.routes || data.routes.length === 0))) {
                debugWarn('SCFI æ•°æ®ä¸ºç©ºï¼Œéšè—è¡¨æ ¼');
                infoContainer.style.display = 'none';
                return;
            }
            
            infoContainer.style.display = 'block';
            let html = '<table class="scfi-table" style="width: 100%; border-collapse: collapse; margin-top: 10px; font-size: 12px; table-layout: fixed;">';
            
            // è¡¨å¤´
            html += '<tr style="background: #f5f5f5;">';
            html += '<th style="padding: 8px; text-align: left; border: 1px solid #ddd; width: 15%;">èˆªçº¿</th>';
            html += '<th style="padding: 8px; text-align: center; border: 1px solid #ddd; width: 5%;">å•ä½</th>';
            html += '<th style="padding: 8px; text-align: right; border: 1px solid #ddd; width: 8%;">å½“æœŸæŒ‡æ•°</th>';
            html += '<th style="padding: 8px; text-align: right; border: 1px solid #ddd; width: 8%;">ä¸ŠæœŸæŒ‡æ•°</th>';
            html += '<th style="padding: 8px; text-align: right; border: 1px solid #ddd; width: 8%;">ä¸ŠæœŸå¯¹æ¯”%</th>';
            html += '<th style="padding: 8px; text-align: right; border: 1px solid #ddd; width: 8%;">ä¸ŠæœˆæŒ‡æ•°</th>';
            html += '<th style="padding: 8px; text-align: right; border: 1px solid #ddd; width: 8%;">ä¸Šæœˆå¯¹æ¯”%</th>';
            html += '<th style="padding: 8px; text-align: right; border: 1px solid #ddd; width: 8%;">ä¸Šå­£åº¦æŒ‡æ•°</th>';
            html += '<th style="padding: 8px; text-align: right; border: 1px solid #ddd; width: 8%;">ä¸Šå­£åº¦å¯¹æ¯”%</th>';
            html += '<th style="padding: 8px; text-align: right; border: 1px solid #ddd; width: 8%;">ä¸Šå¹´æŒ‡æ•°</th>';
            html += '<th style="padding: 8px; text-align: right; border: 1px solid #ddd; width: 8%;">ä¸Šå¹´å¯¹æ¯”%</th>';
            html += '</tr>';
            
            // SCFI ç»¼åˆæŒ‡æ•°è¡Œï¼ˆä½œä¸ºç¬¬ä¸€è¡Œæ•°æ®ï¼Œåœ¨è¡¨å¤´ä¸‹é¢ï¼‰
            if (data.index) {
                const formatValue = (val) => typeof val === 'number' ? val.toLocaleString() : 'â€”';
                const formatPercent = (val) => {
                    if (val === null || val === undefined) return 'â€”';
                    const sign = val >= 0 ? '+' : '';
                    return sign + val.toFixed(1) + '%';
                };
                
                html += '<tr style="background: #f9f9f9; font-weight: bold;">';
                html += '<td style="padding: 8px; border: 1px solid #ddd;">SCFI ç»¼åˆæŒ‡æ•°</td>';
                html += '<td style="padding: 8px; border: 1px solid #ddd; text-align: center;">â€”</td>'; // å•ä½åˆ—
                html += '<td style="padding: 8px; border: 1px solid #ddd; text-align: right;">' + formatValue(data.index) + '</td>';
                // ä¸ŠæœŸæŒ‡æ•° = 1å‘¨æŒ‡æ•° (indexWeek1)
                html += '<td style="padding: 8px; border: 1px solid #ddd; text-align: right;">' + formatValue(data.indexWeek1) + '</td>';
                // ä¸ŠæœŸå¯¹æ¯”% = 1å‘¨å˜åŒ–% (indexWeek1Change)
                html += '<td style="padding: 8px; border: 1px solid #ddd; text-align: right;">' + formatPercent(data.indexWeek1Change) + '</td>';
                // ä¸ŠæœˆæŒ‡æ•° = 1ä¸ªæœˆæŒ‡æ•° (indexMonth1)
                html += '<td style="padding: 8px; border: 1px solid #ddd; text-align: right;">' + formatValue(data.indexMonth1) + '</td>';
                // ä¸Šæœˆå¯¹æ¯”% = 1ä¸ªæœˆå˜åŒ–% (indexMonth1Change)
                html += '<td style="padding: 8px; border: 1px solid #ddd; text-align: right;">' + formatPercent(data.indexMonth1Change) + '</td>';
                // ä¸Šå­£åº¦æŒ‡æ•° = 3ä¸ªæœˆæŒ‡æ•° (indexQuarter3)
                html += '<td style="padding: 8px; border: 1px solid #ddd; text-align: right;">' + formatValue(data.indexQuarter3) + '</td>';
                // ä¸Šå­£åº¦å¯¹æ¯”% = 3ä¸ªæœˆå˜åŒ–% (indexQuarter3Change)
                html += '<td style="padding: 8px; border: 1px solid #ddd; text-align: right;">' + formatPercent(data.indexQuarter3Change) + '</td>';
                // ä¸Šå¹´æŒ‡æ•° = 1å¹´æŒ‡æ•° (indexYear1)
                html += '<td style="padding: 8px; border: 1px solid #ddd; text-align: right;">' + formatValue(data.indexYear1) + '</td>';
                // ä¸Šå¹´å¯¹æ¯”% = 1å¹´å˜åŒ–% (indexYear1Change)
                html += '<td style="padding: 8px; border: 1px solid #ddd; text-align: right;">' + formatPercent(data.indexYear1Change) + '</td>';
                html += '</tr>';
            }
            
            if (data.routes && data.routes.length > 0) {
                // æ•°æ®è¡Œ
                data.routes.forEach(route => {
                    const formatValue = (val) => typeof val === 'number' ? val.toLocaleString() : 'â€”';
                    const formatPercent = (val) => {
                        if (val === null || val === undefined) return 'â€”';
                        const sign = val >= 0 ? '+' : '';
                        return sign + val.toFixed(1) + '%';
                    };
                    
                    // æ£€æŸ¥æ˜¯å¦æ˜¯India/East Africa/Central Americaï¼Œè¿™äº›èˆªçº¿æ²¡æœ‰ä¸Šå¹´æ•°æ®
                    const routeNameLower = (route.name || '').toLowerCase();
                    const hasNoYearData = routeNameLower.includes('india') || 
                                         routeNameLower.includes('nhava sheva') ||
                                         routeNameLower.includes('east africa') ||
                                         routeNameLower.includes('mombasa') ||
                                         routeNameLower.includes('central america') ||
                                         routeNameLower.includes('manzanillo');
                    
                    html += '<tr>';
                    html += `<td style="padding: 6px 8px; border: 1px solid #ddd;">${route.name}</td>`;
                    html += `<td style="padding: 6px 8px; border: 1px solid #ddd; text-align: center;">${route.unit || 'â€”'}</td>`;
                    html += `<td style="padding: 6px 8px; border: 1px solid #ddd; text-align: right;">${formatValue(route.current)}</td>`;
                    html += `<td style="padding: 6px 8px; border: 1px solid #ddd; text-align: right;">${formatValue(route.week1Price)}</td>`;
                    html += `<td style="padding: 6px 8px; border: 1px solid #ddd; text-align: right;">${formatPercent(route.week1Change)}</td>`;
                    html += `<td style="padding: 6px 8px; border: 1px solid #ddd; text-align: right;">${formatValue(route.month1Price)}</td>`;
                    html += `<td style="padding: 6px 8px; border: 1px solid #ddd; text-align: right;">${formatPercent(route.month1Change)}</td>`;
                    html += `<td style="padding: 6px 8px; border: 1px solid #ddd; text-align: right;">${formatValue(route.quarter3Price)}</td>`;
                    html += `<td style="padding: 6px 8px; border: 1px solid #ddd; text-align: right;">${formatPercent(route.quarter3Change)}</td>`;
                    // å¦‚æœæ˜¯India/East Africa/Central Americaï¼Œä¸Šå¹´æ•°æ®æ˜¾ç¤ºä¸º"â€”"
                    if (hasNoYearData) {
                        html += '<td style="padding: 6px 8px; border: 1px solid #ddd; text-align: right;">â€”</td>';
                        html += '<td style="padding: 6px 8px; border: 1px solid #ddd; text-align: right;">â€”</td>';
                    } else {
                        html += `<td style="padding: 6px 8px; border: 1px solid #ddd; text-align: right;">${formatValue(route.year1Price)}</td>`;
                        html += `<td style="padding: 6px 8px; border: 1px solid #ddd; text-align: right;">${formatPercent(route.year1Change)}</td>`;
                    }
                    html += '</tr>';
                });
            }
            
            html += '</table>';
            container.innerHTML = html;
            
            if (sourceEl) {
                sourceEl.textContent = `æ•°æ®æ¥æºï¼š${source}`;
            }
        }

        function initMarketSelectors() {
            if (marketSelectorsInitialized) return;
            if (marketRegionSelect) {
                setupMultiSelect(marketRegionSelect);
                marketRegionSelect.addEventListener('change', () => {
                    marketSelectedRegions = getSelectedValues(marketRegionSelect);
                    updateMarketPortOptions();
                    updateMarketChartFromSelection(false);
                });
            }

            if (marketPortSelect) {
                setupMultiSelect(marketPortSelect);
                marketPortSelect.addEventListener('change', () => {
                    marketSelectedPorts = getSelectedValues(marketPortSelect);
                    updateMarketChartFromSelection(true);
                });
            }

            marketSelectorsInitialized = true;
        }

        function updateMarketPortOptions() {
            if (!marketPortSelect) return;
            const targetRegions = marketSelectedRegions.length ? marketSelectedRegions : marketRegions;
            const portSet = new Set();
            targetRegions.forEach(region => {
                (marketRegionPortMap[region] || []).forEach(port => portSet.add(port));
            });

            // ä½¿ç”¨æ ‡å‡†æ¸¯å£é¡ºåºæ’åº
            const allPorts = Array.from(portSet);
            const uniquePorts = (typeof sortPortsByStandardOrder === 'function')
                ? sortPortsByStandardOrder(allPorts)
                : allPorts.sort((a, b) => a.localeCompare(b, 'zh-Hans-CN'));
            const filteredSelection = marketSelectedPorts.filter(port => uniquePorts.includes(port));
            marketSelectedPorts = filteredSelection;
            const selectedSet = new Set(filteredSelection);

            marketPortSelect.innerHTML = '';
            const placeholderOption = document.createElement('option');
            placeholderOption.value = '';
            placeholderOption.textContent = uniquePorts.length ? 'å…¨éƒ¨æ¸¯å£' : 'è¯·å…ˆé€‰æ‹©åŒºåŸŸ';
            if (!selectedSet.size) {
                placeholderOption.selected = true;
            }
            marketPortSelect.appendChild(placeholderOption);

            uniquePorts.forEach(port => {
                const option = document.createElement('option');
                option.value = port;
                option.textContent = port;
                if (selectedSet.has(port)) {
                    option.selected = true;
                }
                marketPortSelect.appendChild(option);
            });

            marketPortSelect.disabled = uniquePorts.length === 0;
        }

        function updateMarketChartFromSelection(showAlertIfEmpty) {
            if (!marketSelectedPorts.length) {
                if (showAlertIfEmpty) {
                    marketInfoText && (marketInfoText.textContent = 'è¯·é€‰æ‹©è‡³å°‘ä¸€ä¸ªæ¸¯å£ä»¥ç”Ÿæˆèµ°åŠ¿å›¾');
                }
                if (marketChart) {
                    marketChart.destroy();
                    marketChart = null;
                }
                marketChartContainer?.classList.add('hidden');
                marketDateControls?.classList.add('hidden');
                return;
            }
            updateMarketChart(marketSelectedPorts);
        }

        fileInput?.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            if (typeof XLSX === 'undefined') {
                showError(ErrorType.FILE_LOAD, 'XLSX_NOT_LOADED');
                return;
            }

            try {
                const data = await readMarketExcelFile(file);
                if (!data.length) {
                    showError(ErrorType.FILE_LOAD, 'FILE_EMPTY');
                    return;
                }

                marketData = data;
                const firstRow = data[0] || {};
                const columnKeys = Object.keys(firstRow);

                const findColumn = (keywords, fallbackIndex = null) => {
                    const key = columnKeys.find(col =>
                        keywords.some(word => (col || '').toString().toLowerCase().includes(word.toLowerCase()))
                    );
                    if (key) return key;
                    if (typeof fallbackIndex === 'number' && columnKeys[fallbackIndex]) {
                        return columnKeys[fallbackIndex];
                    }
                    return null;
                };

                const regionCol = findColumn(['åŒºåŸŸ', 'region', 'åœ°åŒº', 'area'], 8);
                const portCol = findColumn(['æ¸¯å£', 'port', 'ç›®çš„æ¸¯', 'ç›®çš„'], 3);
                const dateCol = findColumn(['æ—¥æœŸ', 'date', 'æ—¶é—´', 'time'], 0);

                if (!regionCol || !portCol) {
                    showError(ErrorType.FILE_PARSE, 'MISSING_REGION_PORT', { columns: columnKeys.join(', ') });
                    return;
                }

                marketColumnConfig = { portCol, dateCol };
                marketRegionPortMap = {};

                data.forEach(row => {
                    const region = String(row[regionCol] || '').trim();
                    const port = String(row[portCol] || '').trim();
                    if (!region || !port) return;
                    if (!marketRegionPortMap[region]) {
                        marketRegionPortMap[region] = new Set();
                    }
                    marketRegionPortMap[region].add(port);
                });

                // ä½¿ç”¨æ ‡å‡†åŒºåŸŸé¡ºåºæ’åºï¼ˆä¸¥æ ¼æŒ‰ç…§ STANDARD_AREA_ORDER çš„é¡ºåºï¼‰
                const allRegions = Object.keys(marketRegionPortMap);
                // å¤„ç†åŒºåŸŸåç§°å˜ä½“ï¼ˆå¦‚"ä¸­ä¸œå°å·´çº¢æµ·" -> "ä¸­ä¸œçº¢æµ·å°å·´"ï¼‰
                const normalizeAreaName = (areaName) => {
                    if (!areaName) return areaName;
                    // å¦‚æœåŒ…å«"ä¸­ä¸œ"ã€"å°å·´"ã€"çº¢æµ·"è¿™äº›å…³é”®è¯ï¼Œç»Ÿä¸€æ˜ å°„åˆ°"ä¸­ä¸œçº¢æµ·å°å·´"
                    if (areaName.includes('ä¸­ä¸œ') && (areaName.includes('å°å·´') || areaName.includes('çº¢æµ·'))) {
                        return 'ä¸­ä¸œçº¢æµ·å°å·´';
                    }
                    return areaName;
                };
                
                // ç¡®ä¿ä½¿ç”¨æ ‡å‡†åŒºåŸŸé¡ºåºæ’åº
                if (typeof sortAreasByStandardOrder === 'function') {
                    marketRegions = sortAreasByStandardOrder(allRegions);
                } else if (typeof STANDARD_AREA_ORDER !== 'undefined') {
                    // å¦‚æœ sortAreasByStandardOrder ä¸å¯ç”¨ï¼Œæ‰‹åŠ¨æ’åº
                    const areaOrderMap = new Map();
                    STANDARD_AREA_ORDER.forEach((area, index) => {
                        areaOrderMap.set(area, index);
                    });
                    // åˆ›å»ºæ–°æ•°ç»„è¿›è¡Œæ’åºï¼Œä¸ä¿®æ”¹åŸæ•°ç»„
                    marketRegions = [...allRegions].sort((a, b) => {
                        const normalizedA = normalizeAreaName(a);
                        const normalizedB = normalizeAreaName(b);
                        const indexA = areaOrderMap.has(normalizedA) ? areaOrderMap.get(normalizedA) : Infinity;
                        const indexB = areaOrderMap.has(normalizedB) ? areaOrderMap.get(normalizedB) : Infinity;
                        if (indexA !== Infinity && indexB !== Infinity) {
                            return indexA - indexB;
                        }
                        if (indexA !== Infinity) return -1;
                        if (indexB !== Infinity) return 1;
                        return a.localeCompare(b, 'zh-Hans-CN');
                    });
                } else {
                    marketRegions = [...allRegions].sort((a, b) => a.localeCompare(b, 'zh-Hans-CN'));
                }
                const totalPorts = marketRegions.reduce((sum, region) => sum + marketRegionPortMap[region].size, 0);
                marketRegions.forEach(region => {
                    marketRegionPortMap[region] = Array.from(marketRegionPortMap[region]).sort((a, b) => a.localeCompare(b, 'zh-Hans-CN'));
                });

                if (marketRegionSelect) {
                    marketRegionSelect.innerHTML = '';
                    const placeholder = document.createElement('option');
                    placeholder.value = '';
                    placeholder.textContent = 'å…¨éƒ¨åŒºåŸŸ';
                    placeholder.selected = true;
                    marketRegionSelect.appendChild(placeholder);
                    // marketRegions å·²ç»æŒ‰æ ‡å‡†é¡ºåºæ’åºï¼Œç›´æ¥ä½¿ç”¨
                    marketRegions.forEach(region => {
                        const option = document.createElement('option');
                        option.value = region;
                        option.textContent = `${region} (${marketRegionPortMap[region].length}ä¸ªæ¸¯å£)`;
                        marketRegionSelect.appendChild(option);
                    });
                }

                initMarketSelectors();
                marketSelectedRegions = [];
                marketSelectedPorts = [];
                updateMarketPortOptions();

                // ç­›é€‰æ§ä»¶åœ¨ tryRevealModules() ä¸­ç»Ÿä¸€æ˜¾ç¤º
                marketInfoBox?.classList.remove('hidden');
                if (marketInfoText) {
                    marketInfoText.textContent = `å·²åŠ è½½ ${data.length} æ¡æ•°æ®ï¼Œå…± ${marketRegions.length} ä¸ªåŒºåŸŸï¼Œ${totalPorts} ä¸ªæ¸¯å£`;
                }

                marketChartContainer?.classList.add('hidden');
                marketDateControls?.classList.remove('hidden');
                excelLoadState.market = true;
                tryRevealModules();
                } catch (error) {
                    showError(ErrorType.FILE_LOAD, 'FILE_READ_FAILED', { message: error.message }, error);
                    debugError(error);
                }
        });

        marketRegionSelect?.addEventListener('change', (e) => {
            const selectedRegion = e.target.value;
            if (!marketPortSelect) return;

            marketPortSelect.innerHTML = '<option value="">è¯·é€‰æ‹©æ¸¯å£</option>';
            if (selectedRegion && marketRegionPortMap[selectedRegion]) {
                marketRegionPortMap[selectedRegion].forEach(port => {
                    const option = document.createElement('option');
                    option.value = port;
                    option.textContent = port;
                    marketPortSelect.appendChild(option);
                });
            }

            marketPortSelect.value = '';
            marketChartContainer?.classList.add('hidden');
        });

        // æ—¥æœŸç­›é€‰å·²ç§»é™¤

        async function readMarketExcelFile(file) {
            return new Promise((resolve, reject) => {
                if (typeof XLSX === 'undefined') {
                    reject(new Error('XLSX åº“æœªåŠ è½½ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•'));
                    return;
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, { type: 'array', cellDates: true, cellNF: false });
                        const sheetName = workbook.SheetNames.find(name =>
                            name.toLowerCase().includes('market')
                        ) || workbook.SheetNames[0];
                        const worksheet = workbook.Sheets[sheetName];
                        const jsonData = XLSX.utils.sheet_to_json(worksheet, { raw: false, defval: null });
                        resolve(jsonData);
                    } catch (error) {
                        reject(error);
                    }
                };
                reader.onerror = reject;
                reader.readAsArrayBuffer(file);
            });
        }

        function marketFormatDateForInput(date) {
            if (!(date instanceof Date) || isNaN(date)) return '';
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        // ä½¿ç”¨ç»Ÿä¸€çš„æ—¥æœŸè§£æå‡½æ•°ï¼ˆä» vendor/date-utils.jsï¼‰
        function marketParseDate(value) {
            if (value === null || value === undefined) return null;
            // å¦‚æœæ˜¯æ•°å­—ï¼ˆExcel åºåˆ—å·ï¼‰èµ°é€šç”¨è§£æ
            if (typeof value === 'number') {
                const d = parseDateValue(value);
                return d instanceof Date && !isNaN(d) ? d : null;
            }
            const s = String(value).trim();
            if (!s) return null;
            // 1) yyyy/mm/dd æˆ– yyyy-m-d
            let m = s.match(/^(\d{4})[\/\-\.](\d{1,2})[\/\-\.](\d{1,2})$/);
            if (m) {
                let y = +m[1], mo = +m[2], d = +m[3];
                // å¦‚æœå†™æˆ 2025/5/11 ä½†å®é™…åº”ä¸º 2025/11/5ï¼ˆmo>12 æƒ…å†µï¼‰ï¼Œå°è¯•äº¤æ¢
                if (mo > 12 && d <= 12) {
                    [mo, d] = [d, mo];
                }
                const dt = new Date(y, mo - 1, d);
                return dt instanceof Date && !isNaN(dt) ? dt : null;
            }
            // 2) dd/mm/yyyy æˆ– d-m-yyyy
            m = s.match(/^(\d{1,2})[\/\-\.](\d{1,2})[\/\-\.](\d{4})$/);
            if (m) {
                let d = +m[1], mo = +m[2], y = +m[3];
                // å¦‚æœå†™æˆ 5/11/2025 ä½†å®é™…åº”ä¸º 11/5/2025ï¼ˆmo>12 æƒ…å†µï¼‰ï¼Œå°è¯•äº¤æ¢
                if (mo > 12 && d <= 12) {
                    [d, mo] = [mo, d];
                }
                const dt = new Date(y, mo - 1, d);
                return dt instanceof Date && !isNaN(dt) ? dt : null;
            }
            // å…¶ä»–æ ¼å¼ï¼Œå°è¯•é€šç”¨è§£æ
            const dt = new Date(s);
            return dt instanceof Date && !isNaN(dt) ? dt : null;
        }

        function formatDateLabel(date) {
            if (!(date instanceof Date) || isNaN(date)) return '';
            const y = date.getFullYear();
            const m = String(date.getMonth() + 1).padStart(2, '0');
            const d = String(date.getDate()).padStart(2, '0');
            return `${y}/${m}/${d}`;
        }

        function updateMarketChart(ports) {
            if (!marketData.length || !marketColumnConfig.portCol) {
                showError(ErrorType.DATA_VALIDATION, 'NO_EXCEL_LOADED');
                return;
            }

            const selectedPorts = Array.isArray(ports) ? ports.filter(Boolean) : [ports].filter(Boolean);
            if (!selectedPorts.length) {
                marketChartContainer?.classList.add('hidden');
                return;
            }

            const { portCol, dateCol } = marketColumnConfig;
            const labelMeta = new Map(); // label -> { ts, index }
            let rowIndex = 0;
            const seriesData = selectedPorts.map(port => ({
                port,
                values: new Map() // label -> {gp20, gp40}
            }));

            // å•æ¬¡éå†ï¼ŒæŒ‰ Excel åŸå§‹è¡Œé¡ºåºæ”¶é›†
            marketData.forEach(row => {
                const portVal = String(row[portCol] || '').trim();
                if (!selectedPorts.includes(portVal)) return;

                const rawDate = dateCol ? row[dateCol] : '';
                const parsedDate = dateCol ? marketParseDate(rawDate) : null;
                let label = (rawDate ?? '').toString().trim();
                let ts = null;
                if (parsedDate instanceof Date && !isNaN(parsedDate)) {
                    label = formatDateLabel(parsedDate) || label;
                    ts = parsedDate.getTime();
                }
                if (!label) return;

                if (!labelMeta.has(label)) {
                    labelMeta.set(label, { ts, index: rowIndex });
                } else {
                    const meta = labelMeta.get(label);
                    if (ts !== null && (meta.ts === null || ts < meta.ts)) {
                        meta.ts = ts;
                        labelMeta.set(label, meta);
                    }
                }

                const gp20 = row['20GP'] || row['20gp'] || row['GP20'];
                const gp40 = row['40GP'] || row['40gp'] || row['GP40'];
                const targetSeries = seriesData.find(s => s.port === portVal);
                if (targetSeries) {
                    targetSeries.values.set(label, {
                        gp20: gp20 ? parseFloat(gp20) : null,
                        gp40: gp40 ? parseFloat(gp40) : null
                    });
                }

                rowIndex++;
            });

            if (!seriesData.length) {
                marketInfoText && (marketInfoText.textContent = 'æ‰€é€‰æ¸¯å£åœ¨å½“å‰æ—¶é—´èŒƒå›´å†…æš‚æ— æ•°æ®');
                if (marketChart) {
                    marketChart.destroy();
                    marketChart = null;
                }
                marketChartContainer?.classList.add('hidden');
                return;
            }

            const sortedLabels = Array.from(labelMeta.entries())
                .sort((a, b) => {
                    const aKey = a[1].ts !== null ? a[1].ts : Number.MAX_SAFE_INTEGER;
                    const bKey = b[1].ts !== null ? b[1].ts : Number.MAX_SAFE_INTEGER;
                    if (aKey !== bKey) return aKey - bKey;
                    return a[1].index - b[1].index;
                })
                .map(entry => entry[0]);

            if (!sortedLabels.length) {
                marketInfoText && (marketInfoText.textContent = 'å½“å‰ç­›é€‰ä¸‹ç¼ºå°‘æœ‰æ•ˆæ—¥æœŸ');
                marketChartContainer?.classList.add('hidden');
                return;
            }

            const palettes = [
                '#667eea',
                '#ff6b6b',
                '#20c997',
                '#f9a826',
                '#845ef7',
                '#17a2b8',
                '#ff9f43',
                '#6f42c1'
            ];

            const datasets = [];

            seriesData.forEach((series, index) => {
                const color = palettes[index % palettes.length];
                const gp20Values = [];
                const gp40Values = [];

                sortedLabels.forEach(label => {
                    const record = series.values.get(label);
                    gp20Values.push(record?.gp20 ?? null);
                    gp40Values.push(record?.gp40 ?? null);
                });

                datasets.push({
                    label: `${series.port} - 20GP`,
                    data: gp20Values,
                    borderColor: color,
                    backgroundColor: 'transparent',
                    tension: 0.4,
                    fill: false,
                    borderWidth: 2,
                    spanGaps: true
                });

                datasets.push({
                    label: `${series.port} - 40GP`,
                    data: gp40Values,
                    borderColor: color,
                    backgroundColor: 'transparent',
                    borderDash: [6, 4],
                    tension: 0.4,
                    fill: false,
                    borderWidth: 2,
                    spanGaps: true
                });
            });

            if (marketChart) {
                marketChart.destroy();
            }

            const ctx = document.getElementById('marketTrendChart').getContext('2d');
            marketChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: sortedLabels,
                    datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback(value) {
                                    return '$' + value;
                                }
                            },
                            title: {
                                display: true,
                                text: 'ä»·æ ¼ (USD)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'æ—¥æœŸ'
                            },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45
                            }
                        }
                    }
                }
            });

            marketChartContainer?.classList.remove('hidden');
            marketDateControls?.classList.remove('hidden');

            if (marketInfoText) {
                const labelCount = sortedLabels.length;
                let infoText = `å·²é€‰æ‹© ${seriesData.length} ä¸ªæ¸¯å£ï¼ˆ${selectedPorts.join('ã€')}ï¼‰ï¼Œå…± ${labelCount} ä¸ªæ—¶é—´èŠ‚ç‚¹`;
                
                // è®¡ç®—æ¯ä¸ªæ¸¯å£çš„ä»·æ ¼èŒƒå›´
                const priceRanges = [];
                seriesData.forEach(series => {
                    const gp20Prices = [];
                    const gp40Prices = [];
                    
                    sortedLabels.forEach(label => {
                        const record = series.values.get(label);
                        if (record?.gp20 !== null && record?.gp20 !== undefined) {
                            gp20Prices.push(record.gp20);
                        }
                        if (record?.gp40 !== null && record?.gp40 !== undefined) {
                            gp40Prices.push(record.gp40);
                        }
                    });
                    
                    if (gp20Prices.length > 0 || gp40Prices.length > 0) {
                        const gp20Min = gp20Prices.length > 0 ? Math.min(...gp20Prices) : null;
                        const gp20Max = gp20Prices.length > 0 ? Math.max(...gp20Prices) : null;
                        const gp40Min = gp40Prices.length > 0 ? Math.min(...gp40Prices) : null;
                        const gp40Max = gp40Prices.length > 0 ? Math.max(...gp40Prices) : null;
                        
                        let rangeText = `${series.port}ï¼š`;
                        const parts = [];
                        if (gp20Min !== null && gp20Max !== null) {
                            parts.push(`20GP ${gp20Min.toLocaleString()} ~ ${gp20Max.toLocaleString()}`);
                        }
                        if (gp40Min !== null && gp40Max !== null) {
                            parts.push(`40GP ${gp40Min.toLocaleString()} ~ ${gp40Max.toLocaleString()}`);
                        }
                        if (parts.length > 0) {
                            rangeText += parts.join('ï¼Œ');
                            priceRanges.push(rangeText);
                        }
                    }
                });
                
                // å°†ä»·æ ¼èŒƒå›´ä¿¡æ¯æ·»åŠ åˆ°ä¸»æ–‡æœ¬ä¸­ï¼Œå¦‚æœå†…å®¹è¾ƒé•¿åˆ™åˆ†è¡Œæ˜¾ç¤º
                if (priceRanges.length > 0) {
                    infoText += '\n' + priceRanges.join('\n');
                }
                
                marketInfoText.textContent = infoText;
            }
        }
    </script>

    <script>
        let scheduleData = [];
        let processedRecords = [];
        let groupedTableData = [];
        let latestFilteredRecords = [];
        let destinationHierarchy = {};
        let destinationFilters = {
            areas: [],
            subAreas: [],
            countries: [],
            ports: []
        };
        let currentView = 'all'; // 'all', 'capacity', 'ships'
        let weekColumns = []; // å½“å‘¨+æœªæ¥å››å‘¨ï¼ˆå…±5å‘¨ï¼‰
        let capacityChart = null; // Chart.jså®ä¾‹
        let routeFilterValue = '';
        let routeLabelMap = {};
        let routePathMap = {}; // å­˜å‚¨routeId -> routePathçš„æ˜ å°„

        const infoBox = document.getElementById('infoBox');
        const infoText = document.getElementById('infoText');
        const tableContainer = document.getElementById('tableContainer');
        const tableHead = document.getElementById('tableHead');
        const tableBody = document.getElementById('tableBody');
        const viewToggle = document.getElementById('viewToggle');
        const btnAll = document.getElementById('btnAll');
        const btnCapacity = document.getElementById('btnCapacity');
        const btnShips = document.getElementById('btnShips');
        const destinationFiltersPanel = document.getElementById('destinationFilters');
        const areaSelect = document.getElementById('areaSelect');
        const subAreaSelect = document.getElementById('subAreaSelect');
        const countrySelect = document.getElementById('countrySelect');
        const portSelect = document.getElementById('portSelect');

        // getSelectedValues å’Œ setupMultiSelect å·²ä» vendor/common-utils.js åŠ è½½

        // normalizeDestinationValue, registerRouteLabel, getRouteLabel å·²ä» vendor/market-analysis-utils.js åŠ è½½

        function addToDestinationHierarchy(area, subArea, country, port) {
            const areaKey = area || 'æœªåˆ†é…';
            const subAreaKey = subArea || 'æœªåˆ†é…';
            const countryKey = country || 'æœªåˆ†é…';
            const portKey = port || 'æœªåˆ†é…';

            if (!destinationHierarchy[areaKey]) {
                destinationHierarchy[areaKey] = { subAreas: {} };
            }
            if (!destinationHierarchy[areaKey].subAreas[subAreaKey]) {
                destinationHierarchy[areaKey].subAreas[subAreaKey] = { countries: {} };
            }
            if (!destinationHierarchy[areaKey].subAreas[subAreaKey].countries[countryKey]) {
                destinationHierarchy[areaKey].subAreas[subAreaKey].countries[countryKey] = { ports: new Set() };
            }
            destinationHierarchy[areaKey]
                .subAreas[subAreaKey]
                .countries[countryKey]
                .ports
                .add(portKey);
        }

        // populateSelect å‡½æ•°å·²ä» vendor/market-analysis-utils.js åŠ è½½
        // æœ¬åœ°çš„ populateSelect å‡½æ•°å·²è¢«ç§»é™¤ï¼Œç»Ÿä¸€ä½¿ç”¨ vendor ä¸­çš„ç‰ˆæœ¬ä»¥æ”¯æŒ useAreaOrder å’Œ usePortOrder å‚æ•°
        // å¦‚æœéœ€è¦è°ƒç”¨ï¼Œç›´æ¥ä½¿ç”¨ populateSelect å³å¯ï¼ˆå®ƒä¼šä½¿ç”¨å…¨å±€å‡½æ•°ï¼‰

        function collectCountryOptions(area, selectedSubAreas) {
            if (!area || !selectedSubAreas || !selectedSubAreas.length) return [];
            const subAreaMap = destinationHierarchy[area]?.subAreas || {};
            const set = new Set();
            selectedSubAreas.forEach(subArea => {
                const countries = subAreaMap[subArea]?.countries || {};
                Object.keys(countries).forEach(country => set.add(country));
            });
            return Array.from(set);
        }

        function collectPortOptions(area, selectedSubAreas, selectedCountries) {
            if (!area || !selectedSubAreas?.length || !selectedCountries?.length) return [];
            const subAreaMap = destinationHierarchy[area]?.subAreas || {};
            const set = new Set();
            selectedSubAreas.forEach(subArea => {
                const countriesMap = subAreaMap[subArea]?.countries || {};
                selectedCountries.forEach(country => {
                    const portsSet = countriesMap[country]?.ports || new Set();
                    portsSet.forEach(port => set.add(port));
                });
            });
            return Array.from(set);
        }

        function collectSubAreaOptions(selectedAreas) {
            if (!selectedAreas?.length) return [];
            const set = new Set();
            selectedAreas.forEach(area => {
                const subMap = destinationHierarchy[area]?.subAreas || {};
                Object.keys(subMap).forEach(sub => set.add(sub));
            });
            return Array.from(set);
        }

        function collectCountryOptions(selectedAreas, selectedSubAreas) {
            if (!selectedAreas?.length) return [];
            const set = new Set();
            selectedAreas.forEach(area => {
                const subMap = destinationHierarchy[area]?.subAreas || {};
                const subKeys = selectedSubAreas.length ? selectedSubAreas : Object.keys(subMap);
                subKeys.forEach(sub => {
                    const countries = subMap[sub]?.countries || {};
                    Object.keys(countries).forEach(country => set.add(country));
                });
            });
            return Array.from(set);
        }

        function collectPortOptions(selectedAreas, selectedSubAreas, selectedCountries) {
            if (!selectedAreas?.length) return [];
            const set = new Set();
            selectedAreas.forEach(area => {
                const subMap = destinationHierarchy[area]?.subAreas || {};
                const subKeys = selectedSubAreas.length ? selectedSubAreas : Object.keys(subMap);
                subKeys.forEach(sub => {
                    const countriesMap = subMap[sub]?.countries || {};
                    const countryKeys = selectedCountries.length ? selectedCountries : Object.keys(countriesMap);
                    countryKeys.forEach(country => {
                        const portsSet = countriesMap[country]?.ports || new Set();
                        portsSet.forEach(port => set.add(port));
                    });
                });
            });
            return Array.from(set);
        }

        function updateDestinationFilterOptions() {
            const areaOptions = Object.keys(destinationHierarchy || {});
            destinationFilters.areas = destinationFilters.areas.filter(value => areaOptions.includes(value));
            if (!destinationFilters.areas.length) {
                destinationFilters.subAreas = [];
                destinationFilters.countries = [];
                destinationFilters.ports = [];
            }

            const subAreaOptions = destinationFilters.areas.length
                ? collectSubAreaOptions(destinationFilters.areas)
                : [];
            destinationFilters.subAreas = destinationFilters.subAreas.filter(value => subAreaOptions.includes(value));
            if (!destinationFilters.subAreas.length) {
                destinationFilters.countries = [];
                destinationFilters.ports = [];
            }

            const countryOptions = destinationFilters.areas.length
                ? collectCountryOptions(destinationFilters.areas, destinationFilters.subAreas)
                : [];
            destinationFilters.countries = destinationFilters.countries.filter(value => countryOptions.includes(value));
            if (!destinationFilters.countries.length) {
                destinationFilters.ports = [];
            }

            const portOptions = destinationFilters.areas.length
                ? collectPortOptions(
                    destinationFilters.areas,
                    destinationFilters.subAreas,
                    destinationFilters.countries
                )
                : [];
            destinationFilters.ports = destinationFilters.ports.filter(value => portOptions.includes(value));

            // ä½¿ç”¨æ ‡å‡†åŒºåŸŸé¡ºåºæ’åºï¼ˆä¸¥æ ¼æŒ‰ç…§ STANDARD_AREA_ORDER çš„é¡ºåºï¼‰
            // å¤„ç†åŒºåŸŸåç§°å˜ä½“ï¼ˆå¦‚"ä¸­ä¸œå°å·´çº¢æµ·" -> "ä¸­ä¸œçº¢æµ·å°å·´"ï¼‰
            const normalizeAreaName = (areaName) => {
                if (!areaName) return areaName;
                // å¦‚æœåŒ…å«"ä¸­ä¸œ"ã€"å°å·´"ã€"çº¢æµ·"è¿™äº›å…³é”®è¯ï¼Œç»Ÿä¸€æ˜ å°„åˆ°"ä¸­ä¸œçº¢æµ·å°å·´"
                if (areaName.includes('ä¸­ä¸œ') && (areaName.includes('å°å·´') || areaName.includes('çº¢æµ·'))) {
                    return 'ä¸­ä¸œçº¢æµ·å°å·´';
                }
                return areaName;
            };
            
            // ç¡®ä¿ä½¿ç”¨æ ‡å‡†åŒºåŸŸé¡ºåºæ’åº
            // æ³¨æ„ï¼šç›´æ¥ä½¿ç”¨ useAreaOrder=trueï¼Œè®© populateSelect å†…éƒ¨å¤„ç†æ’åº
            // è¿™æ ·å¯ä»¥ç¡®ä¿æ’åºé€»è¾‘ç»Ÿä¸€ï¼Œé¿å…é‡å¤æ’åº
            populateSelect(areaSelect, areaOptions, 'å…¨éƒ¨åŒºåŸŸ', destinationFilters.areas, false, false, true);
            populateSelect(
                subAreaSelect,
                subAreaOptions,
                'å…¨éƒ¨å­åŒºåŸŸ',
                destinationFilters.subAreas,
                !destinationFilters.areas.length
            );
            populateSelect(
                countrySelect,
                countryOptions,
                'å…¨éƒ¨å›½å®¶ / åœ°åŒº',
                destinationFilters.countries,
                !(destinationFilters.areas.length && destinationFilters.subAreas.length)
            );
            populateSelect(
                portSelect,
                portOptions,
                'å…¨éƒ¨æ¸¯å£',
                destinationFilters.ports,
                !(destinationFilters.areas.length && destinationFilters.subAreas.length && destinationFilters.countries.length)
            );
        }


        function getCurrentGroupLevel() {
            if (destinationFilters.ports.length > 0) return 4;
            if (destinationFilters.countries.length > 0) return 3;
            if (destinationFilters.subAreas.length > 0) return 2;
            if (destinationFilters.areas.length > 0) return 1;
            return 0;
        }

        function getFilteredRecords() {
            const routeFilterText = routeFilterValue.trim().toLowerCase();
            const weekCodes = getWeekRange();
            const filtered = processedRecords.filter(record => {
                if (destinationFilters.areas.length && !destinationFilters.areas.includes(record.area)) return false;
                if (destinationFilters.subAreas.length && !destinationFilters.subAreas.includes(record.subArea)) return false;
                if (destinationFilters.countries.length && !destinationFilters.countries.includes(record.country)) return false;
                if (destinationFilters.ports.length && !destinationFilters.ports.includes(record.port)) return false;
                if (!weekCodes.includes(record.weekCode)) return false;
                if (routeFilterText) {
                    const routeText = String(record.routeLabel || record.route || '').toLowerCase();
                    if (!routeText.includes(routeFilterText)) return false;
                }
                return true;
            });
            // ç»Ÿä¸€å»é‡ï¼ˆä½¿ç”¨ vendor ä¸­çš„æ ‡å‡†å‡½æ•°ï¼‰
            if (typeof deduplicateSailingItems === 'function') {
                return deduplicateSailingItems(filtered);
            }
            return filtered;
        }

        // buildShipSignature å·²ä» vendor/market-analysis-utils.js åŠ è½½

        function buildDedupKey(record, groupLevel) {
            const safe = value => (value && value.trim() ? value.trim() : 'æœªåˆ†é…');
            const routeId = record.routeId && record.routeId.trim ? record.routeId.trim() : (record.routeId || '');
            const shipSignature = buildShipSignature(record);

            if (groupLevel >= 4) {
                return `port|${shipSignature}`;
            }

            if (groupLevel === 3) {
                return routeId ? `country|${routeId}` : `country|${shipSignature}`;
            }

            if (groupLevel === 2) {
                const country = safe(record.country || '');
                return routeId ? `countryLayer|${country}|${routeId}` : `countryLayer|${country}|${shipSignature}`;
            }

            const subArea = safe(record.subArea || '');
            return routeId ? `area|${subArea}|${routeId}` : `area|${subArea}|${shipSignature}`;
        }

        function groupRecords(records) {
            const groups = new Map();

            records.forEach(record => {
                const routeLabel = record.routeLabel || record.route || 'æœªçŸ¥èˆªçº¿';
                const routeKey = record.routeId || routeLabel;
                const routeRemark = record.routeRemark || '';
                const routePath = record.routePath || routePathMap[record.routeId] || '';

                // ä½¿ç”¨routeIdä½œä¸ºå”¯ä¸€key
                const key = routeKey;

                if (!groups.has(key)) {
                    groups.set(key, {
                        routeLabel,
                        routeId: record.routeId || '',
                        routeRemark,
                        routePath,
                        weeks: {}
                    });
                }

                const group = groups.get(key);
                if (!group.weeks[record.weekCode]) {
                    group.weeks[record.weekCode] = [];
                }

                const entries = group.weeks[record.weekCode];
                // å»é‡æ—¶åªè€ƒè™‘èˆ¹åèˆªæ¬¡+è¿åŠ›+æ—¥æœŸï¼Œä¸è€ƒè™‘æ¸¯å£ï¼Œè¿™æ ·å¤šé€‰æ¸¯å£æ—¶åŒä¸€èˆ¹åèˆªæ¬¡ä¼šåˆå¹¶æ˜¾ç¤º
                const dedupKey = buildShipSignature(record);
                const exists = entries.some(item => item.dedupKey === dedupKey);
                if (exists) {
                    return;
                }
                entries.push({
                    capacity: record.capacity,
                    shipName: record.shipName,
                    shipDate: record.shipDate,
                    routeId: record.routeId || '',
                    dedupKey
                });
            });

            const sorted = Array.from(groups.values()).sort((a, b) => {
                return (a.routeLabel || '').localeCompare(b.routeLabel || '');
            });

            return {
                data: sorted,
                level: 0
            };
        }

        fileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            // æ£€æŸ¥ XLSX æ˜¯å¦å·²åŠ è½½
            if (typeof XLSX === 'undefined') {
                showError(ErrorType.FILE_LOAD, 'XLSX_NOT_LOADED');
                return;
            }

            try {
                const data = await readExcelFile(file);
                scheduleData = data;
                generatePivotTable(data);
                infoText.textContent = `å·²åŠ è½½ ${data.length} æ¡èˆ¹æœŸæ•°æ®`;
                infoBox.classList.remove('hidden');
                excelLoadState.schedule = true;
                tryRevealModules();
            } catch (error) {
                showError(ErrorType.FILE_LOAD, 'FILE_READ_FAILED', { message: error.message }, error);
                debugError(error);
            }
        });

        btnAll.addEventListener('click', () => {
            currentView = 'all';
            btnAll.classList.add('active');
            btnCapacity.classList.remove('active');
            btnShips.classList.remove('active');
            renderTable();
        });

        btnCapacity.addEventListener('click', () => {
            currentView = 'capacity';
            btnAll.classList.remove('active');
            btnCapacity.classList.add('active');
            btnShips.classList.remove('active');
            renderTable();
        });

        btnShips.addEventListener('click', () => {
            currentView = 'ships';
            btnAll.classList.remove('active');
            btnCapacity.classList.remove('active');
            btnShips.classList.add('active');
            renderTable();
        });

        if (areaSelect) {
            setupMultiSelect(areaSelect);
            areaSelect.addEventListener('change', () => {
                destinationFilters.areas = getSelectedValues(areaSelect);
                if (!destinationFilters.areas.length) {
                    destinationFilters.subAreas = [];
                    destinationFilters.countries = [];
                    destinationFilters.ports = [];
                }
                updateDestinationFilterOptions();
                renderTable();
            });
        }

        if (subAreaSelect) {
            setupMultiSelect(subAreaSelect);
            subAreaSelect.addEventListener('change', () => {
                destinationFilters.subAreas = getSelectedValues(subAreaSelect);
                destinationFilters.countries = [];
                destinationFilters.ports = [];
                updateDestinationFilterOptions();
                renderTable();
            });
        }

        if (countrySelect) {
            setupMultiSelect(countrySelect);
            countrySelect.addEventListener('change', () => {
                destinationFilters.countries = getSelectedValues(countrySelect);
                destinationFilters.ports = [];
                updateDestinationFilterOptions();
                renderTable();
            });
        }

        if (portSelect) {
            setupMultiSelect(portSelect);
            portSelect.addEventListener('change', () => {
                destinationFilters.ports = getSelectedValues(portSelect);
                updateDestinationFilterOptions();
                renderTable();
            });
        }

        // ç»‘å®š"å…¨éƒ¨é€‰æ‹©"å’Œ"æ¸…é™¤é€‰æ‹©"æŒ‰é’®äº‹ä»¶
        // è¿è´¹èµ°åŠ¿æ¨¡å—
        const marketRegionSelectAll = document.getElementById('marketRegionSelectAll');
        const marketRegionClear = document.getElementById('marketRegionClear');
        const marketPortSelectAll = document.getElementById('marketPortSelectAll');
        const marketPortClear = document.getElementById('marketPortClear');
        
        if (marketRegionSelectAll && marketRegionSelect) {
            marketRegionSelectAll.addEventListener('click', () => selectAllOptions(marketRegionSelect));
        }
        if (marketRegionClear && marketRegionSelect) {
            marketRegionClear.addEventListener('click', () => clearSelectOptions(marketRegionSelect));
        }
        if (marketPortSelectAll && marketPortSelect) {
            marketPortSelectAll.addEventListener('click', () => selectAllOptions(marketPortSelect));
        }
        if (marketPortClear && marketPortSelect) {
            marketPortClear.addEventListener('click', () => clearSelectOptions(marketPortSelect));
        }
        
        // èˆªçº¿è¿åŠ›åˆ†ææ¨¡å—
        const areaSelectAll = document.getElementById('areaSelectAll');
        const areaClearAll = document.getElementById('areaClearAll');
        const subAreaSelectAll = document.getElementById('subAreaSelectAll');
        const subAreaClearAll = document.getElementById('subAreaClearAll');
        const countrySelectAll = document.getElementById('countrySelectAll');
        const countryClearAll = document.getElementById('countryClearAll');
        const portSelectAll = document.getElementById('portSelectAll');
        const portClearAll = document.getElementById('portClearAll');
        
        if (areaSelectAll && areaSelect) {
            areaSelectAll.addEventListener('click', () => selectAllOptions(areaSelect));
        }
        if (areaClearAll && areaSelect) {
            areaClearAll.addEventListener('click', () => clearSelectOptions(areaSelect));
        }
        if (subAreaSelectAll && subAreaSelect) {
            subAreaSelectAll.addEventListener('click', () => selectAllOptions(subAreaSelect));
        }
        if (subAreaClearAll && subAreaSelect) {
            subAreaClearAll.addEventListener('click', () => clearSelectOptions(subAreaSelect));
        }
        if (countrySelectAll && countrySelect) {
            countrySelectAll.addEventListener('click', () => selectAllOptions(countrySelect));
        }
        if (countryClearAll && countrySelect) {
            countryClearAll.addEventListener('click', () => clearSelectOptions(countrySelect));
        }
        if (portSelectAll && portSelect) {
            portSelectAll.addEventListener('click', () => selectAllOptions(portSelect));
        }
        if (portClearAll && portSelect) {
            portClearAll.addEventListener('click', () => clearSelectOptions(portSelect));
        }

        async function readExcelFile(file) {
            return new Promise((resolve, reject) => {
                if (typeof XLSX === 'undefined') {
                    reject(new Error('XLSX åº“æœªåŠ è½½ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•'));
                    return;
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, { type: 'array' });
                        
                        // æŸ¥æ‰¾ schedule å·¥ä½œè¡¨
                        const sheetName = workbook.SheetNames.find(name => 
                            name.toLowerCase().includes('schedule')
                        ) || workbook.SheetNames[0];
                        
                        const worksheet = workbook.Sheets[sheetName];
                        const jsonData = XLSX.utils.sheet_to_json(worksheet);
                        resolve(jsonData);
                    } catch (error) {
                        reject(error);
                    }
                };
                reader.onerror = reject;
                reader.readAsArrayBuffer(file);
            });
        }

        // å°†å‘¨åˆ«æ–‡æœ¬è½¬æ¢ä¸ºYYYYWWæ ¼å¼ï¼ˆå¦‚ï¼š202547ï¼‰
        // parseWeekText, getCurrentWeekCode, getWeekRange, getWeekNumber, getISOWeek, getWeekDateRange å·²ä» vendor/market-analysis-utils.js åŠ è½½


        function generatePivotTable(data) {
            if (!data || data.length === 0) {
                showError(ErrorType.DATA_VALIDATION, 'DATA_EMPTY');
                return;
            }

            const firstRow = data[0];
            const columnKeys = Object.keys(firstRow);

            const matchesKeyword = (key, keyword) => {
                if (!key) return false;
                const lowerKey = key.toLowerCase();
                return lowerKey.includes(keyword.toLowerCase()) || key.includes(keyword);
            };

            const findColumnKey = (keywords, fallbackIndex = null) => {
                const key = columnKeys.find(col =>
                    keywords.some(keyword => matchesKeyword(col, keyword))
                );
                if (key) return key;
                if (typeof fallbackIndex === 'number' && columnKeys[fallbackIndex]) {
                    return columnKeys[fallbackIndex];
                }
                return null;
            };

            const weekCol = findColumnKey(['å‘¨åˆ«', 'å‘¨æ¬¡', 'å‘¨æ•°', 'week'], 17);
            const capacityCol = findColumnKey(['è¿åŠ›', 'teu', 'èˆ±ä½'], 18);
            const shipNameCol = findColumnKey(['èˆ¹å', 'èˆªæ¬¡', 'vessel'], 11);
            const shipDateCol = findColumnKey(['å¼€èˆ¹', 'èˆ¹æœŸ', 'ç¦»æ¸¯', 'etd', 'æ—¶é—´'], 12);
            const routeIdCol = findColumnKey(['èˆªçº¿id', 'èˆªçº¿ID', 'route id', 'group_id', 'groupid'], 6);

            const routeCol =
                columnKeys.find(col => matchesKeyword(col, 'å…±èˆ±')) ||
                columnKeys.find(col => matchesKeyword(col, 'èˆ¹å…¬å¸')) ||
                columnKeys.find(col => matchesKeyword(col, 'èˆªçº¿') && !matchesKeyword(col, 'id')) ||
                columnKeys.find(col => matchesKeyword(col, 'route')) ||
                (columnKeys[9] || null);
            const routeRemarkCol = columnKeys[10] || null; // Kåˆ—ï¼ˆç´¢å¼•10ï¼‰
            const routePathCol = columnKeys[24] || null; // Yåˆ—ï¼ˆç´¢å¼•24ï¼‰
            const areaCol = findColumnKey(['åŒºåŸŸ', 'å¤§åŒº', 'region']);
            const subAreaCol = findColumnKey(['å­åŒºåŸŸ', 'æ¬¡åŒºåŸŸ', 'sub'], null);
            const countryCol = findColumnKey(['å›½å®¶åœ°åŒº', 'å›½å®¶/åœ°åŒº', 'å›½å®¶', 'country'], null);
            const portCol = findColumnKey(['æ¸¯å£', 'ç›®çš„æ¸¯', 'pod'], 1);

            if (!weekCol || !capacityCol || !shipNameCol || !shipDateCol || !routeCol) {
                showError(ErrorType.FILE_PARSE, 'MISSING_COLUMNS', { columns: columnKeys.join(', ') });
                return;
            }

            // å›ºå®šæ˜¾ç¤ºå½“å‘¨+æœªæ¥4å‘¨ï¼ˆå…±5å‘¨ï¼‰
            const weekCodes = getWeekRange();
            weekColumns = weekCodes.map(code => {
                const year = code.substring(0, 4);
                const weekNo = parseInt(code.substring(4), 10);
                const dateRange = getWeekDateRange(code);
                return {
                    code,
                    label: `${year}/${String(weekNo).padStart(2, '0')}`,
                    range: dateRange.range
                };
            });

            processedRecords = [];
            destinationHierarchy = {};
            destinationFilters = { areas: [], subAreas: [], countries: [], ports: [] };
            routeFilterValue = '';
            routeLabelMap = {};

            data.forEach(row => {
                const weekText = String(row[weekCol] ?? '').trim();
                const weekCode = parseWeekText(weekText);
                if (!weekCode) {
                    return;
                }

                const area = normalizeDestinationValue(row[areaCol]);
                const subArea = normalizeDestinationValue(row[subAreaCol]);
                const country = normalizeDestinationValue(row[countryCol]);
                const port = normalizeDestinationValue(row[portCol]);
                let route = String(row[routeCol] ?? '').trim();
                const routeId = routeIdCol ? String(row[routeIdCol] ?? '').trim() : '';
                const routeRemark = routeRemarkCol ? String(row[routeRemarkCol] ?? '').trim() : '';
                const routePath = routePathCol ? String(row[routePathCol] ?? '').trim() : '';
                const capacity = parseFloat(row[capacityCol]) || 0;
                const shipName = String(row[shipNameCol] ?? '').trim();
                const shipDate = String(row[shipDateCol] ?? '').trim();

                if (!route) {
                    route = 'æœªçŸ¥èˆªçº¿';
                }

                if (routeId) {
                    if (route && route !== 'æœªçŸ¥èˆªçº¿') {
                        registerRouteLabel(routeId, route);
                    }
                    route = getRouteLabel(routeId, route);
                    // å­˜å‚¨è·¯å¾„ä¿¡æ¯
                    if (routePath) {
                        routePathMap[routeId] = routePath;
                    }
                }

                const record = {
                    area,
                    subArea,
                    country,
                    port,
                    route,
                    routeId,
                    routeRemark,
                    routePath,
                    weekCode,
                    capacity,
                    shipName,
                    shipDate
                };
                processedRecords.push(record);
                addToDestinationHierarchy(area, subArea, country, port);
            });

            processedRecords = processedRecords.map(record => ({
                ...record,
                routeLabel: getRouteLabel(record.routeId, record.route)
            }));
            if (processedRecords.length === 0) {
                showError(ErrorType.FILE_PARSE, 'NO_SCHEDULE_DATA');
                return;
            }

            // ç­›é€‰æ§ä»¶åœ¨ tryRevealModules() ä¸­ç»Ÿä¸€æ˜¾ç¤º
            updateDestinationFilterOptions();
            renderTable();
            updateAiAnalysis(false);
        }

        function renderTable() {
            if (!processedRecords.length) {
                tableContainer.classList.add('hidden');
                updateChart(false, []);
                updateAiAnalysis(false);
                return;
            }

            // å›ºå®šæ˜¾ç¤ºå½“å‘¨+æœªæ¥4å‘¨ï¼ˆå…±5å‘¨ï¼‰
            const weekCodes = getWeekRange();
            weekColumns = weekCodes.map(code => {
                const year = code.substring(0, 4);
                const weekNo = parseInt(code.substring(4), 10);
                const dateRange = getWeekDateRange(code);
                return {
                    code,
                    label: `${year}/${String(weekNo).padStart(2, '0')}`,
                    range: dateRange.range
                };
            });

            const filteredRecords = getFilteredRecords();
            latestFilteredRecords = filteredRecords;
            const groupedResult = groupRecords(filteredRecords);
            const groupedData = groupedResult.data;
            groupedTableData = groupedData;
            const hasAreaSelected = destinationFilters.areas.length > 0;

            const safeRouteValue = (routeFilterValue || '').replace(/"/g, '&quot;');

            tableHead.innerHTML = `
                <tr>
                    <th class="filter-header" style="width: 200px;">èˆªçº¿å¤‡æ³¨</th>
                    <th class="filter-header">
                        å…±èˆ±èˆ¹å…¬å¸
                        <input type="text" class="filter-input" id="routeFilter" placeholder="ç­›é€‰å…±èˆ±èˆ¹å…¬å¸..." value="${safeRouteValue}" autocomplete="off">
                    </th>
                    ${weekColumns.map(week => `
                        <th class="week-header week-cell">
                            <div>${week.label}</div>
                            ${week.range ? `<div style="font-size: 11px; font-weight: normal; margin-top: 4px; opacity: 0.9;">(${week.range})</div>` : ''}
                        </th>
                    `).join('')}
                </tr>
            `;

            const routeFilter = document.getElementById('routeFilter');
            if (routeFilter) {
                let composing = false;
                const newRouteFilter = routeFilter.cloneNode(true);
                routeFilter.parentNode.replaceChild(newRouteFilter, routeFilter);
                newRouteFilter.addEventListener('compositionstart', function() {
                    composing = true;
                });
                newRouteFilter.addEventListener('compositionend', function() {
                    composing = false;
                    routeFilterValue = this.value;
                    setTimeout(() => {
                        renderTable();
                    }, 0);
                });
                newRouteFilter.addEventListener('input', function() {
                    if (!composing) {
                        routeFilterValue = this.value;
                        clearTimeout(newRouteFilter._inputTimeout);
                        newRouteFilter._inputTimeout = setTimeout(() => {
                            renderTable();
                        }, 300);
                    }
                });
            }

            tableBody.innerHTML = '';
            groupedData.forEach(item => {
                const row = document.createElement('tr');
                const routePath = item.routePath || routePathMap[item.routeId] || '';
                const routePathAttr = routePath ? `data-tooltip="${routePath.replace(/"/g, '&quot;')}"` : '';
                const routeCellClass = routePath ? 'hover-cell' : '';
                const cells = [
                    `<td>${item.routeRemark || 'â€”'}</td>`,
                    `<td class="${routeCellClass}" ${routePathAttr}>${item.routeLabel || 'æœªçŸ¥èˆªçº¿'}</td>`
                ];

                weekColumns.forEach((week) => {
                    const weekCode = week.code;
                    const ships = item.weeks[weekCode] || [];
                    
                    // è®¡ç®—è¯¥å‘¨çš„è¿åŠ›å’Œæ´¾èˆ¹æ•°
                    const totalCapacity = ships.reduce((sum, ship) => sum + (ship.capacity || 0), 0);
                    const shipCount = ships.length;
                    
                    // æ„å»ºtooltipå†…å®¹ï¼ˆèˆ¹åèˆªæ¬¡ã€è¿åŠ›å’Œå¼€èˆ¹æ—¥æœŸï¼‰
                    let tooltipData = '';
                    if (ships.length > 0) {
                        const shipDetails = ships.map(ship => {
                            const name = ship.shipName || 'æœªçŸ¥';
                            const capacity = ship.capacity || 0;
                            let date = ship.shipDate || 'æœªçŸ¥';
                            
                            // æ ¼å¼åŒ–æ—¥æœŸä¸º YYYY/MM/DD
                            // ä½¿ç”¨ç»Ÿä¸€çš„æ—¥æœŸè§£æå’Œæ ¼å¼åŒ–å‡½æ•°
                            if (date && date !== 'æœªçŸ¥') {
                                date = formatDateToYYYYMMDD(date);
                            }
                            
                            // æ ¼å¼ï¼šèˆ¹åèˆªæ¬¡ è¿åŠ›TEU (æ—¥æœŸ) - ç¡®ä¿ä¸€è¡Œæ˜¾ç¤º
                            const capacityStr = capacity > 0 ? `${capacity.toLocaleString()} TEU` : '0 TEU';
                            return `${name} ${capacityStr} (${date})`;
                        }).join('\n');
                        tooltipData = shipDetails;
                    }
                    
                    let cellContent = '';
                    if (currentView === 'all') {
                        cellContent = `è¿åŠ›: ${totalCapacity.toLocaleString()} TEU<br>æ´¾èˆ¹: ${shipCount}`;
                    } else if (currentView === 'capacity') {
                        cellContent = totalCapacity.toLocaleString() + ' TEU';
                    } else if (currentView === 'ships') {
                        cellContent = shipCount.toString();
                    }
                    
                    // å¦‚æœæœ‰æ•°æ®ï¼Œæ·»åŠ tooltipå’Œæ‚¬åœæ ·å¼
                    const cellClass = ships.length > 0 ? 'number-cell hover-cell' : 'number-cell';
                    const tooltipAttr = tooltipData ? `data-tooltip="${tooltipData.replace(/"/g, '&quot;')}"` : '';
                    cells.push(`<td class="${cellClass}" ${tooltipAttr}>${cellContent}</td>`);
                });

                row.innerHTML = cells.join('');
                tableBody.appendChild(row);
            });
            
            const hasDestinationSelection = Boolean(
                destinationFilters.areas.length ||
                destinationFilters.subAreas.length ||
                destinationFilters.countries.length ||
                destinationFilters.ports.length ||
                routeFilterValue.trim()
            );
            const hasAreaSelection = destinationFilters.areas.length > 0;

            if (hasDestinationSelection && groupedData.length > 0) {
                const summaryRow = document.createElement('tr');
                summaryRow.className = 'summary-row';
                const summaryCells = [
                    '<td><strong>åˆè®¡</strong></td>',
                    '<td></td>'
                ];

                let totalCapacityByWeek = {};
                let totalShipsByWeek = {};
                
                // è®¡ç®—æ¯å‘¨çš„åˆè®¡
                groupedData.forEach(item => {
                    weekColumns.forEach((week) => {
                        const weekCode = week.code;
                        const ships = item.weeks[weekCode] || [];
                        const weekCapacity = ships.reduce((sum, ship) => sum + (ship.capacity || 0), 0);
                        const weekShips = ships.length;
                        
                        if (!totalCapacityByWeek[weekCode]) {
                            totalCapacityByWeek[weekCode] = 0;
                            totalShipsByWeek[weekCode] = 0;
                        }
                        totalCapacityByWeek[weekCode] += weekCapacity;
                        totalShipsByWeek[weekCode] += weekShips;
                    });
                });
                
                weekColumns.forEach((week) => {
                    const weekCode = week.code;
                    const totalCapacity = totalCapacityByWeek[weekCode] || 0;
                    const totalShips = totalShipsByWeek[weekCode] || 0;
                    
                    let cellContent = '';
                    if (currentView === 'all') {
                        cellContent = `è¿åŠ›: ${totalCapacity.toLocaleString()} TEU<br>æ´¾èˆ¹: ${totalShips}`;
                    } else if (currentView === 'capacity') {
                        cellContent = `${totalCapacity.toLocaleString()} TEU`;
                    } else if (currentView === 'ships') {
                        cellContent = `${totalShips}`;
                    }
                    
                    summaryCells.push(`<td class="number-cell"><strong>${cellContent}</strong></td>`);
                });
                
                summaryRow.innerHTML = summaryCells.join('');
                tableBody.appendChild(summaryRow);
            }

            // æ·»åŠ tooltipäº‹ä»¶ç›‘å¬ï¼ˆåŒ…æ‹¬å‘¨åˆ«å•å…ƒæ ¼å’Œå…±èˆ±èˆ¹å…¬å¸å•å…ƒæ ¼ï¼‰
            const hoverCells = tableBody.querySelectorAll('.hover-cell');
            hoverCells.forEach(cell => {
                const tooltipText = cell.getAttribute('data-tooltip');
                if (!tooltipText) return;
                
                let tooltip = null;
                
                cell.addEventListener('mouseenter', (e) => {
                    tooltip = document.createElement('div');
                    tooltip.className = 'tooltip';
                    tooltip.style.display = 'block';
                    // å¯¹äºè·¯å¾„ä¿¡æ¯ï¼Œç›´æ¥æ˜¾ç¤ºå®Œæ•´æ–‡æœ¬
                    const displayText = tooltipText;
                    const span = document.createElement('span');
                    span.className = 'tooltip-line';
                    span.textContent = displayText;
                    span.style.whiteSpace = 'pre-wrap';
                    tooltip.appendChild(span);
                    document.body.appendChild(tooltip);
                    
                    // ä½¿ç”¨é¼ æ ‡ä½ç½®æ¥å®šä½tooltipï¼Œè¿™æ ·æ»šåŠ¨æ—¶ä¹Ÿèƒ½æ­£ç¡®æ˜¾ç¤º
                    const updateTooltipPosition = (event) => {
                        if (!tooltip || !tooltip.parentNode) return;
                        
                        const mouseX = event.clientX;
                        const mouseY = event.clientY;
                        // ä½¿ç”¨ getBoundingClientRect è·å–æ›´å‡†ç¡®çš„å°ºå¯¸
                        const rect = tooltip.getBoundingClientRect();
                        const tooltipWidth = rect.width || tooltip.offsetWidth;
                        const tooltipHeight = rect.height || tooltip.offsetHeight;
                        const padding = 10;
                        
                        // é»˜è®¤æ˜¾ç¤ºåœ¨é¼ æ ‡å³ä¸‹æ–¹
                        let tooltipX = mouseX + padding;
                        let tooltipY = mouseY + padding;
                        
                        // å¦‚æœå³ä¾§ç©ºé—´ä¸å¤Ÿï¼Œæ˜¾ç¤ºåœ¨å·¦ä¾§
                        if (tooltipX + tooltipWidth > window.innerWidth) {
                            tooltipX = mouseX - tooltipWidth - padding;
                        }
                        
                        // å¦‚æœå·¦ä¾§ä¹Ÿä¸å¤Ÿï¼Œå±…ä¸­æ˜¾ç¤º
                        if (tooltipX < 0) {
                            tooltipX = (window.innerWidth - tooltipWidth) / 2;
                        }
                        
                        // å¦‚æœä¸‹æ–¹ç©ºé—´ä¸å¤Ÿï¼Œæ˜¾ç¤ºåœ¨ä¸Šæ–¹
                        if (tooltipY + tooltipHeight > window.innerHeight) {
                            tooltipY = mouseY - tooltipHeight - padding;
                        }
                        
                        // å¦‚æœä¸Šæ–¹ä¹Ÿä¸å¤Ÿï¼Œæ˜¾ç¤ºåœ¨é¼ æ ‡ä½ç½®
                        if (tooltipY < 0) {
                            tooltipY = mouseY + padding;
                        }
                        
                        tooltip.style.left = tooltipX + 'px';
                        tooltip.style.top = tooltipY + 'px';
                    };
                    
                    // åˆå§‹å®šä½ - ä½¿ç”¨ requestAnimationFrame ç¡®ä¿ DOM å·²æ›´æ–°
                    requestAnimationFrame(() => {
                        updateTooltipPosition(e);
                    });
                    
                    // é¼ æ ‡ç§»åŠ¨æ—¶æ›´æ–°ä½ç½®
                    cell.addEventListener('mousemove', updateTooltipPosition);
                    cell._tooltipMoveHandler = updateTooltipPosition;
                });
                
                cell.addEventListener('mouseleave', () => {
                    if (tooltip) {
                        tooltip.remove();
                        tooltip = null;
                    }
                    // ç§»é™¤mousemoveäº‹ä»¶ç›‘å¬
                    if (cell._tooltipMoveHandler) {
                        cell.removeEventListener('mousemove', cell._tooltipMoveHandler);
                        cell._tooltipMoveHandler = null;
                    }
                });
            });

            tableContainer.classList.remove('hidden');
            
            // æ›´æ–°å›¾è¡¨
            updateChart(hasAreaSelection, groupedData);
            
            // æ›´æ–°AIåˆ†æåŒºåŸŸ
            updateAiAnalysis(hasAreaSelection);
        }
        
        function updateChart(hasAreaSelection, groupedData) {
            const chartContainer = document.getElementById('chartContainer');
            const chartWrapper = document.getElementById('chartWrapper');
            const emptyChartMessage = document.getElementById('emptyChartMessage');
            
            chartContainer.classList.remove('hidden');
            
            if (!hasAreaSelection || groupedData.length === 0) {
                chartWrapper.classList.add('hidden');
                emptyChartMessage.classList.remove('hidden');
                if (capacityChart) {
                    capacityChart.destroy();
                    capacityChart = null;
                }
                return;
            }
            
            emptyChartMessage.classList.add('hidden');
            chartWrapper.classList.remove('hidden');
            
            const weekCodes = weekColumns.map(week => week.code);
            const weekLabels = weekColumns.map(week => {
                const range = week.range ? ` (${week.range})` : '';
                return `${week.label}${range}`;
            });
            
            // å‡†å¤‡æ•°æ®
            const shipData = []; // æ¯å‘¨çš„æ€»æ´¾èˆ¹æ•°ï¼ˆç”¨äºæŠ˜çº¿å›¾ï¼‰
            const datasets = [];
            const podRoutePairs = [];
            
            // æ”¶é›†æ‰€æœ‰èˆªçº¿å¤‡æ³¨+å…±èˆ±èˆ¹å…¬å¸ç»„åˆ
            groupedData.forEach(item => {
                const routeLabel = item.routeLabel || 'æœªçŸ¥èˆªçº¿';
                const routeRemark = item.routeRemark || 'â€”';
                podRoutePairs.push({
                    label: `${routeRemark} - ${routeLabel}`,
                    routeLabel: routeLabel,
                    routeId: item.routeId || '',
                    routeRemark: routeRemark
                });
            });
            
            // ä¸ºæ¯ä¸ªç›®çš„æ¸¯+èˆªçº¿ç»„åˆåˆ›å»ºè¿åŠ›æ•°æ®é›†
            podRoutePairs.forEach((pair, index) => {
                const item = groupedData[index];
                const capacityValues = [];
                
                weekColumns.forEach((week) => {
                    const weekCode = week.code;
                    const ships = item.weeks[weekCode] || [];
                    const weekCapacity = ships.reduce((sum, ship) => sum + (ship.capacity || 0), 0);
                    capacityValues.push(weekCapacity);
                });
                
                // ç”Ÿæˆé¢œè‰²
                const hue = (index * 137.508) % 360; // ä½¿ç”¨é»„é‡‘è§’åº¦åˆ†å¸ƒé¢œè‰²
                const color = `hsl(${hue}, 70%, 50%)`;
                
                datasets.push({
                    label: pair.label,
                    data: capacityValues,
                    type: 'bar',
                    backgroundColor: color,
                    borderColor: color,
                    borderWidth: 1
                });
            });
            
            // è®¡ç®—æ¯å‘¨çš„æ€»æ´¾èˆ¹æ•°ï¼ˆè€ƒè™‘å‘¨åˆ«åˆå¹¶ï¼‰
            weekCodes.forEach((weekCode, weekIndex) => {
                let totalShips = 0;
                groupedData.forEach(item => {
                    let ships = item.weeks[weekCode] || [];
                    
                    // æ£€æŸ¥æ˜¯å¦éœ€è¦ä¸ä¸‹ä¸€ä¸ªå‘¨åˆ«åˆå¹¶
                    if (weekIndex < weekCodes.length - 1) {
                        const nextWeekCode = weekCodes[weekIndex + 1];
                        if (typeof shouldMergeWeeks === 'function' && shouldMergeWeeks(weekCode, nextWeekCode)) {
                            // åˆå¹¶ä¸¤ä¸ªå‘¨åˆ«çš„æ•°æ®
                            const nextWeekShips = item.weeks[nextWeekCode] || [];
                            ships = [...ships, ...nextWeekShips];
                        }
                    }
                    
                    totalShips += ships.length;
                });
                shipData.push(totalShips);
            });
            
            // æ·»åŠ æ´¾èˆ¹æŠ˜çº¿å›¾æ•°æ®é›†
            datasets.push({
                label: 'æ´¾èˆ¹æ€»æ•°',
                data: shipData,
                type: 'line',
                borderColor: '#dc3545',
                backgroundColor: 'rgba(220, 53, 69, 0.1)',
                borderWidth: 3,
                fill: false,
                tension: 0.4,
                yAxisID: 'y1'
            });
            
            // é”€æ¯æ—§å›¾è¡¨
            if (capacityChart) {
                capacityChart.destroy();
            }
            
            // åˆ›å»ºæ–°å›¾è¡¨
            const ctx = document.getElementById('trendChart').getContext('2d');
            capacityChart = new Chart(ctx, {
                data: {
                    labels: weekLabels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'è¿åŠ›ä¸æ´¾èˆ¹è¶‹åŠ¿åˆ†æ',
                            font: {
                                size: 16,
                                weight: 'bold'
                            }
                        },
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false
                        }
                    },
                    scales: {
                        x: {
                            stacked: true,
                            title: {
                                display: true,
                                text: 'å‘¨åˆ«'
                            }
                        },
                        y: {
                            stacked: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: 'è¿åŠ› (TEU)'
                            },
                            beginAtZero: true
                        },
                        y1: {
                            type: 'linear',
                            position: 'right',
                            title: {
                                display: true,
                                text: 'æ´¾èˆ¹æ•°'
                            },
                            beginAtZero: true,
                            grid: {
                                drawOnChartArea: false
                            }
                        }
                    }
                }
            });
        }

        // AIåˆ†æç›¸å…³åŠŸèƒ½ï¼ˆä½¿ç”¨ç»Ÿä¸€çš„å·¥å…·æ¨¡å—ï¼‰
        const aiProviders = createAiProviders('', {
            deepseek: { maxTokens: 8000 },
            kimi: { maxTokens: 8000 },
            qwen: { maxTokens: 8000 }
        }); // å¸‚åœºè§‚å¯Ÿå·¥å…·ä½¿ç”¨é»˜è®¤å‰ç¼€ï¼Œå¢åŠ è¾“å‡ºé•¿åº¦é™åˆ¶
        // æç¤ºè¯å·²ä»å…±äº«æ–‡ä»¶ vendor/ai-prompts.js åŠ è½½
        // baseSystemPrompt å’Œ aiInstructionTemplate ç°åœ¨ä»å¤–éƒ¨æ–‡ä»¶å¼•ç”¨
        let activeAiProvider = 'deepseek';
        let setActiveAiPanelBound = null;

        // åˆå§‹åŒ– AI æ¨¡å—
        // æ³¨æ„ï¼šinitAiModule éœ€è¦åœ¨æ¨¡æ¿ç”Ÿæˆåè°ƒç”¨ï¼Œæ‰€ä»¥ç§»åˆ° window.addEventListener('load') ä¸­
        // è¿™é‡Œå…ˆå®šä¹‰ä¸€ä¸ªåŒ…è£…å‡½æ•°
        function setActiveAiPanel(providerId = 'deepseek') {
            if (setActiveAiPanelBound) {
                const result = setActiveAiPanelBound(providerId);
                if (result) {
                    activeAiProvider = result;
                }
            } else {
                // é™çº§æ–¹æ¡ˆï¼šå¦‚æœ initAiModule æœªè°ƒç”¨ï¼Œä½¿ç”¨æœ¬åœ°å®ç°
                if (!aiProviders[providerId]) return;
                activeAiProvider = providerId;
                const aiTabButtons = document.querySelectorAll('.ai-tab-btn');
                const aiPanels = document.querySelectorAll('.ai-panel');
                aiTabButtons.forEach(btn => {
                    if (btn.dataset.provider === providerId) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                });
                aiPanels.forEach(panel => {
                    if (panel.dataset.provider === providerId) {
                        panel.classList.add('active');
                    } else {
                        panel.classList.remove('active');
                    }
                });
            }
        }

        function loadAiConfigs() {
            loadAiConfigsFromStorage(aiProviders);
        }

        function getAiConfig(providerId = 'deepseek') {
            return getAiConfigFromInputs(providerId, aiProviders);
        }

        function saveAiConfig(providerId = 'deepseek') {
            saveAiConfigToStorage(providerId, aiProviders, (providerName) => {
                // ä½¿ç”¨ç»Ÿä¸€çš„é”™è¯¯å¤„ç†æ¨¡å—
                const configSavedMsg = typeof getErrorMessage === 'function' 
                    ? getErrorMessage(ErrorType.USER_ACTION, 'CONFIG_SAVED', { provider: providerName })
                    : `${providerName} API é…ç½®å·²ä¿å­˜`;
                showSuccess(configSavedMsg);
            });
        }
        
        // å¯¼å‡ºåˆ°å…¨å±€ï¼Œä¾›æ¨¡æ¿ä¸­çš„ onclick ä½¿ç”¨
        window.saveAiConfig = saveAiConfig;

        // fetchBunkerData, extractBunkerTables, parseBunkerTable, updateBunkerStatus, describeBunkerLine å·²ä» vendor/market-analysis-utils.js åŠ è½½

        // fetchWciData, parseWciText, renderWciStatus å·²ä» vendor/market-analysis-utils.js åŠ è½½

        const wciCodeMap = {
            'WCI-COMPOSITE': 'å…¨çƒç»¼åˆ',
            'WCI-SHA-RTM': 'ä¸Šæµ· â†’ é¹¿ç‰¹ä¸¹',
            'WCI-RTM-SHA': 'é¹¿ç‰¹ä¸¹ â†’ ä¸Šæµ·',
            'WCI-SHA-GOA': 'ä¸Šæµ· â†’ çƒ­é‚£äºš',
            'WCI-SHA-LAX': 'ä¸Šæµ· â†’ æ´›æ‰çŸ¶',
            'WCI-LAX-SHA': 'æ´›æ‰çŸ¶ â†’ ä¸Šæµ·',
            'WCI-SHA-NYC': 'ä¸Šæµ· â†’ çº½çº¦',
            'WCI-NYC-RTM': 'çº½çº¦ â†’ é¹¿ç‰¹ä¸¹',
            'WCI-RTM-NYC': 'é¹¿ç‰¹ä¸¹ â†’ çº½çº¦'
        };

        const fbxCodeMap = {
            FBX: 'FBXï¼ˆFreightos Baltic Index å…¨çƒç»¼åˆï¼‰',
            FBX01: 'FBX01 ä¸­å›½/ä¸œäºš â†’ åŒ—ç¾è¥¿æµ·å²¸',
            FBX02: 'FBX02 åŒ—ç¾è¥¿æµ·å²¸ â†’ ä¸­å›½/ä¸œäºš',
            FBX03: 'FBX03 ä¸­å›½/ä¸œäºš â†’ åŒ—ç¾ä¸œæµ·å²¸',
            FBX04: 'FBX04 åŒ—ç¾ä¸œæµ·å²¸ â†’ ä¸­å›½/ä¸œäºš',
            FBX11: 'FBX11 ä¸­å›½/ä¸œäºš â†’ åŒ—æ¬§',
            FBX12: 'FBX12 åŒ—æ¬§ â†’ ä¸­å›½/ä¸œäºš',
            FBX13: 'FBX13 ä¸­å›½/ä¸œäºš â†’ åœ°ä¸­æµ·',
            FBX14: 'FBX14 åœ°ä¸­æµ· â†’ ä¸­å›½/ä¸œäºš',
            FBX21: 'FBX21 åŒ—ç¾ä¸œæµ·å²¸ â†’ åŒ—æ¬§',
            FBX22: 'FBX22 åŒ—æ¬§ â†’ åŒ—ç¾ä¸œæµ·å²¸',
            FBX24: 'FBX24 æ¬§æ´² â†’ å—ç¾ä¸œæµ·å²¸',
            FBX26: 'FBX26 æ¬§æ´² â†’ å—ç¾è¥¿æµ·å²¸'
        };

        // fetchFbxData, parseFbxText, renderFbxStatus å·²ä» vendor/market-analysis-utils.js åŠ è½½

        const cachedWci = loadCachedData(CACHE_KEYS.wci);
        if (cachedWci) {
            wciData = cachedWci;
            renderWciStatus();
        }
        const cachedFbx = loadCachedData(CACHE_KEYS.fbx);
        if (cachedFbx) {
            fbxData = cachedFbx;
            renderFbxStatus();
        }

        // fetchTextContent å·²ä» vendor/market-analysis-utils.js åŠ è½½

        /**
         * æ›´æ–°AIåˆ†ææ¨¡å—å¯è§æ€§ï¼ˆé»˜è®¤æ˜¾ç¤ºï¼Œç±»ä¼¼ Monitor-Sailing-Scheduleï¼‰
         * @param {boolean} hasAreaSelection - æ˜¯å¦æœ‰åŒºåŸŸé€‰æ‹©
         */
        function updateAiAnalysis(hasAreaSelection) {
            const aiAnalysisContainer = document.getElementById('aiAnalysisContainer');
            const emptyAiMessage = document.getElementById('emptyAiMessage');
            const aiConfigSection = document.getElementById('aiConfigSection');
            
            if (!aiAnalysisContainer) return;
            
            // AI æ¨¡å—å§‹ç»ˆæ˜¾ç¤ºï¼ˆé»˜è®¤æ˜¾ç¤ºï¼‰
            aiAnalysisContainer.style.display = 'block';
            
            // æ ¹æ®æ•°æ®çŠ¶æ€æ˜¾ç¤º/éšè—é…ç½®åŒºåŸŸ
            if (!hasAreaSelection || !latestFilteredRecords || latestFilteredRecords.length === 0) {
                if (emptyAiMessage) emptyAiMessage.style.display = 'block';
                if (aiConfigSection) aiConfigSection.style.display = 'none';
                return;
            }
            
            if (emptyAiMessage) emptyAiMessage.style.display = 'none';
            if (aiConfigSection) aiConfigSection.style.display = 'block';
            loadAiConfigs();
            setActiveAiPanel(activeAiProvider);
        }

        async function runAiAnalysis(providerId = 'deepseek') {
            await executeAiAnalysis(
                providerId,
                aiProviders,
                buildAiPrompt,
                baseSystemPrompt,
                {
                    beforeAnalysis: async () => {
                        // åˆ†æå‰è·å–æ•°æ®
                        await Promise.allSettled([
                            fetchBunkerData(false),
                            fetchWciData(false),
                            fetchFbxData(false)
                        ]);
                    }
                }
            );
        }
        
        // å¯¼å‡ºåˆ°å…¨å±€ï¼Œä¾›æ¨¡æ¿ä¸­çš„ onclick ä½¿ç”¨
        window.runAiAnalysis = runAiAnalysis;

        function buildAiPrompt() {
            if (!destinationFilters.areas.length) {
                showError(ErrorType.DATA_VALIDATION, 'NO_AREA_SELECTION');
                return null;
            }
            const filteredRecords = latestFilteredRecords;
            if (!filteredRecords.length) {
                showError(ErrorType.DATA_VALIDATION, 'NO_DATA');
                return null;
            }
            const analysisGroups = groupedTableData.length ? groupedTableData : groupRecords(filteredRecords).data;
            if (!analysisGroups.length) {
                showError(ErrorType.DATA_VALIDATION, 'NO_ROUTE_DATA');
                return null;
            }

            // ä½¿ç”¨å…¬å…±å‡½æ•°å‡†å¤‡åˆ†ææ•°æ®
            const prepared = prepareAnalysisData(analysisGroups, weekColumns, showError, ErrorType);
            if (!prepared) return null;
            const { analysisData, weeklySummary, analysisWeekCodes, analysisWeekLabels } = prepared;

            // æ„å»ºç›®çš„åœ°æ‘˜è¦ï¼ˆ365-04æ ¼å¼ï¼‰
            const destinationSummary = [
                destinationFilters.areas.length ? destinationFilters.areas.join('ã€') : 'å…¨éƒ¨åŒºåŸŸ',
                destinationFilters.subAreas.length ? destinationFilters.subAreas.join('ã€') : 'å…¨éƒ¨å­åŒºåŸŸ',
                destinationFilters.countries.length ? destinationFilters.countries.join('ã€') : 'å…¨éƒ¨å›½å®¶/åœ°åŒº',
                destinationFilters.ports.length ? destinationFilters.ports.join('ã€') : 'å…¨éƒ¨æ¸¯å£'
            ].join(' / ');

            // ä½¿ç”¨å…¬å…±å‡½æ•°æ„å»ºæç¤ºè¯
            let prompt = buildDataOverview(destinationSummary, analysisData.length, analysisWeekCodes, analysisWeekLabels, weeklySummary);
            prompt += buildDetailedData365(analysisData, analysisWeekCodes, analysisWeekLabels);
            prompt += buildBookingDataSection(getBookingDataLocal());

            if (
                typeof marketData !== 'undefined' &&
                Array.isArray(marketData) &&
                marketData.length > 0 &&
                typeof marketSelectedPorts !== 'undefined' &&
                marketSelectedPorts.length > 0
            ) {
                prompt += `\nã€è¿è´¹èµ°åŠ¿å›¾æ¨¡å—æ•°æ®ï¼ˆç½‘é¡µé¡¶éƒ¨ï¼‰ã€‘
ä»¥ä¸‹æ•°æ®æ¥è‡ªè¿è´¹èµ°åŠ¿å›¾æ¨¡å—ï¼Œå±•ç¤ºå†å²ä»·æ ¼è¶‹åŠ¿ï¼Œç”¨äºç»¼åˆåˆ¤æ–­å¸‚åœºæ–¹å‘ï¼š
`;
                const { portCol, dateCol } = marketColumnConfig;
                const startValue = marketStartDate?.value;
                const endValue = marketEndDate?.value;
                const startDateObj = startValue ? new Date(startValue + 'T00:00:00') : null;
                const endDateObj = endValue ? new Date(endValue + 'T23:59:59') : null;

                marketSelectedPorts.forEach(port => {
                    let rows = marketData.filter(row => String(row[portCol] || '').trim() === port);
                    if (dateCol && (startDateObj || endDateObj)) {
                        rows = rows.filter(row => {
                            const rowDate = marketParseDate(row[dateCol]);
                            if (!(rowDate instanceof Date) || isNaN(rowDate)) return false;
                            const rowDateOnly = new Date(rowDate.getFullYear(), rowDate.getMonth(), rowDate.getDate());
                            if (startDateObj && rowDateOnly < startDateObj) return false;
                            if (endDateObj && rowDateOnly > endDateObj) return false;
                            return true;
                        });
                    }
                    if (rows.length === 0) return;

                    rows.sort((a, b) => {
                        const dateA = marketParseDate(a[dateCol]);
                        const dateB = marketParseDate(b[dateCol]);
                        if (dateA && dateB) return dateA - dateB;
                        return 0;
                    });

                    const prices = rows.map(row => {
                        const date = dateCol ? marketParseDate(row[dateCol]) : null;
                        const dateStr = date ? `${date.getFullYear()}/${String(date.getMonth() + 1).padStart(2, '0')}/${String(date.getDate()).padStart(2, '0')}` : (row[dateCol] || '');
                        const gp20 = row['20GP'] || row['20gp'] || row['GP20'];
                        const gp40 = row['40GP'] || row['40gp'] || row['GP40'];
                        return { date: dateStr, gp20: gp20 ? parseFloat(gp20) : null, gp40: gp40 ? parseFloat(gp40) : null };
                    }).filter(p => p.gp20 !== null || p.gp40 !== null);

                    if (prices.length > 0) {
                        const recentPrices = prices.slice(-8);
                        const firstPrice = recentPrices[0];
                        const lastPrice = recentPrices[recentPrices.length - 1];
                        const gp20Trend = firstPrice.gp20 && lastPrice.gp20 ? (lastPrice.gp20 > firstPrice.gp20 ? 'ä¸Šæ¶¨' : lastPrice.gp20 < firstPrice.gp20 ? 'ä¸‹è·Œ' : 'æŒå¹³') : 'æ•°æ®ä¸è¶³';
                        const gp40Trend = firstPrice.gp40 && lastPrice.gp40 ? (lastPrice.gp40 > firstPrice.gp40 ? 'ä¸Šæ¶¨' : lastPrice.gp40 < firstPrice.gp40 ? 'ä¸‹è·Œ' : 'æŒå¹³') : 'æ•°æ®ä¸è¶³';

                        prompt += `\næ¸¯å£ï¼š${port}
  - æ•°æ®ç‚¹æ•°é‡ï¼š${prices.length}ä¸ª
  - 20GP è¶‹åŠ¿ï¼š${gp20Trend}ï¼ˆ${firstPrice.gp20 ? firstPrice.gp20.toLocaleString() : 'N/A'} â†’ ${lastPrice.gp20 ? lastPrice.gp20.toLocaleString() : 'N/A'}ï¼‰
  - 40GP è¶‹åŠ¿ï¼š${gp40Trend}ï¼ˆ${firstPrice.gp40 ? firstPrice.gp40.toLocaleString() : 'N/A'} â†’ ${lastPrice.gp40 ? lastPrice.gp40.toLocaleString() : 'N/A'}ï¼‰
  - æœ€è¿‘ä»·æ ¼ï¼š20GP ${lastPrice.gp20 ? lastPrice.gp20.toLocaleString() : 'N/A'} USD, 40GP ${lastPrice.gp40 ? lastPrice.gp40.toLocaleString() : 'N/A'} USDï¼ˆ${lastPrice.date}ï¼‰
`;
                    }
                });
                prompt += `\næ³¨ï¼šä»¥ä¸Šè¿è´¹èµ°åŠ¿å›¾æ•°æ®éœ€ä¸ç”¨æˆ·å¡«å†™çš„ç°è¡ŒæŠ¥ä»·ã€æç«¯æŠ¥ä»·ä»¥åŠ SCFI/WCI/FBX æŒ‡æ•°è¿›è¡Œäº¤å‰éªŒè¯ï¼Œåˆ¤æ–­å¸‚åœºæ–¹å‘çš„ä¸€è‡´æ€§ã€‚è‹¥è¶‹åŠ¿ä¸ä¸€è‡´ï¼Œéœ€è§£é‡Šæˆå› ï¼ˆå¦‚æŒ‡æ•°æ»åã€åŒºåŸŸç»“æ„å·®å¼‚ï¼‰ã€‚\n`;
            }

            // ä½¿ç”¨å…¬å…±å‡½æ•°æ„å»ºæç¤ºè¯ï¼ˆç»§ç»­ï¼‰
            prompt += buildMarketReportsSection(marketReports);
            prompt += buildBunkerDataSection(bunkerData);
            prompt += buildWciDataSection(wciData);
            prompt += buildFbxDataSection(fbxData);
            // æ·»åŠ  SCFI æ•°æ®ï¼ˆä»å¸‚åœºæŠ¥å‘Šä¸­æå–ï¼Œæ›¿ä»£ä¹‹å‰çš„ CCFIï¼‰
            prompt += buildScfiDataSection(marketReports);

            prompt += aiInstructionTemplate;
            return prompt;
        }


        // ä½¿ç”¨å…¬å…±å‡½æ•°è·å–è®¢èˆ±æ•°æ®ï¼ˆä» vendor/market-analysis-utils.jsï¼‰
        // ç›´æ¥ä½¿ç”¨å…¨å±€å‡½æ•°ï¼Œé¿å…å‘½åå†²çª
        function getBookingDataLocal() {
            return window.getBookingData ? window.getBookingData('bookingDataBody') : [];
        }

        /**
         * å¯¼å‡ºæ•´é¡µ PDFï¼ˆä½¿ç”¨ vendor/pdf-utils.jsï¼‰
         */
        // ä½¿ç”¨å…¬å…±å‡½æ•°åˆ›å»º PDF å¯¼å‡ºå‡½æ•°ï¼ˆä» vendor/pdf-utils.jsï¼‰
        const exportPageToPdf = window.createExportPageToPdfFunction 
            ? window.createExportPageToPdfFunction('è¿è´¹èµ°åŠ¿åŠèˆªçº¿è¿åŠ›åˆ†æ')
            : async function() {
                        showError(ErrorType.SYSTEM_ERROR, 'PDF_EXPORT_FAILED', { 
                    message: 'PDF å¯¼å‡ºåŠŸèƒ½æœªåŠ è½½' 
                });
            };

        document.getElementById('exportPdfBtn')?.addEventListener('click', exportPageToPdf);
        window.addEventListener('load', () => {
            // ä½¿ç”¨å…¬å…±æ¨¡æ¿ç”Ÿæˆå¸‚åœºæ•°æ®ä¿¡æ¯å—
            if (typeof window.generateMarketDataInfoBlocks === 'function') {
                const marketDataContainer = document.getElementById('marketDataInfoBlocksContainer');
                if (marketDataContainer) {
                    marketDataContainer.innerHTML = window.generateMarketDataInfoBlocks();
                    }
            }
            
            // é‡æ–°è·å–çŠ¶æ€å…ƒç´ å¼•ç”¨ï¼ˆæ¨¡æ¿ç”Ÿæˆåï¼‰
            bunkerStatusEl = document.getElementById('bunkerStatus');
            bunkerUpdatedEl = document.getElementById('bunkerUpdated');
            wciStatusEl = document.getElementById('wciStatus');
            wciUpdatedEl = document.getElementById('wciUpdated');
            fbxStatusEl = document.getElementById('fbxStatus');
            fbxUpdatedEl = document.getElementById('fbxUpdated');
            
            // ä½¿ç”¨å…¬å…±åˆå§‹åŒ–å‡½æ•°ï¼ˆä» vendor/template-utils.jsï¼‰
            if (typeof window.initMarketAnalysisPage === 'function') {
                window.initMarketAnalysisPage({
                    updateAiAnalysis,
                    fetchBunkerData,
                    fetchWciData,
                    fetchFbxData,
                    bunkerStatusEl,
                    bunkerUpdatedEl,
                    wciStatusEl,
                    fbxStatusEl
                });
                
                // æ¨¡æ¿ç”Ÿæˆåï¼Œåˆå§‹åŒ– AI æ¨¡å—ï¼ˆç»‘å®šæ ‡ç­¾é¡µåˆ‡æ¢äº‹ä»¶ï¼‰
                if (typeof window.initAiModule === 'function') {
                    setActiveAiPanelBound = window.initAiModule(aiProviders);
                    // è®¾ç½®é»˜è®¤æ¿€æ´»çš„æä¾›å•†
                    if (setActiveAiPanelBound) {
                        setActiveAiPanelBound(activeAiProvider);
                    }
                }
            } else {
                // é™çº§æ–¹æ¡ˆï¼šå¦‚æœå…¬å…±å‡½æ•°æœªåŠ è½½ï¼Œä½¿ç”¨æœ¬åœ°å®ç°
                if (typeof window.generateBookingDataTable === 'function') {
                    const container = document.getElementById('bookingDataTableContainer');
                    if (container) {
                        container.innerHTML = window.generateBookingDataTable();
                    }
                }
                if (typeof window.generateAiConfigPanels === 'function') {
                    const aiContainer = document.getElementById('aiConfigPanelsContainer');
                    if (aiContainer) {
                        aiContainer.innerHTML = window.generateAiConfigPanels();
                    }
                }
                
                // é™çº§æ–¹æ¡ˆï¼šæ¨¡æ¿ç”Ÿæˆåï¼Œåˆå§‹åŒ– AI æ¨¡å—ï¼ˆç»‘å®šæ ‡ç­¾é¡µåˆ‡æ¢äº‹ä»¶ï¼‰
                if (typeof window.initAiModule === 'function') {
                    setActiveAiPanelBound = window.initAiModule(aiProviders);
                    // è®¾ç½®é»˜è®¤æ¿€æ´»çš„æä¾›å•†
                    if (setActiveAiPanelBound) {
                        setActiveAiPanelBound(activeAiProvider);
                    }
                }
                
            updateAiAnalysis(false);
            Promise.allSettled([
                fetchBunkerData(false),
                fetchWciData(false),
                fetchFbxData(false)
            ]);
            }
        });

        // ç­›é€‰åŠŸèƒ½åœ¨renderTableä¸­å·²å®ç°
    </script>
</body>
</html>
