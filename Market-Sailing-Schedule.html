<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monitor · 专业船期表</title>
    <link rel="stylesheet" href="vendor/theme-styles.css">
    <script src="vendor/lib-loader.js"></script>
    <script src="vendor/common-utils.js"></script>
    <script src="vendor/date-utils.js"></script>
    <script src="vendor/error-handler.js"></script>
    <script src="vendor/debug-utils.js"></script>
    <script src="vendor/auth-gist.js"></script>
    <script src="vendor/filter-utils.js"></script>
    <script src="vendor/excel-reader-utils.js"></script>
    <script src="vendor/week-utils.js"></script>
    <script src="vendor/week-definition-parser.js"></script>
    <script src="vendor/ai-config.js"></script>
    <script src="vendor/ai-prompts.js"></script>
    <script src="vendor/ai-utils.js"></script>
    <script src="vendor/template-utils.js"></script>
    <script src="vendor/market-analysis-utils.js"></script>
    <script src="vendor/port-sort-utils.js"></script>
</head>
<body data-page="Market-Sailing-Schedule.html">
    <div class="dashboard-container">
        <!-- 左侧导航栏占位容器（将由sidebar-loader.js动态加载） -->
        <div id="sidebar-placeholder"></div>

        <!-- 右侧内容 -->
        <main class="dashboard-content">
            <div class="container">
                <!-- 顶部介绍卡片，沿用 dashboard 风格 -->
                <div class="section-intro">
                    <div class="section-intro-header">
                        <div class="section-intro-content">
                            <h2>Monitor · 专业船期表</h2>
                            <p>以日历视图展示船期信息，支持起运港、目的港、共舱船公司多维度筛选</p>
                        </div>
                        <div class="section-intro-actions">
                            <a href="dashboard.html?tab=monitor" class="tool-link" aria-label="返回工具集首页">← 返回首页</a>
                            <a href="Market-Sailing-Schedule-README.html" class="tool-link secondary" aria-label="查看使用说明文档">使用说明 →</a>
                        </div>
                    </div>
                </div>

                <!-- 文件上传和数据状态区域 - 上下结构 -->
                <div style="display: flex; flex-direction: column; gap: 20px; margin-bottom: 0;">
                    <!-- 第一行：载入 001 和 365 文件 -->
                    <div class="grid-2-col" style="margin-bottom: 0;">
                        <!-- 左侧：载入 001 文件 -->
                        <div class="card-white">
                            <label for="file001" class="file-upload-label" aria-label="选择001 Excel文件上传">
                                <svg class="file-upload-icon" width="36" height="36" viewBox="0 0 36 36" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <rect x="4" y="4" width="28" height="28" rx="8" fill="url(#grad001)" />
                                    <rect x="8" y="8" width="20" height="20" rx="2" fill="none" stroke="#fff" stroke-width="1.5"/>
                                    <line x1="8" y1="14" x2="28" y2="14" stroke="#fff" stroke-width="1.5"/>
                                    <line x1="8" y1="20" x2="28" y2="20" stroke="#fff" stroke-width="1.5"/>
                                    <line x1="14" y1="8" x2="14" y2="28" stroke="#fff" stroke-width="1.5"/>
                                    <path d="M18 22L22 26L14 26Z" fill="#fff"/>
                                    <defs>
                                        <linearGradient id="grad001" x1="4" y1="4" x2="32" y2="32" gradientUnits="userSpaceOnUse">
                                            <stop stop-color="#0071e3" />
                                            <stop offset="1" stop-color="#54a4ff" />
                                        </linearGradient>
                                    </defs>
                                </svg>
                                <div class="file-upload-content">
                                    <div class="file-upload-title">载入 001 文件</div>
                                    <div class="file-upload-desc">支持 .xlsx / .xls，数据仅在本地浏览器解析</div>
                                </div>
                                <input type="file" id="file001" class="file-upload-input" accept=".xlsx,.xls" aria-label="选择001 Excel文件" title="选择001 Excel文件：文件需包含 schedule 工作表">
                            </label>
                        </div>
                        
                        <!-- 右侧：载入 365 文件 -->
                        <div class="card-white">
                            <label for="file365" class="file-upload-label" aria-label="选择365 Excel文件上传">
                                <svg class="file-upload-icon" width="36" height="36" viewBox="0 0 36 36" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <rect x="4" y="4" width="28" height="28" rx="8" fill="url(#grad365)" />
                                    <rect x="8" y="8" width="20" height="20" rx="2" fill="none" stroke="#fff" stroke-width="1.5"/>
                                    <line x1="8" y1="14" x2="28" y2="14" stroke="#fff" stroke-width="1.5"/>
                                    <line x1="8" y1="20" x2="28" y2="20" stroke="#fff" stroke-width="1.5"/>
                                    <line x1="14" y1="8" x2="14" y2="28" stroke="#fff" stroke-width="1.5"/>
                                    <path d="M18 22L22 26L14 26Z" fill="#fff"/>
                                    <defs>
                                        <linearGradient id="grad365" x1="4" y1="4" x2="32" y2="32" gradientUnits="userSpaceOnUse">
                                            <stop stop-color="#0071e3" />
                                            <stop offset="1" stop-color="#54a4ff" />
                                        </linearGradient>
                                    </defs>
                                </svg>
                                <div class="file-upload-content">
                                    <div class="file-upload-title">载入 365 文件</div>
                                    <div class="file-upload-desc">支持 .xlsx / .xls，数据仅在本地浏览器解析</div>
                                </div>
                                <input type="file" id="file365" class="file-upload-input" accept=".xlsx,.xls" aria-label="选择365 Excel文件" title="选择365 Excel文件：文件需包含 schedule 工作表">
                            </label>
                        </div>
                    </div>
                    
                    <!-- 第二行：001 文件状态 和 365 文件状态 -->
                    <div class="grid-2-col" style="margin-bottom: 0;">
                        <!-- 左侧：001 文件状态 -->
                        <div class="card-white">
                            <div class="data-status-container">
                                <svg class="data-status-icon" width="36" height="36" viewBox="0 0 36 36" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <rect x="4" y="4" width="28" height="28" rx="8" fill="url(#gradStatus001)" />
                                    <rect x="11" y="10" width="14" height="16" rx="2" fill="none" stroke="#fff" stroke-width="1.5"/>
                                    <rect x="15" y="8" width="6" height="4" rx="1" fill="#fff"/>
                                    <path d="M14 18L17 21L23 15" stroke="#fff" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
                                    <defs>
                                        <linearGradient id="gradStatus001" x1="4" y1="4" x2="32" y2="32" gradientUnits="userSpaceOnUse">
                                            <stop stop-color="#FF8A00" />
                                            <stop offset="1" stop-color="#FFB347" />
                                        </linearGradient>
                                    </defs>
                                </svg>
                                <div class="data-status-content">
                                    <div class="data-status-title">001 文件状态</div>
                                    <div id="status001" class="data-status-text" style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">尚未载入数据</div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- 右侧：365 文件状态 -->
                        <div class="card-white">
                            <div class="data-status-container">
                                <svg class="data-status-icon" width="36" height="36" viewBox="0 0 36 36" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <rect x="4" y="4" width="28" height="28" rx="8" fill="url(#gradStatus365)" />
                                    <rect x="11" y="10" width="14" height="16" rx="2" fill="none" stroke="#fff" stroke-width="1.5"/>
                                    <rect x="15" y="8" width="6" height="4" rx="1" fill="#fff"/>
                                    <path d="M14 18L17 21L23 15" stroke="#fff" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
                                    <defs>
                                        <linearGradient id="gradStatus365" x1="4" y1="4" x2="32" y2="32" gradientUnits="userSpaceOnUse">
                                            <stop stop-color="#FF8A00" />
                                            <stop offset="1" stop-color="#FFB347" />
                                        </linearGradient>
                                    </defs>
                                </svg>
                                <div class="data-status-content">
                                    <div class="data-status-title">365 文件状态</div>
                                    <div id="status365" class="data-status-text" style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">尚未载入数据</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 筛选器和显示模式 -->
                <section class="feature-section">
                    <div class="module-header">
                        <span class="module-badge">筛选条件</span>
                        <div>
                            <h2 class="section-title">船期筛选 <span>SAILING SCHEDULE FILTER</span></h2>
                            <p class="module-desc">起运港、目的港、共舱船公司多维度筛选，支持显示模式切换</p>
                        </div>
                    </div>
                    <div class="card-white module-card" style="margin-top: 20px;">
                        <div class="controls">
                            <div class="view-toggle" id="viewToggle">
                                <label>显示模式：</label>
                                <button id="btnMode001" data-mode="001">001</button>
                                <button id="btnMode365" class="active" data-mode="365">365</button>
                            </div>
                        </div>
                        <div id="destinationFilters" class="destination-filters">
                            <div class="filter-row">
                                <!-- 起运港选择区域 -->
                                <div class="filter-group">
                                    <label for="originPortSelect">起运港</label>
                                    <small class="multi-hint">可多选（Ctrl/点击切换）</small>
                                    <input type="text" id="originPortSearch" class="filter-search" placeholder="搜索起运港..." autocomplete="off">
                                    <select id="originPortSelect" multiple size="6" class="multi-select">
                                        <option value="">全部起运港</option>
                                    </select>
                                    <div class="filter-actions">
                                        <button type="button" class="filter-btn btn-sweep-blue" id="originPortSelectAll">全部选择</button>
                                        <button type="button" class="filter-btn btn-sweep-blue" id="originPortClearAll">清除选择</button>
                                    </div>
                                </div>
                                <!-- 目的港选择区域（合并001和365） -->
                                <div class="filter-group">
                                    <label for="destPortSelect">目的港</label>
                                    <small class="multi-hint">可多选（Ctrl/点击切换）</small>
                                    <input type="text" id="destPortSearch" class="filter-search" placeholder="搜索目的港..." autocomplete="off">
                                    <select id="destPortSelect" multiple size="6" class="multi-select">
                                        <option value="">全部目的港</option>
                                    </select>
                                    <div class="filter-actions">
                                        <button type="button" class="filter-btn btn-sweep-blue" id="destPortSelectAll">全部选择</button>
                                        <button type="button" class="filter-btn btn-sweep-blue" id="destPortClearAll">清除选择</button>
                                    </div>
                                </div>
                                <!-- 共舱船公司选择区域 -->
                                <div class="filter-group">
                                    <label for="carrierSelect">共舱船公司</label>
                                    <small class="multi-hint">可多选（Ctrl/点击切换）</small>
                                    <input type="text" id="carrierSearch" class="filter-search" placeholder="搜索共舱船公司..." autocomplete="off">
                                    <select id="carrierSelect" multiple size="6" class="multi-select">
                                        <option value="">全部共舱船公司</option>
                                    </select>
                                    <div class="filter-actions">
                                        <button type="button" class="filter-btn btn-sweep-blue" id="carrierSelectAll">全部选择</button>
                                        <button type="button" class="filter-btn btn-sweep-blue" id="carrierClearAll">清除选择</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- 日历视图 -->
                <section class="feature-section">
                    <div class="card-white module-card">
                        <div class="empty-message hidden" id="emptyMessage">
                            请选择筛选条件以显示船期日历
                        </div>
                        <div class="calendar-container hidden" id="calendarContainer">
                            <div class="calendar-header">
                                <div class="calendar-header-cell">周日</div>
                                <div class="calendar-header-cell">周一</div>
                                <div class="calendar-header-cell">周二</div>
                                <div class="calendar-header-cell">周三</div>
                                <div class="calendar-header-cell">周四</div>
                                <div class="calendar-header-cell">周五</div>
                                <div class="calendar-header-cell">周六</div>
                            </div>
                            <div id="calendarBody"></div>
                        </div>
                    </div>
                </section>

                <!-- 月度汇总表格 -->
                <section class="feature-section">
                    <div class="card-white module-card">
                        <div class="empty-message hidden" id="monthlySummaryEmptyMessage">
                            请选择筛选条件以显示月度汇总
                        </div>
                        <div id="monthlySummaryContainer" class="monthly-summary-container hidden">
                            <h3 style="margin: 0 0 16px 0; color: #495057; font-size: 18px;">月度航线靠泊汇总</h3>
                            <div id="monthlySummaryTable" class="monthly-summary-table"></div>
                        </div>
                    </div>
                </section>

                <!-- AI 船期分析模块 -->
                <section id="aiModule" class="feature-section">
                    <div class="module-header">
                        <span class="module-badge">AI 分析</span>
                        <div>
                            <h2 class="section-title">AI 船期分析 <span>AI SAILING SCHEDULE ANALYSIS</span></h2>
                            <p class="module-desc">DeepSeek × KIMI × 通义千问 三模型交叉验证船期规律、异常检测与趋势分析</p>
                        </div>
                    </div>
                    <div class="card-white module-card hidden mt-20" data-module="ai">
                        <div id="aiAnalysisContainer" class="ai-analysis-container">
                            <div class="ai-header">
                                <h3>AI 船期分析</h3>
                                <p>基于当前筛选条件，对起运港、船公司或目的港进行深度船期分析</p>
                            </div>
                            <div id="emptyAiMessage" class="empty-chart-message" style="display: none;">
                                请先选择筛选条件（起运港、船公司或目的港）以启用 AI 分析
                            </div>
                            <div id="aiConfigSection" style="display: none;">
                                <!-- AI 配置面板 - 使用公共模板（vendor/template-utils.js） -->
                                <div id="aiConfigPanelsContainer"></div>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- 使用声明 -->
                <div class="card-white mt-20">
                    <h2 class="usage-statement-title">Monitor · 专业船期表使用声明</h2>
                    <p class="usage-statement-text">资料整合自用户 Excel 数据，解析结果仅供内部研判，不构成对外报价或投资建议。</p>
                    <p class="usage-statement-text">AI 服务由 DeepSeek / KIMI / 通义千问 API 驱动，所有调用费用与合规责任由使用者自担，涉及客户或敏感数据时请先完成脱敏处理。</p>
                </div>
            </div>
        </main>
    </div>

    <!-- 引入导航栏公共组件 -->
    <script src="vendor/sidebar-loader.js"></script>
    <script>
        init001ToolPage('Market-Sailing-Schedule.html', 'market');
    </script>

    <script>
      // ==================== 全局函数引用保存 ====================
      // 在脚本最开始保存全局 formatDateKey 函数的引用，避免作用域冲突导致无限递归
      // 必须在所有函数定义之前执行，确保捕获的是 vendor/date-utils.js 中的原始函数
      // 注意：使用立即执行函数确保在 market-analysis-utils.js 加载之前就保存引用
      const _originalFormatDateKey = (function() {
        // 在 date-utils.js 加载后、market-analysis-utils.js 加载前保存引用
        // 由于脚本是按顺序加载的，此时 window.formatDateKey 应该是 date-utils.js 中的函数
        if (typeof window !== 'undefined' && typeof window.formatDateKey === 'function') {
          const fn = window.formatDateKey;
          // 验证是否是 date-utils.js 中的函数（接受 2 个参数：date, format）
          if (fn.length === 2) {
            return fn;
          }
        }
        return null;
      })();
      
      // ==================== 常量定义 ====================
      
      /** @constant {number} 防抖延迟时间（毫秒） */
      const DEBOUNCE_DELAY = 300;
      
      /** @constant {number} 日历显示周数 */
      const CALENDAR_WEEKS = 4;
      
      /** @constant {number} 每周天数 */
      const DAYS_PER_WEEK = 7;
      
      /** @constant {number} 日历每天显示的最大项目数 */
      const MAX_ITEMS_PER_DAY = 5;
      
      /** @constant {number} 日历单元格高度（像素）- 设置为显示5条记录（每条2行），留有上下空隙 */
      const CALENDAR_DAY_HEIGHT = 430;
      
      /** @constant {number} 日历单元格最小宽度（像素） */
      const CALENDAR_DAY_MIN_WIDTH = 180;
      
      /** @constant {number} 时间标签宽度（像素） */
      const TIME_LABEL_WIDTH = 120;
      
      /** @constant {number} 最大失败记录数（用于统计） */
      const MAX_FAILED_RECORDS = 20;
      
      // 调试函数已统一到 vendor/debug-utils.js
      // 使用：debugLog(), debugWarn(), debugError()
      
      /** @constant {string} 默认模式 */
      const DEFAULT_MODE = '365';
      
      /** @constant {string} 模式 365 */
      const MODE_365 = '365';
      
      /** @constant {string} 模式 001 */
      const MODE_001 = '001';
      
      /** @constant {string} Excel 文件类型 */
      const EXCEL_MIME_TYPES = '.xlsx,.xls';
      
      /** @constant {string} Schedule Sheet 关键词 */
      const SCHEDULE_SHEET_KEYWORD = 'schedule';
      
      /** @constant {number} 001 文件默认 Sheet 索引 */
      const SHEET_INDEX_001 = 0;
      
      /** @constant {number} 365 文件默认 Sheet 索引 */
      const SHEET_INDEX_365 = 1;
      
      /** @constant {string} 日期格式分隔符 */
      const DATE_SEPARATOR = '/';
      
      /** @constant {string} 港口分隔符 */
      const PORT_SEPARATOR = '、';
      
      // ==================== 错误处理 ====================
      // 注意：ErrorType 和 showError/showSuccess 已在 vendor/error-handler.js 中定义
      // 这里只添加页面特定的错误消息
      
      // 添加页面特定的错误消息（使用统一的错误处理模块）
      if (typeof addErrorMessage === 'function') {
        addErrorMessage(ErrorType.DATA_VALIDATION, 'NO_FILTERS', '请先选择筛选条件');
        addErrorMessage(ErrorType.DATA_VALIDATION, 'NO_FILTERED_DATA', '筛选后没有可分析的数据');
        addErrorMessage(ErrorType.DATA_VALIDATION, 'NO_DATA_FOR_ANALYSIS', '没有可分析的数据，请先加载Excel文件并选择筛选条件');
        addErrorMessage(ErrorType.API_ERROR, 'API_KEY_MISSING', '请先配置 {provider} 的 API Key');
        addErrorMessage(ErrorType.DOM_ERROR, 'ELEMENT_NOT_FOUND', '未找到必要的页面元素：{element}');
      }
      
      // 注意：港口标准化和排序现在统一使用 portSortUtils 和 Material-parsed_ports_list.txt
      // 调试函数已统一到 vendor/debug-utils.js，使用：debugLog(), debugWarn(), debugError()

      // ==================== 工具函数 =====================
      /**
       * 获取多选下拉框的选中值
       */
      function getSelectedValues(selectElement) {
        if (!selectElement) return [];
        return Array.from(selectElement.selectedOptions)
          .map(option => option.value)
          .filter(value => value !== '');
      }

      /**
       * 设置多选下拉框
       */
      function setupMultiSelect(selectElement) {
        if (!selectElement) return;
        selectElement.addEventListener('mousedown', (e) => {
          e.preventDefault();
          const option = e.target;
          if (option.tagName === 'OPTION') {
            option.selected = !option.selected;
            selectElement.dispatchEvent(new Event('change', { bubbles: true }));
          }
        });
      }

      /**
       * 填充下拉框选项
       */
      function populateSelect(selectElement, options, defaultLabel, selectedValues, disabled) {
        if (!selectElement) return;
        
        const currentSelected = getSelectedValues(selectElement);
        selectElement.innerHTML = '';
        
        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = defaultLabel;
        selectElement.appendChild(defaultOption);
        
        options.forEach(option => {
          const optionElement = document.createElement('option');
          optionElement.value = option;
          optionElement.textContent = option;
          if (selectedValues && selectedValues.includes(option)) {
            optionElement.selected = true;
          }
          selectElement.appendChild(optionElement);
        });
        
        selectElement.disabled = !!disabled;
      }

      /**
       * 全选选项
       */
      function selectAllOptions(selectElement) {
        if (!selectElement) return;
        Array.from(selectElement.options).forEach(option => {
          option.selected = true;
        });
        selectElement.dispatchEvent(new Event('change', { bubbles: true }));
      }

      /**
       * 清除所有选择
       */
      function clearSelectOptions(selectElement) {
        if (!selectElement) return;
        Array.from(selectElement.options).forEach(option => {
          option.selected = false;
        });
        selectElement.dispatchEvent(new Event('change', { bubbles: true }));
      }

      /**
       * 应用程序状态管理对象
       * @type {Object}
       * @property {Array<Object>|null} data001 - 001模式数据
       * @property {Array<Object>|null} data365 - 365模式数据
       * @property {string} currentMode - 当前显示模式（'001' 或 '365'）
       * @property {Array<string>} selectedOriginPorts - 选中的起运港
       * @property {Array<string>} selectedDestPorts - 选中的目的港（合并001和365）
       * @property {Array<string>} selectedCarriers - 选中的船公司（根据显示模式切换001/365）
       * @property {Set<string>} allCarriers001 - 001模式所有船公司
       * @property {Set<string>} allCarriers365 - 365模式所有船公司
       * @property {Set<string>} allOriginPorts - 所有起运港（合并001和365，不标准化，使用原始值）
       * @property {Set<string>} allDestPorts - 所有目的港（合并001和365，不标准化，使用原始值）
       */
      const state = {
        data001: null,
        data365: null,
        currentMode: DEFAULT_MODE,
        selectedOriginPorts: [],
        selectedDestPorts: [],
        selectedCarriers: [],
        allCarriers001: new Set(),
        allCarriers365: new Set(),
        allOriginPorts: new Set(),
        allDestPorts: new Set(),
        weekDefinitionMap: {} // 周别定义映射表（从week表解析）
      };

      // 事件监听器管理（用于清理）
      const eventListeners = {
        handlers: new Map(),
        add(element, event, handler, options) {
          if (!element) return;
          const key = `${element.constructor.name}_${event}_${handler.name || 'anonymous'}`;
          element.addEventListener(event, handler, options);
          if (!this.handlers.has(element)) {
            this.handlers.set(element, []);
          }
          this.handlers.get(element).push({ event, handler, options, key });
        },
        remove(element, event, handler) {
          if (!element) return;
          element.removeEventListener(event, handler);
          const listeners = this.handlers.get(element);
          if (listeners) {
            const index = listeners.findIndex(l => l.event === event && l.handler === handler);
            if (index > -1) {
              listeners.splice(index, 1);
            }
          }
        },
        removeAll(element) {
          if (!element) return;
          const listeners = this.handlers.get(element);
          if (listeners) {
            listeners.forEach(({ event, handler, options }) => {
              element.removeEventListener(event, handler, options);
            });
            this.handlers.delete(element);
          }
        },
        cleanup() {
          this.handlers.forEach((listeners, element) => {
            listeners.forEach(({ event, handler, options }) => {
              element.removeEventListener(event, handler, options);
            });
          });
          this.handlers.clear();
        }
      };

      /**
       * 防抖函数 - 延迟执行函数，直到停止调用后等待指定时间
       * @param {Function} func - 要防抖的函数
       * @param {number} [wait=DEBOUNCE_DELAY] - 等待时间（毫秒）
       * @returns {Function} 防抖后的函数
       */
      function debounce(func, wait = DEBOUNCE_DELAY) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      /**
       * DOM 元素缓存对象
       * 所有 DOM 查询结果都缓存在这里，避免重复查询
       * @type {Object<string, HTMLElement|NodeList>}
       */
      const dom = {
        file001: null,
        file365: null,
        status001: null,
        status365: null,
        modeBtns: null,
        originPortSelect: null,
        originPortSearch: null,
        destPortSelect: null,
        destPortSearch: null,
        carrierSelect: null,
        carrierSearch: null,
        calendarContainer: null,
        calendarBody: null,
        emptyMessage: null,
        aiAnalysisSection: null,
        emptyAiMessage: null,
        aiConfigSection: null
      };
      
      /**
       * 初始化 DOM 元素缓存
       * 在页面加载时调用，缓存所有需要的 DOM 元素
       */
      function initDOMCache() {
        dom.file001 = document.getElementById('file001');
        dom.file365 = document.getElementById('file365');
        dom.status001 = document.getElementById('status001');
        dom.status365 = document.getElementById('status365');
        dom.modeBtns = document.querySelectorAll('[data-mode]');
        dom.originPortSelect = document.getElementById('originPortSelect');
        dom.originPortSearch = document.getElementById('originPortSearch');
        dom.destPortSelect = document.getElementById('destPortSelect');
        dom.destPortSearch = document.getElementById('destPortSearch');
        dom.carrierSelect = document.getElementById('carrierSelect');
        dom.carrierSearch = document.getElementById('carrierSearch');
        dom.calendarContainer = document.getElementById('calendarContainer');
        dom.calendarBody = document.getElementById('calendarBody');
        dom.emptyMessage = document.getElementById('emptyMessage');
        dom.monthlySummaryContainer = document.getElementById('monthlySummaryContainer');
        dom.monthlySummaryTable = document.getElementById('monthlySummaryTable');
        dom.monthlySummaryEmptyMessage = document.getElementById('monthlySummaryEmptyMessage');
        dom.aiAnalysisSection = document.getElementById('aiModule');
        dom.emptyAiMessage = document.getElementById('emptyAiMessage');
        dom.aiConfigSection = document.getElementById('aiConfigSection');
        
        // 验证必要的 DOM 元素是否存在
        const requiredElements = [
          { key: 'file001', name: '001文件载入' },
          { key: 'file365', name: '365文件载入' },
          { key: 'originPortSelect', name: '起运港筛选器' },
          { key: 'destPortSelect', name: '目的港筛选器' },
          { key: 'carrierSelect', name: '船公司筛选器' },
          { key: 'calendarContainer', name: '日历容器' },
          { key: 'calendarBody', name: '日历主体' }
        ];
        
        const missingElements = requiredElements.filter(({ key }) => !dom[key]);
        if (missingElements.length > 0) {
          const missingNames = missingElements.map(e => e.name).join('、');
          showError(ErrorType.DOM_ERROR, 'ELEMENT_NOT_FOUND', { element: missingNames });
          debugWarn('缺少必要的 DOM 元素:', missingElements);
        }
      }

      /**
       * 初始化应用程序
       * 设置事件监听器、填充筛选器选项等
       */
      function init() {
        // 初始化 DOM 缓存
        initDOMCache();
        
        // 设置多选下拉框（参考001-04的实现）
        if (dom.originPortSelect) {
          setupMultiSelect(dom.originPortSelect);
        }
        if (dom.destPortSelect) {
          setupMultiSelect(dom.destPortSelect);
        }
        if (dom.carrierSelect) {
          setupMultiSelect(dom.carrierSelect);
        }

        // 事件监听（使用事件监听器管理）
        const handleFile001Change = (e) => handleFileUpload(e, '001');
        const handleFile365Change = (e) => handleFileUpload(e, '365');
        eventListeners.add(dom.file001, 'change', handleFile001Change);
        eventListeners.add(dom.file365, 'change', handleFile365Change);

        // 自动加载 Data 目录下的 Excel 文件
        // 使用公共函数加载 Excel 文件（从 vendor/common-utils.js）
        async function loadDefaultExcelFiles() {
          await window.loadDefaultExcelFiles('Market-Sailing-Schedule', {
            '001': async (file) => {
              // 创建模拟事件对象
              const event001 = { target: { files: [file] } };
              await handleFileUpload(event001, '001');
            },
            '365': async (file) => {
              // 创建模拟事件对象
              const event365 = { target: { files: [file] } };
              await handleFileUpload(event365, '365');
            }
          });
        }

        // 等待 XLSX 库加载完成后自动加载文件
        if (typeof window.ensureXlsx === 'function') {
          window.ensureXlsx().then(() => {
            loadDefaultExcelFiles();
          });
        } else {
          setTimeout(() => {
            if (typeof XLSX !== 'undefined') {
              loadDefaultExcelFiles();
            }
          }, 1000);
        }
        
        // 显示模式切换
        const btnMode001 = document.getElementById('btnMode001');
        const btnMode365 = document.getElementById('btnMode365');
        if (btnMode001) {
          eventListeners.add(btnMode001, 'click', () => {
            state.currentMode = MODE_001;
            btnMode001.classList.add('active');
            btnMode365.classList.remove('active');
            updateCarrierFilter();
            renderCalendar();
            renderMonthlySummary();
            updateAiModuleVisibility();
          });
        }
        if (btnMode365) {
          eventListeners.add(btnMode365, 'click', () => {
            state.currentMode = MODE_365;
            btnMode365.classList.add('active');
            btnMode001.classList.remove('active');
            updateCarrierFilter();
            renderCalendar();
            renderMonthlySummary();
            updateAiModuleVisibility();
          });
        }

        // 筛选器变化事件
        if (dom.originPortSelect) {
          eventListeners.add(dom.originPortSelect, 'change', handleFilterChange);
        }
        if (dom.destPortSelect) {
          eventListeners.add(dom.destPortSelect, 'change', handleFilterChange);
        }
        if (dom.carrierSelect) {
          eventListeners.add(dom.carrierSelect, 'change', handleFilterChange);
        }

        // 搜索功能（添加防抖）
        if (dom.originPortSearch) {
          const handleOriginPortSearch = debounce((e) => filterOptions('originPort', e.target.value));
          eventListeners.add(dom.originPortSearch, 'input', handleOriginPortSearch);
        }
        if (dom.destPortSearch) {
          const handleDestPortSearch = debounce((e) => filterOptions('destPort', e.target.value));
          eventListeners.add(dom.destPortSearch, 'input', handleDestPortSearch);
        }
        if (dom.carrierSearch) {
          const handleCarrierSearch = debounce((e) => filterOptions('carrier', e.target.value));
          eventListeners.add(dom.carrierSearch, 'input', handleCarrierSearch);
        }

        // 筛选器按钮事件
        const originPortSelectAll = document.getElementById('originPortSelectAll');
        const originPortClearAll = document.getElementById('originPortClearAll');
        const destPortSelectAll = document.getElementById('destPortSelectAll');
        const destPortClearAll = document.getElementById('destPortClearAll');
        const carrierSelectAll = document.getElementById('carrierSelectAll');
        const carrierClearAll = document.getElementById('carrierClearAll');
        
        if (originPortSelectAll && dom.originPortSelect) {
          eventListeners.add(originPortSelectAll, 'click', () => selectAllOptions(dom.originPortSelect));
        }
        if (originPortClearAll && dom.originPortSelect) {
          eventListeners.add(originPortClearAll, 'click', () => clearSelectOptions(dom.originPortSelect));
        }
        if (destPortSelectAll && dom.destPortSelect) {
          eventListeners.add(destPortSelectAll, 'click', () => selectAllOptions(dom.destPortSelect));
        }
        if (destPortClearAll && dom.destPortSelect) {
          eventListeners.add(destPortClearAll, 'click', () => clearSelectOptions(dom.destPortSelect));
        }
        if (carrierSelectAll && dom.carrierSelect) {
          eventListeners.add(carrierSelectAll, 'click', () => selectAllOptions(dom.carrierSelect));
        }
        if (carrierClearAll && dom.carrierSelect) {
          eventListeners.add(carrierClearAll, 'click', () => clearSelectOptions(dom.carrierSelect));
        }

      }

      // 注意：handleFilterAction 函数已废弃，引用了不存在的 DOM 元素（originPort001Select, destPort365Select）
      // 当前筛选器使用统一的 originPortSelect, destPortSelect, carrierSelect

      // 搜索筛选选项
      function filterOptions(type, searchText) {
        const searchLower = searchText.toLowerCase();
        let select;
        if (type === 'originPort') select = dom.originPortSelect;
        else if (type === 'destPort') select = dom.destPortSelect;
        else if (type === 'carrier') select = dom.carrierSelect;
        else return;

        if (!select) return;

        Array.from(select.options).forEach(option => {
          const text = option.textContent.toLowerCase();
          if (text.includes(searchLower)) {
            option.classList.remove('hidden');
          } else {
            option.classList.add('hidden');
          }
        });
      }

      // 处理文件载入
      async function handleFileUpload(event, mode) {
        const file = event.target.files?.[0];
        if (!file) return;

        if (typeof window.XLSX === "undefined") {
          showError(ErrorType.FILE_LOAD, 'XLSX_NOT_LOADED');
          return;
        }

        const statusEl = mode === '001' ? dom.status001 : dom.status365;
        const filePrefix = mode === '001' ? '001文件' : '365文件';
        statusEl.textContent = `${filePrefix}解析中...`;

        try {
          const data = await file.arrayBuffer();
          // 对于001文件，不使用cellDates: true，因为可能日期格式不一致
          // 使用raw模式读取，然后手动解析日期
          const workbook = XLSX.read(data, { 
            type: "array", 
            cellDates: false,  // 改为false，手动解析日期
            cellNF: false, 
            cellText: false,
            dateNF: 'yyyy-mm-dd'  // 指定日期格式（如果Excel中有格式）
          });
          
          // 查找并解析 week 工作表（与001-04/365-04保持一致）
          const weekSheetName = workbook.SheetNames.find(name => 
            name.toLowerCase() === 'week' || name.toLowerCase().includes('week')
          );
          if (weekSheetName) {
            const weekWorksheet = workbook.Sheets[weekSheetName];
            const weekData = XLSX.utils.sheet_to_json(weekWorksheet, { header: 1, defval: null, raw: true });
            if (typeof window.parseWeekDefinitions === 'function') {
              state.weekDefinitionMap = window.parseWeekDefinitions(weekData, {
                weekTextColumn: 3, // D列（索引3）
                dateRangeColumn: 0 // A列（索引0）
              });
              debugLog(`已解析week表，共 ${Object.keys(state.weekDefinitionMap).length} 个周别定义`);
            } else {
              debugWarn('parseWeekDefinitions 函数未加载，请检查 week-definition-parser.js 是否已加载');
              state.weekDefinitionMap = {};
            }
          } else {
            debugWarn('未找到week工作表，将使用计算方式获取周数');
            state.weekDefinitionMap = {};
          }
          
          // 根据模式选择正确的sheet
          let sheetName;
          if (mode === MODE_001) {
            // 001文件：第一个sheet是schedule（索引0）
            // 优先使用第一个sheet，如果第一个sheet名称包含schedule则使用，否则也使用第一个
            if (workbook.SheetNames.length > 0) {
              const firstSheet = workbook.SheetNames[0];
              // 如果第一个sheet名称包含schedule，使用它；否则也使用第一个sheet
              if (firstSheet.toLowerCase().includes('schedule')) {
                sheetName = firstSheet;
              } else {
                // 查找是否有其他sheet包含schedule，如果有且是第一个，使用它；否则使用第一个sheet
                const scheduleSheet = workbook.SheetNames.find(name => 
                  name.toLowerCase().includes('schedule')
                );
                sheetName = scheduleSheet || firstSheet;
              }
            } else {
              // 使用统一的错误处理模块
              const noSheetsMsg = typeof getErrorMessage === 'function'
                  ? getErrorMessage(ErrorType.FILE_LOAD, 'NO_SHEETS')
                  : 'Excel文件中没有找到任何工作表';
              throw new Error(noSheetsMsg);
            }
            debugLog('001模式选择的sheet:', sheetName, '所有sheet:', workbook.SheetNames);
          } else {
            // 365文件：第二个sheet是schedule
            const scheduleSheet = workbook.SheetNames.find(name => 
              name.toLowerCase().includes(SCHEDULE_SHEET_KEYWORD)
            );
            if (scheduleSheet) {
              sheetName = scheduleSheet;
            } else if (workbook.SheetNames.length > SHEET_INDEX_365) {
              // 如果找不到schedule，使用第二个sheet
              sheetName = workbook.SheetNames[SHEET_INDEX_365];
            } else {
              // 如果只有一个sheet，使用第一个
              sheetName = workbook.SheetNames[SHEET_INDEX_001];
            }
            debugLog('365模式选择的sheet:', sheetName, '所有sheet:', workbook.SheetNames);
          }
          
          const sheet = workbook.Sheets[sheetName];
          // 使用 raw: true 来获取原始值，包括日期序列号
          const jsonData = XLSX.utils.sheet_to_json(sheet, { raw: true, defval: null });

          // 解析数据（使用不同的解析方法）
          const parsedData = mode === MODE_001 ? parseExcelData001(jsonData) : parseExcelData365(jsonData);
          
          // 检查解析结果
          if (!Array.isArray(parsedData)) {
            throw new Error('数据解析失败：解析函数返回了无效的数据格式');
          }
          
          if (parsedData.length === 0) {
            const filePrefix = mode === '001' ? '001文件' : '365文件';
            throw new Error(`${filePrefix}解析后没有有效数据，请检查：\n1. 文件格式是否正确\n2. 是否包含必要列（目的港、船公司、船期）\n3. 数据是否为空`);
          }
          
          if (mode === MODE_001) {
            state.data001 = parsedData;
          } else {
            state.data365 = parsedData;
          }

          const filePrefix = mode === '001' ? '001文件' : '365文件';
          statusEl.textContent = `${filePrefix}已加载 ${parsedData.length} 条记录`;
          
          // 更新筛选器（联动更新）
          await updateFilterOptions();
          renderCalendar();
          renderMonthlySummary(); // 渲染月度汇总表格
          updateAiModuleVisibility(); // 更新 AI 模块可见性
        } catch (error) {
          debugError('解析文件失败:', error);
          const filePrefix = mode === '001' ? '001文件' : '365文件';
          statusEl.textContent = `${filePrefix}加载失败`;
          showError(ErrorType.FILE_PARSE, 'PARSE_FAILED', {}, error);
        }
      }

      // ==================== 公共解析工具函数 ====================
      
      /**
       * 将Excel列字母转换为索引（A=0, B=1, ..., Z=25, AA=26, ...）
       * @param {string} letter - 列字母（如 'A', 'B', 'AA'）
       * @returns {number|null} 列索引，如果无效则返回 null
       */
      function columnLetterToIndex(letter) {
        if (!letter) return null;
        let index = 0;
        const up = letter.trim().toUpperCase();
        for (let i = 0; i < up.length; i++) {
          const charCode = up.charCodeAt(i);
          if (charCode < 65 || charCode > 90) return null;
          index = index * 26 + (charCode - 64);
        }
        return index - 1;
      }

      /**
       * 匹配列名（检查单个关键词）
       * @param {string} key - 要匹配的列名
       * @param {string} keyword - 关键词
       * @returns {boolean} 是否匹配
       */
      function matchesKeyword(key, keyword) {
        if (!key || !keyword) return false;
        const lowerKey = String(key).toLowerCase();
        const lowerKeyword = String(keyword).toLowerCase();
        return lowerKey.includes(lowerKeyword);
      }

      /**
       * 通用数据行解析函数（抽取公共逻辑）
       * @param {Object} row - Excel行数据对象
       * @param {Object} config - 列配置对象
       * @param {string} mode - 解析模式（'001' 或 '365'）
       * @returns {Object|null} 解析后的数据对象，如果无效则返回 null
       */
      function parseDataRow(row, config, mode) {
        const {
          originPortCol,
          portCol,
          carrierCol,
          dateCol,
          vesselCol,
          shipTypeCol,
          weekdayCol,
          voyageDaysCol,
          originTerminalCol,
          destTerminalCol,
          routeIdCol,
          vesselNameCol,
          yearCol,
          routePathCol
        } = config;

        // 提取起运港（A列，不标准化）
        const originPort = originPortCol && row[originPortCol] ? String(row[originPortCol]).trim() : '';
        
        // 提取基础字段
        // 001模式：提取目的港（B列，不标准化）
        // 365模式：提取目的港（B列，不标准化）
        const rawPort = row[portCol];
        let port = '';
        
        if (mode === MODE_001) {
          // 001模式：目的港不标准化
          port = rawPort ? String(rawPort).trim() : '';
        } else {
          // 365模式：目的港不标准化
          port = rawPort ? String(rawPort).trim() : '';
        }
        
        const carrier = row[carrierCol] ? String(row[carrierCol]).trim() : '';
        const vessel = vesselCol && row[vesselCol] ? String(row[vesselCol]).trim() : '';
        const shipType = shipTypeCol && row[shipTypeCol] ? String(row[shipTypeCol]).trim() : '';

        // 验证必要字段
        // 001和365模式：目的港只需要非空（不标准化）
        if (!port) return null;
        if (!carrier) return null;

        // 解析日期
        const rawDate = row[dateCol];
        const date = parseDate(rawDate);
        if (!date || isNaN(date.getTime())) return null;

        // 提取额外字段
        const weekday = weekdayCol && row[weekdayCol] ? String(row[weekdayCol]).trim() : '';
        const voyageDays = voyageDaysCol && row[voyageDaysCol] ? String(row[voyageDaysCol]).trim() : '';
        const originTerminal = originTerminalCol && row[originTerminalCol] ? String(row[originTerminalCol]).trim() : '';
        
        // 目的港码头处理（001模式特殊处理：只取/前的部分）
        let destTerminal = '';
        if (destTerminalCol && row[destTerminalCol]) {
          const destTerminalRaw = String(row[destTerminalCol]).trim();
          if (mode === MODE_001) {
            destTerminal = destTerminalRaw.includes(DATE_SEPARATOR) ? destTerminalRaw.split(DATE_SEPARATOR)[0].trim() : destTerminalRaw;
          } else {
            destTerminal = destTerminalRaw;
          }
        }

        // 提取航线ID（001模式：C列，365模式：G列）
        // 清理航线ID：去除无效字符，只保留数字、字母和常见分隔符
        let routeId = '';
        if (routeIdCol && row[routeIdCol]) {
          const rawRouteId = String(row[routeIdCol]).trim();
          // 只保留数字、字母、连字符、下划线，过滤掉乱码和特殊字符
          const cleaned = rawRouteId.replace(/[^\w\-]/g, '');
          // 如果清理后还有有效内容（至少包含数字或字母），才使用
          if (cleaned && /[0-9A-Za-z]/.test(cleaned)) {
            routeId = cleaned;
          }
        }

        // 构建基础数据对象
        const baseData = {
          originPort,
          port,
          carrier,
          date,
          vessel,
          shipType,
          weekday,
          voyageDays,
          originTerminal,
          destTerminal,
          mode,
          routeId
        };

        // 365模式特有字段
        if (mode === MODE_365) {
          baseData.vesselName = vesselNameCol && row[vesselNameCol] ? String(row[vesselNameCol]).trim() : '';
          baseData.year = yearCol && row[yearCol] ? String(row[yearCol]).trim() : '';
          baseData.routePath = routePathCol && row[routePathCol] ? String(row[routePathCol]).trim() : '';
        }

        return baseData;
      }

      // 解析Excel数据 - 001文件专用
      function parseExcelData001(jsonData) {
        if (!jsonData || jsonData.length === 0) return [];

        const firstRow = jsonData[0];
        const columnKeys = Object.keys(firstRow);

        const getColumnKey = (keywords, fallbackLetter = null) => {
          const key = columnKeys.find(col => 
            keywords.some(keyword => matchesKeyword(col, keyword))
          );
          if (key) return key;
          if (fallbackLetter) {
            const idx = columnLetterToIndex(fallbackLetter);
            if (idx !== null && columnKeys[idx]) {
              return columnKeys[idx];
            }
          }
          return null;
        };

        // 001文件列定义（参照365模式，使用索引作为fallback）
        const originPortCol = getColumnKey(['起运港', 'pol', 'origin'], 'A'); // A列 - 起运港（不标准化）
        const portCol = getColumnKey(['港口', '目的港', 'pod'], 'B'); // B列 - 目的港（不标准化）
        const carrierCol = getColumnKey(['共舱船公司', '共舱', '船公司'], 'G'); // G列
        
        // 航线ID：参照365模式，使用索引2（C列）作为fallback
        const cColIndex = columnLetterToIndex('C');
        const routeIdCol = getColumnKey(['航线id', '航线ID', 'route id', 'group_id', 'groupid'], 'C') || 
                          (cColIndex !== null && columnKeys[cColIndex] ? columnKeys[cColIndex] : null); // C列（索引2）- 航线ID
        // 强制使用M列（索引12）作为日期列，避免关键词匹配到错误列
        const mColIndexForDate = columnLetterToIndex('M');
        const dateCol = (mColIndexForDate !== null && columnKeys[mColIndexForDate]) ? columnKeys[mColIndexForDate] : getColumnKey(['船期', '开船', '离港', 'etd'], 'M'); // M列
        // 强制使用K列（索引10）作为船名航次列，避免关键词匹配到错误列（如I列）
        const kColIndex = columnLetterToIndex('K');
        const vesselCol = (kColIndex !== null && columnKeys[kColIndex]) ? columnKeys[kColIndex] : getColumnKey(['船名', '航次', 'vessel'], 'K'); // K列 - 船名航次
        // 强制使用L列（索引11）作为船型列
        const lColIndex = columnLetterToIndex('L');
        const shipTypeCol = (lColIndex !== null && columnKeys[lColIndex]) ? columnKeys[lColIndex] : null; // L列 - 船型
        
        // 001模式悬停框额外列：E、F、P、Q
        const eColIndex = columnLetterToIndex('E');
        const weekdayCol = (eColIndex !== null && columnKeys[eColIndex]) ? columnKeys[eColIndex] : null; // E列 - 标准开航日
        const fColIndex = columnLetterToIndex('F');
        const voyageDaysCol = (fColIndex !== null && columnKeys[fColIndex]) ? columnKeys[fColIndex] : null; // F列 - 标准航程
        const pColIndex = columnLetterToIndex('P');
        const originTerminalCol = (pColIndex !== null && columnKeys[pColIndex]) ? columnKeys[pColIndex] : null; // P列 - 起运港码头
        const qColIndex = columnLetterToIndex('Q');
        const destTerminalCol = (qColIndex !== null && columnKeys[qColIndex]) ? columnKeys[qColIndex] : null; // Q列 - 目的港码头

        // 调试：显示列映射信息（仅在调试模式下）
        debugLog('001文件列映射:');
        debugLog('所有列:', columnKeys);
        debugLog('B列索引:', columnLetterToIndex('B'), '港口列:', portCol, '索引:', columnKeys.indexOf(portCol));
        debugLog('C列索引:', columnLetterToIndex('C'), '航线ID列:', routeIdCol, '索引:', routeIdCol ? columnKeys.indexOf(routeIdCol) : 'N/A');
        debugLog('G列索引:', columnLetterToIndex('G'), '船公司列:', carrierCol, '索引:', columnKeys.indexOf(carrierCol));
        debugLog('M列索引:', mColIndexForDate, '日期列:', dateCol, '索引:', columnKeys.indexOf(dateCol));
        debugLog('K列索引:', columnLetterToIndex('K'), '船名列:', vesselCol, '索引:', vesselCol ? columnKeys.indexOf(vesselCol) : 'N/A');
        debugLog('L列索引:', lColIndex, '船型列:', shipTypeCol, '索引:', shipTypeCol ? columnKeys.indexOf(shipTypeCol) : 'N/A');
        debugLog('E列索引:', eColIndex, '标准开航日列:', weekdayCol, '索引:', weekdayCol ? columnKeys.indexOf(weekdayCol) : 'N/A');
        debugLog('F列索引:', fColIndex, '标准航程列:', voyageDaysCol, '索引:', voyageDaysCol ? columnKeys.indexOf(voyageDaysCol) : 'N/A');
        debugLog('P列索引:', pColIndex, '起运港码头列:', originTerminalCol, '索引:', originTerminalCol ? columnKeys.indexOf(originTerminalCol) : 'N/A');
        debugLog('Q列索引:', qColIndex, '目的港码头列:', destTerminalCol, '索引:', destTerminalCol ? columnKeys.indexOf(destTerminalCol) : 'N/A');
        
        // 检查M列和N列的实际数据（前5行）
        const nColIndex = columnLetterToIndex('N');
        if (mColIndexForDate !== null && columnKeys[mColIndexForDate]) {
          const mColKey = columnKeys[mColIndexForDate];
          debugLog('M列实际列名:', mColKey, '前5行数据:', jsonData.slice(0, 5).map(r => r[mColKey]));
        }
        if (nColIndex !== null && columnKeys[nColIndex]) {
          const nColKey = columnKeys[nColIndex];
          debugLog('N列实际列名:', nColKey, '前5行数据:', jsonData.slice(0, 5).map(r => r[nColKey]));
        }

        if (!portCol || !carrierCol || !dateCol) {
          const missingCols = [];
          if (!portCol) missingCols.push('目的港(B列)');
          if (!carrierCol) missingCols.push('船公司(G列)');
          if (!dateCol) missingCols.push('船期(M列)');
          const errorMsg = `001文件缺少必要的列：${missingCols.join('、')}`;
          debugError('001文件缺少必要的列:', { portCol, carrierCol, dateCol, allColumns: columnKeys });
          throw new Error(errorMsg);
        }

        const parsed = [];
        const carriers = state.allCarriers001;
        const ports = new Set(); // 用于统计，不用于验证（001模式目的港不标准化）
        
        // 统计信息
        let totalRows = 0;
        let skippedPort = 0;
        let skippedCarrier = 0;
        let skippedDate = 0;
        const failedPorts = new Map(); // 记录映射失败的港口名称
        const failedDates = new Map(); // 记录解析失败的日期格式（前20个）

        // 构建列配置对象
        const columnConfig = {
          originPortCol,
          portCol,
          carrierCol,
          dateCol,
          vesselCol,
          shipTypeCol,
          weekdayCol,
          voyageDaysCol,
          originTerminalCol,
          destTerminalCol,
          routeIdCol
        };

        jsonData.forEach(row => {
          totalRows++;
          
          // 使用公共解析函数
          const parsedRow = parseDataRow(row, columnConfig, '001');
          
          if (!parsedRow) {
            // 记录失败原因（001模式：目的港不标准化，直接使用原始值）
            const rawPort = row[portCol];
            const port = rawPort ? String(rawPort).trim() : ''; // 001模式：不标准化
            const carrier = row[carrierCol] ? String(row[carrierCol]).trim() : '';
            const rawDate = row[dateCol];
            
            if (!port) {
              skippedPort++;
              if (rawPort) {
                const rawPortStr = String(rawPort).trim();
                failedPorts.set(rawPortStr, (failedPorts.get(rawPortStr) || 0) + 1);
              }
            } else if (!carrier) {
              skippedCarrier++;
            } else {
              skippedDate++;
              // 记录失败的日期格式（只记录前20个不同的格式）
              if (failedDates.size < 20 && rawDate !== null && rawDate !== undefined) {
                const dateStr = String(rawDate);
                if (!failedDates.has(dateStr)) {
                  failedDates.set(dateStr, {
                    value: rawDate,
                    type: typeof rawDate,
                    sample: dateStr.substring(0, 50)
                  });
                }
              }
            }
            return;
          }

          parsed.push(parsedRow);
          carriers.add(parsedRow.carrier);
          ports.add(parsedRow.port);
          // 收集起运港和目的港（合并001和365）
          if (parsedRow.originPort) {
            state.allOriginPorts.add(parsedRow.originPort);
          }
          if (parsedRow.port) {
            state.allDestPorts.add(parsedRow.port);
          }
        });

        // 输出统计信息（仅在调试模式下）
        debugLog('001文件解析统计:');
        debugLog(`总行数: ${totalRows}`);
        debugLog(`成功解析: ${parsed.length}`);
        debugLog(`跳过-港口映射失败: ${skippedPort}`);
        debugLog(`跳过-船公司为空: ${skippedCarrier}`);
        debugLog(`跳过-日期无效: ${skippedDate}`);
        
        // 输出映射失败的港口（按出现次数排序，只显示前20个）
        if (failedPorts.size > 0) {
          const sortedFailedPorts = Array.from(failedPorts.entries())
            .sort((a, b) => b[1] - a[1])
            .slice(0, 20);
          debugLog('映射失败的港口（前20个）:', sortedFailedPorts);
        }
        
        // 输出解析失败的日期格式
        if (failedDates.size > 0) {
          debugLog('解析失败的日期格式（前20个）:', Array.from(failedDates.entries()));
        }

        return parsed;
      }

      /**
       * 解析Excel数据 - 365文件专用
       * @param {Array<Object>} jsonData - Excel转换后的JSON数据
       * @returns {Array<Object>} 解析后的船期数据数组
       */
      function parseExcelData365(jsonData) {
        if (!jsonData || jsonData.length === 0) return [];

        const firstRow = jsonData[0];
        const columnKeys = Object.keys(firstRow);

        const findColumnKey = (keywords, fallbackIndex = null) => {
          const key = columnKeys.find(col => 
            keywords.some(keyword => matchesKeyword(col, keyword))
          );
          if (key) return key;
          if (typeof fallbackIndex === 'number' && columnKeys[fallbackIndex]) {
            return columnKeys[fallbackIndex];
          }
          return null;
        };

        // 365文件列定义（删除C-F列后更新）
        const originPortCol = findColumnKey(['起运港', 'pol', 'origin'], 0); // A列（索引0）- 起运港（不标准化）
        const portCol = findColumnKey(['港口', '目的港', 'pod'], 1); // B列（索引1）- 目的港（不标准化）
        const routeIdCol = findColumnKey(['航线id', '航线ID', 'route id', 'group_id', 'groupid'], 2); // C列（索引2）- 航线ID
        const weekdayCol = columnKeys[3] || null; // D列（索引3）- 标准开航日
        const voyageDaysCol = columnKeys[4] || null; // E列（索引4）- 标准航程
        const carrierCol = findColumnKey(['共舱', '船公司'], 5); // F列（索引5）- 共舱船公司
        const routeRemarkCol = columnKeys[6] || null; // G列（索引6）- 航线备注
        const vesselCol = columnKeys[7] || findColumnKey(['船名', '航次', 'vessel'], 7); // H列（索引7）- 船名航次
        const dateCol = findColumnKey(['船期', '开船', '离港', 'etd'], 8); // I列（索引8）- 开船日期
        const originTerminalCol = columnKeys[9] || null; // J列（索引9）- 起运港码头
        const destTerminalCol = columnKeys[10] || null; // K列（索引10）- 目的港码头
        const vesselNameCol = columnKeys[12] || null; // M列（索引12）- 船名
        const shipTypeCol = columnKeys[14] || null; // O列（索引14）- 船型
        const yearCol = columnKeys[16] || null; // Q列（索引16）- 年份
        const routePathCol = columnKeys[20] || null; // U列（索引20）- 航线路径

        if (!portCol || !carrierCol || !dateCol) {
          debugWarn('365文件缺少必要的列:', { portCol, carrierCol, dateCol, allColumns: columnKeys });
          // 如果通过关键词找不到，强制使用索引（删除C-F列后的新索引）
          const portColFallback = columnKeys[1] || null; // B列
          const carrierColFallback = columnKeys[5] || null; // F列
          const dateColFallback = columnKeys[8] || null; // I列
          const routeIdColFallback = columnKeys[2] || null; // C列
          
          if (!portColFallback || !carrierColFallback || !dateColFallback) {
            const missingCols = [];
            if (!portColFallback) missingCols.push('目的港(B列)');
            if (!carrierColFallback) missingCols.push('船公司(F列)');
            if (!dateColFallback) missingCols.push('船期(I列)');
            const errorMsg = `365文件缺少必要的列：${missingCols.join('、')}`;
            debugError('365文件缺少必要的列:', { portCol, carrierCol, dateCol, portColFallback, carrierColFallback, dateColFallback, allColumns: columnKeys });
            throw new Error(errorMsg);
          }
          
          // 使用fallback
          const finalPortCol = portCol || portColFallback;
          const finalCarrierCol = carrierCol || carrierColFallback;
          const finalDateCol = dateCol || dateColFallback;
          const finalRouteIdCol = routeIdCol || routeIdColFallback;
          
          return parse365WithColumns(jsonData, originPortCol || columnKeys[0] || null, finalPortCol, finalCarrierCol, finalDateCol, vesselCol,
            weekdayCol, voyageDaysCol, originTerminalCol, destTerminalCol, shipTypeCol, yearCol, routePathCol,
            finalRouteIdCol, vesselNameCol);
        }

        return parse365WithColumns(jsonData, originPortCol || columnKeys[0] || null, portCol, carrierCol, dateCol, vesselCol,
          weekdayCol, voyageDaysCol, originTerminalCol, destTerminalCol, shipTypeCol, yearCol, routePathCol,
          routeIdCol, vesselNameCol);
      }

      // 365文件数据解析（使用指定列）
      function parse365WithColumns(jsonData, originPortCol, portCol, carrierCol, dateCol, vesselCol,
        weekdayCol, voyageDaysCol, originTerminalCol, destTerminalCol, shipTypeCol, yearCol, routePathCol,
        routeIdCol, vesselNameCol) {
        const parsed = [];
        const carriers = state.allCarriers365;
        const ports = new Set(); // 用于统计，不用于验证（365模式目的港不标准化）

        // 构建列配置对象
        const columnConfig = {
          originPortCol,
          portCol,
          carrierCol,
          dateCol,
          vesselCol,
          shipTypeCol,
          weekdayCol,
          voyageDaysCol,
          originTerminalCol,
          destTerminalCol,
          routeIdCol,
          vesselNameCol,
          yearCol,
          routePathCol
        };

        jsonData.forEach(row => {
          // 使用公共解析函数
          const parsedRow = parseDataRow(row, columnConfig, '365');
          
          if (!parsedRow) {
            return; // 跳过无效数据
          }

          parsed.push(parsedRow);
          carriers.add(parsedRow.carrier);
          ports.add(parsedRow.port);
          // 收集起运港和目的港（合并001和365）
          if (parsedRow.originPort) {
            state.allOriginPorts.add(parsedRow.originPort);
          }
          if (parsedRow.port) {
            state.allDestPorts.add(parsedRow.port);
          }
        });

        return parsed;
      }

      // parseDate 函数已移至 vendor/common-utils.js
      // 港口标准化功能已迁移到 portSortUtils，使用 Material-parsed_ports_list.txt 作为数据源

      /**
       * 更新船公司筛选器（联动更新）
       * 根据当前选中的区域和港口，更新可用的船公司选项
       */
      function updateCarrierFilter() {
        const currentData = state.currentMode === MODE_001 ? state.data001 : state.data365;
        if (!currentData || currentData.length === 0) {
          if (dom.carrierSelect) {
            populateSelect(dom.carrierSelect, [], '全部共舱船公司', [], false);
          }
          return;
        }

        // 根据当前筛选条件，获取可用的船公司
        const availableCarriers = getAvailableCarriers(currentData);
        
        // 保存当前选中的值
        const currentSelected = getSelectedValues(dom.carrierSelect);
        
        // 使用populateSelect函数填充选项
        populateSelect(
          dom.carrierSelect,
          Array.from(availableCarriers).sort((a, b) => a.localeCompare(b, 'zh-Hans-CN')),
          '全部共舱船公司',
          currentSelected,
          false
        );
      }
      
      /**
       * 更新筛选器选项
       */
      async function updateFilterOptions() {
        // 提取 A 列起运港顺序（用于排序）- 合并 001 和 365 数据
        const originPortOrder = [];
        const seenOriginPorts = new Set();
        const allData = [];
        if (state.data001) allData.push(...state.data001);
        if (state.data365) allData.push(...state.data365);
        allData.forEach(record => {
          if (record.originPort && record.originPort.trim() && !seenOriginPorts.has(record.originPort.trim())) {
            originPortOrder.push(record.originPort.trim());
            seenOriginPorts.add(record.originPort.trim());
          }
        });
        
        // 提取 B 列目的港顺序（用于排序）- 合并 001 和 365 数据
        const destPortOrder = [];
        const seenDestPorts = new Set();
        allData.forEach(record => {
          if (record.port && record.port.trim() && !seenDestPorts.has(record.port.trim())) {
            destPortOrder.push(record.port.trim());
            seenDestPorts.add(record.port.trim());
          }
        });
        
        // 更新起运港筛选器
        if (dom.originPortSelect) {
          let originPorts = Array.from(state.allOriginPorts);
          
          // 使用统一的排序函数（按 A 列起运港顺序 + 区域顺序 + 代码顺序）
          if (typeof window !== 'undefined' && typeof window.portSortUtils !== 'undefined') {
            try {
              // 确保港口映射已加载
              if (!window.portSortUtils.portsMappingLoaded) {
                await window.portSortUtils.loadPortsMapping();
              }
              // 使用新的统一排序函数
              originPorts = window.portSortUtils.sortPortsByDataAndRegion(originPorts, originPortOrder);
            } catch (error) {
              debugWarn('portSortUtils.sortPortsByDataAndRegion 失败，使用降级方案:', error);
              // 降级方案：简单排序
              originPorts = originPorts.sort((a, b) => a.localeCompare(b, 'zh-Hans-CN'));
            }
          } else {
            // 降级方案：简单排序
            originPorts = originPorts.sort((a, b) => a.localeCompare(b, 'zh-Hans-CN'));
          }
          
          const filteredOriginPorts = dom.originPortSearch && dom.originPortSearch.value.trim()
            ? originPorts.filter(port => 
                port.toLowerCase().includes(dom.originPortSearch.value.toLowerCase())
              )
            : originPorts;
          
          populateSelect(
            dom.originPortSelect,
            filteredOriginPorts,
            '全部起运港',
            state.selectedOriginPorts,
            filteredOriginPorts.length === 0,
            false
          );
        }
        
        // 更新目的港筛选器（合并001和365）
        if (dom.destPortSelect) {
          let destPorts = Array.from(state.allDestPorts);
          
          // 使用统一的排序函数（按 B 列目的港顺序 + 区域顺序 + 代码顺序）
          if (typeof window !== 'undefined' && typeof window.portSortUtils !== 'undefined') {
            try {
              // 确保港口映射已加载
              if (!window.portSortUtils.portsMappingLoaded) {
                await window.portSortUtils.loadPortsMapping();
              }
              // 使用新的统一排序函数
              destPorts = window.portSortUtils.sortPortsByDataAndRegion(destPorts, destPortOrder);
            } catch (error) {
              debugWarn('portSortUtils.sortPortsByDataAndRegion 失败，使用降级方案:', error);
              // 降级方案：简单排序
              destPorts = destPorts.sort((a, b) => a.localeCompare(b, 'zh-Hans-CN'));
            }
          } else {
            // 降级方案：简单排序
            destPorts = destPorts.sort((a, b) => a.localeCompare(b, 'zh-Hans-CN'));
          }
          
          const filteredDestPorts = dom.destPortSearch && dom.destPortSearch.value.trim()
            ? destPorts.filter(port => 
                port.toLowerCase().includes(dom.destPortSearch.value.toLowerCase())
              )
            : destPorts;
          
          populateSelect(
            dom.destPortSelect,
            filteredDestPorts,
            '全部目的港',
            state.selectedDestPorts,
            filteredDestPorts.length === 0,
            false
          );
        }
        
        // 更新船公司筛选器（根据显示模式）
        updateCarrierFilter();
      }

      // 注意：updatePortFilter 函数已废弃，引用了不存在的 DOM 元素（destPort365Select）
      // 当前使用统一的 updateFilterOptions 函数更新所有筛选器
      // 注意：getAvailableRegions 函数已删除（未使用，依赖已废弃的 getPortRegion）

      // 获取可用的船公司（基于当前起运港和目的港筛选）
      function getAvailableCarriers(data) {
        const filtered = data.filter(item => {
          // 起运港筛选
          if (state.selectedOriginPorts.length > 0) {
            if (!item.originPort || !state.selectedOriginPorts.includes(item.originPort)) {
              return false;
            }
          }
          // 目的港筛选（合并001和365）
          if (state.selectedDestPorts.length > 0) {
            if (!item.port || !state.selectedDestPorts.includes(item.port)) {
              return false;
            }
          }
          return true;
        });
        
        const carriers = new Set(filtered.map(item => item.carrier));
        return Array.from(carriers).sort();
      }

      /**
       * 获取可用的港口（基于当前001目的港和船公司筛选）
       * @param {Array} data - 当前模式的数据数组
       * @returns {Array} 可用的港口列表
       */
      function getAvailablePorts(data) {
        const filtered = data.filter(item => {
          // 起运港筛选
          if (state.selectedOriginPorts.length > 0) {
            if (!item.originPort || !state.selectedOriginPorts.includes(item.originPort)) {
              return false;
            }
          }
          // 船公司筛选
          if (state.selectedCarriers.length > 0) {
            if (!state.selectedCarriers.includes(item.carrier)) {
              return false;
            }
          }
          return true;
        });
        
        const ports = new Set(filtered.map(item => item.port));
        return Array.from(ports);
      }

      // 注意：updateRegionFilter 函数已废弃，引用了不存在的 DOM 元素（originPort001Select）
      // 当前使用统一的 updateFilterOptions 函数更新所有筛选器

      // 处理筛选变化（联动更新）- 使用防抖优化性能
      const handleFilterChange = debounce(async () => {
        // 更新筛选状态
        state.selectedOriginPorts = getSelectedValues(dom.originPortSelect);
        state.selectedDestPorts = getSelectedValues(dom.destPortSelect);
        state.selectedCarriers = getSelectedValues(dom.carrierSelect);
        
        // 联动更新筛选器（异步）
        await updateFilterOptions();
        
        // 使用 requestAnimationFrame 优化渲染性能
        requestAnimationFrame(() => {
          renderCalendar();
          renderMonthlySummary(); // 渲染月度汇总表格
          updateAiModuleVisibility(); // 更新 AI 模块可见性
        });
      }, 150); // 150ms 防抖延迟

      /**
       * 筛选数据（根据当前筛选条件）
       * @param {Array} currentData - 当前模式的数据
       * @returns {Array} 筛选后的数据
       */
      function filterDataBySelection(currentData) {
        return currentData.filter(item => {
          // 起运港筛选
          if (state.selectedOriginPorts.length > 0) {
            if (!item.originPort || !state.selectedOriginPorts.includes(item.originPort)) {
              return false;
            }
          }

          // 目的港筛选（合并001和365）
          if (state.selectedDestPorts.length > 0) {
            if (!item.port || !state.selectedDestPorts.includes(item.port)) {
              return false;
            }
          }

          // 船公司筛选
          if (state.selectedCarriers.length > 0) {
            if (!state.selectedCarriers.includes(item.carrier)) {
              return false;
            }
          }

          return true;
        });
      }

      /**
       * 按日期分组数据
       * @param {Array} filteredData - 筛选后的数据
       * @returns {Object} 按日期键分组的数据对象
       */
      function groupDataByDate(filteredData) {
        const dataByDate = {};
        filteredData.forEach(item => {
          const dateKey = formatDateKey(item.date);
          if (!dataByDate[dateKey]) {
            dataByDate[dateKey] = [];
          }
          dataByDate[dateKey].push(item);
        });
        return dataByDate;
      }

      /**
       * 合并同船名航次船型的港口（提取为独立函数）
       * @param {Array} items - 去重后的数据项
       * @returns {Array} 合并后的数据项
       */
      function mergeItemsByVessel(items) {
        const grouped = {};
        
        items.forEach(item => {
          let groupKey;
          let vesselName, voyageNumber, shipType, carrier;
          
          // 365模式：同一天 + 同船名(Q列) + 同航线ID(G列)
          if (item.mode === '365') {
            const dateKey = formatDateKey(item.date);
            vesselName = item.vesselName || getVesselName(item.vessel || '');
            const routeId = item.routeId || '';
            groupKey = `${dateKey}_${vesselName}_${routeId}`;
          } else {
            // 001模式：同一天 + 船名 + 航次 + 船公司（去掉船型，因为001数据中有时候会漏掉船型数据）
            const dateKey = formatDateKey(item.date);
            vesselName = getVesselName(item.vessel || '');
            voyageNumber = getVoyageNumber(item.vessel || '');
            carrier = item.carrier || '';
            groupKey = `${dateKey}_${vesselName}_${voyageNumber}_${carrier}`;
          }
          
          if (!grouped[groupKey]) {
            if (item.mode === MODE_365) {
              grouped[groupKey] = {
                vessel: item.vessel || '',
                vesselName: item.vesselName || getVesselName(item.vessel || ''),
                shipType: item.shipType || '',
                carriers: [],
                carriersSet: new Set(),
                ports: [],
                portsSet: new Set(),
                portDetails: [], // 365模式也需要portDetails数组（用于统一处理）
                weekday: item.weekday,
                voyageDays: item.voyageDays,
                originTerminal: item.originTerminal,
                destTerminal: item.destTerminal,
                year: item.year,
                routePath: item.routePath,
                routeId: item.routeId || '',
                mode: item.mode,
                date: item.date
              };
            } else {
              // 001模式：存储每个港口的详细信息，合并时取资料最全的
              grouped[groupKey] = {
                vessel: item.vessel || '',
                vesselName: vesselName,
                voyageNumber: voyageNumber,
                shipType: item.shipType || '', // 合并时取最全的
                carrier: carrier,
                ports: [], // 存储港口名称数组
                portsSet: new Set(), // 用于去重
                portDetails: [], // 存储每个港口的详细信息 [{port, weekday, voyageDays, originTerminal, destTerminal}]
                weekday: item.weekday || '', // 合并时取最全的
                voyageDays: item.voyageDays || '', // 合并时取最全的
                originTerminal: item.originTerminal || '', // 合并时取最全的
                destTerminal: item.destTerminal || '', // 合并时取最全的
                year: item.year || '',
                routePath: item.routePath || '',
                mode: item.mode,
                date: item.date
              };
            }
          }
          
          // 001模式：合并时补全资料（取最全的）
          if (item.mode === MODE_001) {
            const group = grouped[groupKey];
            // 补全基础字段（取最全的，优先保留非空值）
            if (!group.vessel && item.vessel) group.vessel = item.vessel;
            if (!group.shipType && item.shipType) group.shipType = item.shipType;
            if (!group.weekday && item.weekday) group.weekday = item.weekday;
            if (!group.voyageDays && item.voyageDays) group.voyageDays = item.voyageDays;
            if (!group.originTerminal && item.originTerminal) group.originTerminal = item.originTerminal;
            if (!group.destTerminal && item.destTerminal) group.destTerminal = item.destTerminal;
            if (!group.year && item.year) group.year = item.year;
            if (!group.routePath && item.routePath) group.routePath = item.routePath;
          }
          
          // 添加港口（去重）并存储详细信息
          if (item.port) {
            const portKey = String(item.port).trim();
            if (!grouped[groupKey].portsSet.has(portKey)) {
              grouped[groupKey].ports.push(portKey);
              grouped[groupKey].portsSet.add(portKey);
              // 存储该港口的详细信息
              grouped[groupKey].portDetails.push({
                port: portKey,
                weekday: item.weekday || '',
                voyageDays: item.voyageDays || '',
                originTerminal: item.originTerminal || '',
                destTerminal: item.destTerminal || ''
              });
            } else {
              // 如果港口已存在，更新详细信息（保留非空值，补全资料）
              const existingDetail = grouped[groupKey].portDetails.find(d => d.port === portKey);
              if (existingDetail) {
                if (!existingDetail.weekday && item.weekday) existingDetail.weekday = item.weekday;
                if (!existingDetail.voyageDays && item.voyageDays) existingDetail.voyageDays = item.voyageDays;
                if (!existingDetail.originTerminal && item.originTerminal) existingDetail.originTerminal = item.originTerminal;
                if (!existingDetail.destTerminal && item.destTerminal) existingDetail.destTerminal = item.destTerminal;
              }
            }
          }
          
          // 365模式：合并时补全资料（取最全的）
          if (item.mode === MODE_365) {
            const group = grouped[groupKey];
            // 补全基础字段（取最全的，优先保留非空值）
            if (!group.vessel && item.vessel) group.vessel = item.vessel;
            if (!group.shipType && item.shipType) group.shipType = item.shipType;
            if (!group.weekday && item.weekday) group.weekday = item.weekday;
            if (!group.voyageDays && item.voyageDays) group.voyageDays = item.voyageDays;
            if (!group.originTerminal && item.originTerminal) group.originTerminal = item.originTerminal;
            if (!group.destTerminal && item.destTerminal) group.destTerminal = item.destTerminal;
            if (!group.year && item.year) group.year = item.year;
            if (!group.routePath && item.routePath) group.routePath = item.routePath;
          }
          
          // 365模式：收集共舱船公司
          if (item.mode === MODE_365 && item.carrier && !grouped[groupKey].carriersSet.has(item.carrier)) {
            grouped[groupKey].carriers.push(item.carrier);
            grouped[groupKey].carriersSet.add(item.carrier);
          }
          // 365模式：记录航线路径（优先保留已有的非空路径）
          if (item.mode === MODE_365 && !grouped[groupKey].routePath && item.routePath) {
            grouped[groupKey].routePath = item.routePath;
          }
        });
        
        // 转换为数组，合并多个港口的标记为需要合并显示
        return Object.values(grouped).map(group => {
          // 365模式：选择最长的共舱船公司
          if (group.mode === MODE_365) {
            const longestCarrier = group.carriers.reduce((longest, current) => {
              return current.length > longest.length ? current : longest;
            }, group.carriers[0] || '');
            group.carrier = longestCarrier;
          }
          
          if (group.ports.length > 1) {
            return {
              ...group,
              ports: group.ports,
              portsText: group.ports.join('、'),
              portDetails: group.portDetails || [], // 确保包含portDetails
              isMerged: true
            };
          } else {
            return {
              ...group,
              port: group.ports[0] || '',
              portDetails: group.portDetails || [], // 确保包含portDetails
              isMerged: false
            };
          }
        });
      }

      /**
       * 渲染日历视图
       * 根据筛选条件显示船期日历，支持4周显示
       */
      function renderCalendar() {
        const hasFilters = state.selectedOriginPorts.length > 0 || 
                          state.selectedDestPorts.length > 0 || 
                          state.selectedCarriers.length > 0;

        if (!hasFilters) {
          dom.calendarContainer.classList.add('hidden');
          dom.emptyMessage.classList.remove('hidden');
          return;
        }

        dom.calendarContainer.classList.remove('hidden');
        dom.emptyMessage.classList.add('hidden');

        // 获取当前数据
        const currentData = state.currentMode === MODE_001 ? state.data001 : state.data365;
        if (!currentData || currentData.length === 0) {
          dom.calendarContainer.classList.add('hidden');
          dom.emptyMessage.textContent = `请先加载 ${state.currentMode} 文件`;
          dom.emptyMessage.classList.remove('hidden');
          return;
        }

        // 筛选数据
        const filteredData = filterDataBySelection(currentData);

        // 按日期分组
        const dataByDate = groupDataByDate(filteredData);

        // 检测是否为手机端（屏幕宽度 <= 768px）
        const isMobile = window.innerWidth <= 768;
        
        // 清空日历容器（会自动清理动态元素的事件监听器）
        dom.calendarBody.innerHTML = '';

        // 使用事件委托处理日历项的点击事件（优化性能，避免为每个元素单独添加监听器）
        if (!dom.calendarBody.dataset.delegated) {
          const handleScheduleItemClick = (e) => {
            const itemEl = e.target.closest('.schedule-item');
            if (!itemEl) return;
            
            e.stopPropagation();
            const clickedCarrier = itemEl.dataset.carrier;
            if (!clickedCarrier) return;
            
            // 切换高亮状态
            const isHighlighted = itemEl.classList.contains('highlighted');
            
            // 使用缓存的查询结果（从 calendarBody 查询，避免全局查询）
            // 由于使用事件委托，我们可以直接从容器查询，性能更好
            const scheduleItems = dom.calendarBody.querySelectorAll('.schedule-item');
            
            // 清除所有高亮
            scheduleItems.forEach(el => {
              el.classList.remove('highlighted');
            });
            
            // 如果不是已高亮状态，则高亮同航线
            if (!isHighlighted) {
              scheduleItems.forEach(el => {
                if (el.dataset.carrier === clickedCarrier) {
                  el.classList.add('highlighted');
                }
              });
            }
          };
          
          eventListeners.add(dom.calendarBody, 'click', handleScheduleItemClick);
          dom.calendarBody.dataset.delegated = 'true';
        }

        // 手机端：按日显示（显示未来28天的数据）
        if (isMobile) {
          renderMobileCalendar(dataByDate);
          return; // 手机端渲染完成，直接返回
        }

        // 桌面端：按周显示（显示当前周+未来3周，共4周，周日开始）
        renderDesktopCalendar(dataByDate);
      }

      /**
       * 渲染手机端日历（按日显示，未来28天）
       * @param {Object} dataByDate - 按日期分组的数据
       */
      function renderMobileCalendar(dataByDate) {
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const days = [];
        
        // 生成未来28天的日期
        for (let d = 0; d < 28; d++) {
          const date = new Date(today);
          date.setDate(today.getDate() + d);
          days.push(date);
        }
        
        // 按日期渲染
        days.forEach(date => {
          const dateKey = formatDateKey(date);
          const dayData = dataByDate[dateKey] || [];
          
          // 创建日期卡片
          const dayCard = document.createElement('div');
          dayCard.className = 'calendar-day';
          if (isToday(date)) {
            dayCard.classList.add('today');
          }
          
          // 日期标签
          const dateLabel = document.createElement('div');
          dateLabel.style.cssText = 'font-weight: 600; margin-bottom: 16px; color: #495057; font-size: 16px; padding-bottom: 12px; border-bottom: 2px solid #e9ecef;';
          const month = date.getMonth() + 1;
          const day = date.getDate();
          const weekdays = ['周日', '周一', '周二', '周三', '周四', '周五', '周六'];
          const weekday = weekdays[date.getDay()];
          dateLabel.textContent = `${month}月${day}日 ${weekday}`;
          if (isToday(date)) {
            dateLabel.style.color = '#3E62AD';
            dateLabel.style.borderBottomColor = '#3E62AD';
          }
          dayCard.appendChild(dateLabel);
          
          // 去重处理（统一使用 vendor 中的标准去重）
          let uniqueData = typeof deduplicateSailingItems === 'function'
            ? deduplicateSailingItems(dayData)
            : deduplicateItems(dayData);
          
          // 合并同船名航次船型的港口
          const mergedData = mergeItemsByVessel(uniqueData);
          
          // 显示所有项目（手机端不限制数量）
          mergedData.forEach(item => {
            const itemEl = document.createElement('div');
            itemEl.className = 'schedule-item';
            
            // 使用公共函数渲染（统一处理 001/365 模式）
            renderScheduleItem(itemEl, item, state.currentMode);
            
            dayCard.appendChild(itemEl);
          });
          
          // 如果没有数据，显示提示
          if (mergedData.length === 0) {
            const emptyMsg = document.createElement('div');
            emptyMsg.style.cssText = 'text-align: center; color: #6c757d; font-size: 13px; padding: 20px;';
            emptyMsg.textContent = '当日无船期';
            dayCard.appendChild(emptyMsg);
          }
          
          dom.calendarBody.appendChild(dayCard);
        });
      }

      /**
       * 渲染桌面端日历（按周显示，4周）
       * @param {Object} dataByDate - 按日期分组的数据
       */
      function renderDesktopCalendar(dataByDate) {
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const weeks = [];
        
        // 找到本周日（一周的开始）
        const currentSunday = new Date(today);
        const dayOfWeek = today.getDay(); // 0=周日, 1=周一, ..., 6=周六
        const diff = -dayOfWeek; // 如果是周日，diff=0；如果是周一，diff=-1，以此类推
        currentSunday.setDate(today.getDate() + diff);
        
        for (let w = 0; w < CALENDAR_WEEKS; w++) {
          const weekStart = new Date(currentSunday);
          weekStart.setDate(currentSunday.getDate() + w * DAYS_PER_WEEK);
          weeks.push(weekStart);
        }

        weeks.forEach(weekStart => {
          const weekRow = document.createElement('div');
          weekRow.className = 'calendar-week';

          // 获取周数（用于显示在日期标签中）
          const weekNumber = getWeekNumber(weekStart);

          // 生成一周的日期（从周日开始）
          for (let d = 0; d < DAYS_PER_WEEK; d++) {
            const date = new Date(weekStart);
            date.setDate(weekStart.getDate() + d);
            const dateKey = formatDateKey(date);
            const dayData = dataByDate[dateKey] || [];

            const dayCell = document.createElement('div');
            dayCell.className = 'calendar-day';
            if (isToday(date)) {
              dayCell.classList.add('today');
            }

            // 日期标签容器（包含日期文本和箭头按钮）
            const dateLabelContainer = document.createElement('div');
            dateLabelContainer.style.cssText = 'display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px; padding-bottom: 8px; border-bottom: 2px solid #e9ecef;';
            
            // 日期文本（包含周数）
            const dateLabel = document.createElement('div');
            dateLabel.style.cssText = 'font-weight: 600; color: #495057; font-size: 14px; flex: 1;';
            const month = date.getMonth() + 1;
            const day = date.getDate();
            const weekdays = ['周日', '周一', '周二', '周三', '周四', '周五', '周六'];
            const weekday = weekdays[date.getDay()];
            // 格式：12/21 周日 | 第52周
            dateLabel.textContent = `${month}/${day} ${weekday} | 第${weekNumber}周`;
            if (isToday(date)) {
              dateLabel.style.color = '#3E62AD';
              dateLabelContainer.style.borderBottomColor = '#3E62AD';
            }
            dateLabelContainer.appendChild(dateLabel);
            
            // 箭头按钮容器
            const arrowContainer = document.createElement('div');
            arrowContainer.style.cssText = 'display: flex; flex-direction: column; gap: 2px; margin-left: 8px;';
            
            // 上箭头按钮
            const upArrow = document.createElement('button');
            upArrow.className = 'day-pagination-arrow day-pagination-arrow-up';
            upArrow.innerHTML = '▲';
            upArrow.style.cssText = 'width: 20px; height: 16px; border: none; background: #f8f9fa; color: #495057; cursor: pointer; border-radius: 3px; font-size: 10px; padding: 0; display: flex; align-items: center; justify-content: center; transition: all 0.2s ease;';
            upArrow.disabled = true;
            upArrow.title = '上一页';
            
            // 下箭头按钮
            const downArrow = document.createElement('button');
            downArrow.className = 'day-pagination-arrow day-pagination-arrow-down';
            downArrow.innerHTML = '▼';
            downArrow.style.cssText = 'width: 20px; height: 16px; border: none; background: #f8f9fa; color: #495057; cursor: pointer; border-radius: 3px; font-size: 10px; padding: 0; display: flex; align-items: center; justify-content: center; transition: all 0.2s ease;';
            downArrow.disabled = true;
            downArrow.title = '下一页';
            
            // 悬停效果
            const setupArrowHover = (arrow) => {
              arrow.addEventListener('mouseenter', () => {
                if (!arrow.disabled) {
                  arrow.style.background = '#667eea';
                  arrow.style.color = 'white';
                }
              });
              arrow.addEventListener('mouseleave', () => {
                if (!arrow.disabled) {
                  arrow.style.background = '#f8f9fa';
                  arrow.style.color = '#495057';
                }
              });
            };
            setupArrowHover(upArrow);
            setupArrowHover(downArrow);
            
            arrowContainer.appendChild(upArrow);
            arrowContainer.appendChild(downArrow);
            dateLabelContainer.appendChild(arrowContainer);
            dayCell.appendChild(dateLabelContainer);

            // 去重处理（统一使用 vendor 中的标准去重）
            let uniqueData = typeof deduplicateSailingItems === 'function'
              ? deduplicateSailingItems(dayData)
              : deduplicateItems(dayData);
            
            // 合并同一天、同船名、同航次、同船型的不同港口（使用提取的函数）
            const mergedData = mergeItemsByVessel(uniqueData);
            
            // 存储该日期列的所有数据（用于翻页）
            dayCell.dataset.dateKey = dateKey;
            dayCell.dataset.allItems = JSON.stringify(mergedData);
            
            // 计算总页数
            const totalPages = Math.ceil(mergedData.length / MAX_ITEMS_PER_DAY);
            let currentPage = 0; // 从第0页开始
            
            // 存储翻页状态到dayCell
            dayCell.dataset.currentPage = '0';
            dayCell.dataset.totalPages = totalPages.toString();
            
            // 渲染当前页的4条记录
            const renderPage = (pageIndex) => {
              // 清除现有内容（保留日期标签）
              const existingItems = dayCell.querySelectorAll('.schedule-item, .more-items-indicator');
              existingItems.forEach(el => el.remove());
              
              const startIndex = pageIndex * MAX_ITEMS_PER_DAY;
              const endIndex = startIndex + MAX_ITEMS_PER_DAY;
              const displayItems = mergedData.slice(startIndex, endIndex);
            
            displayItems.forEach(item => {
              const itemEl = document.createElement('div');
              itemEl.className = 'schedule-item';
              
              // 使用公共函数渲染（统一处理 001/365 模式）
              renderScheduleItem(itemEl, item, state.currentMode);
              
              dayCell.appendChild(itemEl);
            });

              // 更新箭头状态
              upArrow.disabled = (pageIndex === 0);
              downArrow.disabled = (pageIndex >= totalPages - 1);
                
              if (upArrow.disabled) {
                upArrow.style.opacity = '0.3';
                upArrow.style.cursor = 'not-allowed';
                } else {
                upArrow.style.opacity = '1';
                upArrow.style.cursor = 'pointer';
              }
              
              if (downArrow.disabled) {
                downArrow.style.opacity = '0.3';
                downArrow.style.cursor = 'not-allowed';
              } else {
                downArrow.style.opacity = '1';
                downArrow.style.cursor = 'pointer';
              }
            };
            
            // 初始渲染第0页
            renderPage(0);
              
            // 上箭头点击事件
            upArrow.addEventListener('click', () => {
              if (upArrow.disabled) return;
              currentPage = Math.max(0, currentPage - 1);
              dayCell.dataset.currentPage = currentPage.toString();
              renderPage(currentPage);
            });
            
            // 下箭头点击事件
            downArrow.addEventListener('click', () => {
              if (downArrow.disabled) return;
              currentPage = Math.min(totalPages - 1, currentPage + 1);
              dayCell.dataset.currentPage = currentPage.toString();
              renderPage(currentPage);
            });

            // 如果超过4条，不再显示"还有X条"提示（因为可以通过箭头翻页查看所有记录）

            weekRow.appendChild(dayCell);
          }

          dom.calendarBody.appendChild(weekRow);
        });
      }

      /**
       * 渲染月度汇总表格
       * 显示各航线按月汇总的靠泊情况
       */
      function renderMonthlySummary() {
        const hasFilters = state.selectedOriginPorts.length > 0 || 
                          state.selectedDestPorts.length > 0 || 
                          state.selectedCarriers.length > 0;

        if (!hasFilters) {
          dom.monthlySummaryContainer.classList.add('hidden');
          dom.monthlySummaryEmptyMessage.style.display = 'block';
          return;
        }

        // 获取当前数据
        const currentData = state.currentMode === MODE_001 ? state.data001 : state.data365;
        if (!currentData || currentData.length === 0) {
          dom.monthlySummaryContainer.classList.add('hidden');
          dom.monthlySummaryEmptyMessage.style.display = 'block';
          dom.monthlySummaryEmptyMessage.textContent = `请先加载 ${state.currentMode} 文件`;
          return;
        }

        // 筛选数据（使用与日历相同的筛选逻辑）
        const filteredData = filterDataBySelection(currentData);

        if (filteredData.length === 0) {
          dom.monthlySummaryContainer.classList.add('hidden');
          dom.monthlySummaryEmptyMessage.style.display = 'block';
          return;
        }

        dom.monthlySummaryContainer.classList.remove('hidden');
        dom.monthlySummaryEmptyMessage.style.display = 'none';

        // 去重处理（使用与日历相同的去重规则）
        let uniqueData = typeof deduplicateSailingItems === 'function'
          ? deduplicateSailingItems(filteredData)
          : deduplicateItems(filteredData);

        // 合并同船名航次船型的数据（使用与日历相同的合并规则）
        const mergeByVessel = (items) => {
          const grouped = {};
          
          items.forEach(item => {
            let groupKey;
            let vesselName, voyageNumber, shipType, carrier;
            
            // 365模式：同一天 + 同船名(Q列) + 同航线ID(G列)
            if (item.mode === '365') {
              const dateKey = formatDateKey(item.date);
              vesselName = item.vesselName || getVesselName(item.vessel || '');
              const routeId = item.routeId || '';
              groupKey = `${dateKey}_${vesselName}_${routeId}`;
            } else {
              // 001模式：同一天 + 船名 + 航次 + 船公司（去掉船型，因为001数据中有时候会漏掉船型数据）
              const dateKey = formatDateKey(item.date);
              vesselName = getVesselName(item.vessel || '');
              voyageNumber = getVoyageNumber(item.vessel || '');
              carrier = item.carrier || '';
              groupKey = `${dateKey}_${vesselName}_${voyageNumber}_${carrier}`;
            }
            
            if (!grouped[groupKey]) {
              if (item.mode === MODE_365) {
                grouped[groupKey] = {
                  vessel: item.vessel || '',
                  vesselName: item.vesselName || getVesselName(item.vessel || ''),
                  shipType: item.shipType || '',
                  carriers: [],
                  carriersSet: new Set(),
                  ports: [],
                  portsSet: new Set(),
                  portDetails: [], // 365模式也需要portDetails数组（用于统一处理）
                  routeId: item.routeId || '',
                  mode: item.mode,
                  date: item.date
                };
              } else {
                // 001模式：存储每个港口的详细信息，合并时取资料最全的
                grouped[groupKey] = {
                  vessel: item.vessel || '',
                  vesselName: vesselName,
                  voyageNumber: voyageNumber,
                  shipType: item.shipType || '', // 合并时取最全的
                  carrier: carrier,
                  ports: [],
                  portsSet: new Set(),
                  portDetails: [], // 存储每个港口的详细信息
                  weekday: item.weekday || '', // 合并时取最全的
                  voyageDays: item.voyageDays || '', // 合并时取最全的
                  originTerminal: item.originTerminal || '', // 合并时取最全的
                  destTerminal: item.destTerminal || '', // 合并时取最全的
                  year: item.year || '',
                  routePath: item.routePath || '',
                  mode: item.mode,
                  date: item.date
                };
              }
            }
            
            // 001模式：合并时补全资料（取最全的）
            if (item.mode === MODE_001) {
              const group = grouped[groupKey];
              // 补全基础字段（取最全的，优先保留非空值）
              if (!group.vessel && item.vessel) group.vessel = item.vessel;
              if (!group.shipType && item.shipType) group.shipType = item.shipType;
              if (!group.weekday && item.weekday) group.weekday = item.weekday;
              if (!group.voyageDays && item.voyageDays) group.voyageDays = item.voyageDays;
              if (!group.originTerminal && item.originTerminal) group.originTerminal = item.originTerminal;
              if (!group.destTerminal && item.destTerminal) group.destTerminal = item.destTerminal;
              if (!group.year && item.year) group.year = item.year;
              if (!group.routePath && item.routePath) group.routePath = item.routePath;
            }
            
            // 添加港口（去重）并存储详细信息
            if (item.port) {
              const portKey = String(item.port).trim();
              if (!grouped[groupKey].portsSet.has(portKey)) {
                grouped[groupKey].ports.push(portKey);
                grouped[groupKey].portsSet.add(portKey);
                // 存储该港口的详细信息
                grouped[groupKey].portDetails.push({
                  port: portKey,
                  weekday: item.weekday || '',
                  voyageDays: item.voyageDays || '',
                  originTerminal: item.originTerminal || '',
                  destTerminal: item.destTerminal || ''
                });
              } else {
                // 如果港口已存在，更新详细信息（保留非空值，补全资料）
                const existingDetail = grouped[groupKey].portDetails.find(d => d.port === portKey);
                if (existingDetail) {
                  if (!existingDetail.weekday && item.weekday) existingDetail.weekday = item.weekday;
                  if (!existingDetail.voyageDays && item.voyageDays) existingDetail.voyageDays = item.voyageDays;
                  if (!existingDetail.originTerminal && item.originTerminal) existingDetail.originTerminal = item.originTerminal;
                  if (!existingDetail.destTerminal && item.destTerminal) existingDetail.destTerminal = item.destTerminal;
                }
              }
            }
            
            // 365模式：合并时补全资料（取最全的）
            if (item.mode === MODE_365) {
              const group = grouped[groupKey];
              // 补全基础字段（取最全的，优先保留非空值）
              if (!group.vessel && item.vessel) group.vessel = item.vessel;
              if (!group.shipType && item.shipType) group.shipType = item.shipType;
              if (!group.weekday && item.weekday) group.weekday = item.weekday;
              if (!group.voyageDays && item.voyageDays) group.voyageDays = item.voyageDays;
              if (!group.originTerminal && item.originTerminal) group.originTerminal = item.originTerminal;
              if (!group.destTerminal && item.destTerminal) group.destTerminal = item.destTerminal;
              if (!group.year && item.year) group.year = item.year;
              if (!group.routePath && item.routePath) group.routePath = item.routePath;
            }
            
            // 365模式：收集共舱船公司
            if (item.mode === MODE_365 && item.carrier && !grouped[groupKey].carriersSet.has(item.carrier)) {
              grouped[groupKey].carriers.push(item.carrier);
              grouped[groupKey].carriersSet.add(item.carrier);
            }
            // 365模式：记录航线路径（优先保留已有的非空路径）
            if (item.mode === MODE_365 && !grouped[groupKey].routePath && item.routePath) {
              grouped[groupKey].routePath = item.routePath;
            }
          });
          
          return Object.values(grouped).map(group => {
            // 365模式：选择最长的共舱船公司
            if (group.mode === MODE_365) {
              const longestCarrier = group.carriers.reduce((longest, current) => {
                return current.length > longest.length ? current : longest;
              }, group.carriers[0] || '');
              group.carrier = longestCarrier;
            }
            
            if (group.ports.length > 1) {
              return {
                ...group,
                ports: group.ports,
                portsText: group.ports.join('、'),
                portDetails: group.portDetails || [], // 确保包含portDetails
                isMerged: true
              };
            } else {
              return {
                ...group,
                port: group.ports[0] || '',
                portDetails: group.portDetails || [], // 确保包含portDetails
                isMerged: false
              };
            }
          });
        };

        const mergedData = mergeByVessel(uniqueData);

        // 定义航线：使用航线ID作为分组键
        const getRouteKey = (item) => {
          // 使用航线ID作为分组键（001模式：C列，365模式：G列）
          // 如果航线ID为空或无效，使用共舱船公司作为分组键（作为fallback）
          if (item.routeId && item.routeId.trim()) {
            return item.routeId.trim();
          }
          // 如果没有有效的航线ID，使用共舱船公司作为分组键
          return item.carrier || '未知';
        };

        // 按航线ID分组，并收集每个航线ID下的所有共舱船公司
        const routesMap = new Map(); // key: routeId, value: { items: [], carriers: Set }
        mergedData.forEach(item => {
          const routeKey = getRouteKey(item);
          if (!routesMap.has(routeKey)) {
            routesMap.set(routeKey, {
              items: [],
              carriers: new Set()
            });
          }
          const routeData = routesMap.get(routeKey);
          routeData.items.push(item);
          if (item.carrier) {
            routeData.carriers.add(item.carrier);
          }
        });

        // 获取所有月份（从数据中提取）
        const monthsSet = new Set();
        mergedData.forEach(item => {
          const year = item.date.getFullYear();
          const month = String(item.date.getMonth() + 1).padStart(2, '0');
          const monthKey = `${year}${month}`;
          monthsSet.add(monthKey);
        });

        const months = Array.from(monthsSet).sort();

        // 构建表格
        let tableHTML = '<table class="monthly-summary-table"><thead><tr>';
        tableHTML += '<th>航线</th>';
        months.forEach(month => {
          const year = month.substring(0, 4);
          const monthNum = month.substring(4);
          tableHTML += `<th>${year}${monthNum}</th>`;
        });
        tableHTML += '</tr></thead><tbody>';

        // 按航线ID排序
        const sortedRoutes = Array.from(routesMap.entries()).sort((a, b) => {
          // 先按航线ID排序（数字优先，然后字母）
          const aKey = a[0];
          const bKey = b[0];
          const aNum = parseInt(aKey);
          const bNum = parseInt(bKey);
          if (!isNaN(aNum) && !isNaN(bNum)) {
            return aNum - bNum;
          }
          if (!isNaN(aNum)) return -1;
          if (!isNaN(bNum)) return 1;
          return aKey.localeCompare(bKey, 'zh-Hans-CN');
        });

        // 统计每个月的总船次（用于总计行）
        const monthlyTotals = new Map();
        months.forEach(month => {
          monthlyTotals.set(month, 0);
        });

        sortedRoutes.forEach(([routeKey, routeData]) => {
          const items = routeData.items;
          // 选择该航线ID下共舱船公司名字最长的作为显示名称
          const carriers = Array.from(routeData.carriers);
          const longestCarrier = carriers.reduce((longest, current) => {
            return current.length > longest.length ? current : longest;
          }, carriers[0] || '未知');
          
          tableHTML += '<tr>';
          const routePathRaw = items.find(item => item.routePath)?.routePath || '';
          const routePath = normalizeRoutePath(routePathRaw);
          const routePathAttr = routePath ? ` data-route-path="${escapeAttr(routePath)}"` : '';
          
          // 判断当前模式
          const is365Mode = state.currentMode === MODE_365;
          
          // 判断routeKey是否是有效的航线ID（数字或字母数字组合）
          const isValidRouteId = routeKey && routeKey !== '未知' && /^[0-9A-Za-z\-_]+$/.test(routeKey) && /[0-9A-Za-z]/.test(routeKey);
          
          // 显示格式：
          // 365模式：只显示共舱船公司（最长的），不显示航线ID
          // 001模式：如果有有效的航线ID，显示"航线ID - 共舱船公司（最长的）"，否则只显示共舱船公司
          const displayText = is365Mode
            ? longestCarrier
            : (isValidRouteId ? `${routeKey} - ${longestCarrier}` : longestCarrier);
          tableHTML += `<td class="route-cell"${routePathAttr}>${escapeHtml(displayText)}</td>`;

          // 按月份填充数据
          months.forEach(month => {
            const year = parseInt(month.substring(0, 4));
            const monthNum = parseInt(month.substring(4)) - 1; // JavaScript月份从0开始

            // 筛选该月份的数据
            const monthItems = items.filter(item => {
              const itemYear = item.date.getFullYear();
              const itemMonth = item.date.getMonth();
              return itemYear === year && itemMonth === monthNum;
            });

            if (monthItems.length === 0) {
              tableHTML += '<td></td>';
            } else {
              // 按日期排序
              monthItems.sort((a, b) => a.date.getTime() - b.date.getTime());

              // 统计船次
              monthlyTotals.set(month, monthlyTotals.get(month) + monthItems.length);

              // 构建显示内容：船名航次(开航时间)
              const vesselInfoItems = monthItems.map(item => {
                const vesselText = item.vessel || '';
                const dateStr = formatDateForSummary(item.date);
                return `${vesselText}(${dateStr})`;
              });

              tableHTML += `<td><div class="vessel-info">`;
              vesselInfoItems.forEach(info => {
                tableHTML += `<div class="vessel-info-item">${info}</div>`;
              });
              tableHTML += `</div></td>`;
            }
          });

          tableHTML += '</tr>';
        });

        // 添加总计行
        tableHTML += '</tbody><tfoot><tr>';
        tableHTML += '<td>合计</td>';
        months.forEach(month => {
          const total = monthlyTotals.get(month) || 0;
          tableHTML += `<td style="text-align: center; font-weight: 600; color: #667eea;">${total} 艘次</td>`;
        });
        tableHTML += '</tr></tfoot></table>';
        dom.monthlySummaryTable.innerHTML = tableHTML;

        // 绑定航线路径悬停提示
        bindMonthlyRouteTooltips();
      }

      /**
       * 格式化日期用于汇总表格显示
       * @param {Date} date - 日期对象
       * @returns {string} 格式化后的日期字符串（MM/DD）
       */
      function formatDateForSummary(date) {
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${month}/${day}`;
      }

      /**
       * 转义HTML字符串，避免标题中的特殊字符破坏结构
       * @param {string} str - 待转义的字符串
       * @returns {string} 转义后的字符串
       */
      function escapeHtml(str) {
        if (typeof str !== 'string') return '';
        return str
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;');
      }

      /**
       * 转义用于 HTML 属性的字符串（包含换行处理）
       * @param {string} str - 原始字符串
       * @returns {string} 转义后的字符串
       */
      function escapeAttr(str) {
        if (typeof str !== 'string') return '';
        return escapeHtml(str).replace(/\r?\n/g, '&#10;');
      }

      /**
       * 规范化航线路径文本：去除重复空白、合并重复行
       * @param {string} str
       * @returns {string}
       */
      function normalizeRoutePath(str) {
        if (typeof str !== 'string') return '';
        const lines = str
          .split(/\r?\n/)
          .map(s => s.trim())
          .filter(Boolean);
        const uniq = [];
        lines.forEach(line => {
          if (!uniq.includes(line)) {
            uniq.push(line);
          }
        });
        return uniq.join('\n');
      }

      /**
       * 创建日历项的悬停提示事件处理器
       * @param {HTMLElement} itemEl - 日历项元素
       * @param {Object} item - 数据项
       * @returns {void}
       */
      function attachTooltipToItem(itemEl, item) {
        const tooltip = createTooltip(item);
        if (!tooltip) return;
        
        document.body.appendChild(tooltip);
        
        let tooltipTimeout;
        const handleMouseEnter = (e) => {
          clearTimeout(tooltipTimeout);
          tooltip.style.display = 'block';
          positionTooltip(tooltip, itemEl);
        };
        const handleMouseLeave = () => {
          tooltipTimeout = setTimeout(() => {
            tooltip.style.display = 'none';
          }, 100);
        };
        const handleMouseMove = (e) => {
          clearTimeout(tooltipTimeout);
          if (tooltip.style.display === 'block') {
            positionTooltip(tooltip, itemEl);
          }
        };
        
        itemEl.addEventListener('mouseenter', handleMouseEnter);
        itemEl.addEventListener('mouseleave', handleMouseLeave);
        itemEl.addEventListener('mousemove', handleMouseMove);
      }
      
      /**
       * 渲染日历项（抽取 001/365 公共逻辑）
       * @param {HTMLElement} itemEl - 日历项元素
       * @param {Object} item - 数据项
       * @param {string} currentMode - 当前模式（'001' 或 '365'）
       */
      function renderScheduleItem(itemEl, item, currentMode) {
        // 准备数据
        const vesselText = item.vessel || '';
        const shipTypeText = item.shipType ? ` ${item.shipType}TEU` : '';
        const secondLine = vesselText + shipTypeText;
        
        // 001 模式和 365 模式都显示2行：
        // 第一行：共舱船公司
        // 第二行：船名/航次 + 船型（不显示港口，港口信息移到悬停中）
        // 构建 HTML
        itemEl.innerHTML = `
          <div class="carrier" style="font-weight: 600; margin-bottom: 6px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 13px; color: #1f2d3d;">${item.carrier || ''}</div>
          <div class="vessel" style="color: #495057; font-size: 12px; line-height: 1.5; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${secondLine || ''}</div>
        `;
        
        // 存储航线信息用于点击高亮
        itemEl.dataset.carrier = item.carrier || '';
        
        // 始终显示 tooltip（因为港口信息在悬停中显示）
        attachTooltipToItem(itemEl, item);
      }
      

      // 提取船名（去除航次号）
      function getVesselName(vesselText) {
        if (!vesselText) return '';
        // 船名航次格式通常是 "船名/航次" 或 "船名 航次" 或 "船名航次"
        const parts = vesselText.split(/[\/\s]/);
        return parts[0] ? parts[0].trim() : '';
      }
      
      // 提取航次号
      function getVoyageNumber(vesselText) {
        if (!vesselText) return '';
        const parts = vesselText.split(/[\/\s]/);
        return parts.length > 1 ? parts[1].trim() : '';
      }

      // 去重函数：统一使用 vendor 中的标准实现
      function deduplicateItems(items) {
        if (typeof deduplicateSailingItems === 'function') {
          return deduplicateSailingItems(items);
        }
        // 如果公共函数未加载，返回原数组（不应该发生）
        debugWarn('deduplicateSailingItems 函数未找到，请确保 vendor/market-analysis-utils.js 已加载');
        return items || [];
      }

      // 工具函数：统一使用 vendor/date-utils.js 中的实现
      // 注意：直接使用保存的全局函数引用，避免作用域冲突导致无限递归
      // 使用已保存的 _originalFormatDateKey 引用
      function formatDateKey(date) {
        // 使用在脚本最开始保存的原始全局函数引用
        if (_originalFormatDateKey) {
          // 使用带分隔符的格式（YYYY-MM-DD），与原有逻辑保持一致
          return _originalFormatDateKey(date, 'YYYY-MM-DD');
        }
        // 降级实现（不应该发生，date-utils.js 应该已加载）
        if (!date) return '';
        let d;
        if (date instanceof Date) {
          d = date;
        } else if (typeof date === 'number' && isFinite(date)) {
          d = new Date(date);
        } else if (typeof date === 'string') {
          d = new Date(date);
        } else {
          d = new Date(date);
        }
        if (!d || isNaN(d.getTime())) return '';
        const year = d.getFullYear();
        const month = String(d.getMonth() + 1).padStart(2, '0');
        const day = String(d.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      }

      function isToday(date) {
        const today = new Date();
        return date.getFullYear() === today.getFullYear() &&
               date.getMonth() === today.getMonth() &&
               date.getDate() === today.getDate();
      }

      /**
       * 解析日期字符串为Date对象
       * @param {string} dateStr - 日期字符串（格式：yyyy/m/d 或 yyyy/mm/dd）
       * @returns {Date|null} - Date对象，如果解析失败则返回null
       */
      function parseDateString(dateStr) {
        if (!dateStr) return null;
        const parts = dateStr.split(/[\/\-]/);
        if (parts.length !== 3) return null;
        const year = parseInt(parts[0], 10);
        const month = parseInt(parts[1], 10) - 1; // 月份从0开始
        const day = parseInt(parts[2], 10);
        if (isNaN(year) || isNaN(month) || isNaN(day)) return null;
        const date = new Date(year, month, day);
        if (isNaN(date.getTime())) return null;
        return date;
      }
      
      /**
       * 根据日期从weekDefinitionMap中查找周数
       * @param {Date} date - 日期对象
       * @param {Object} weekDefinitionMap - 周别定义映射表
       * @returns {number|null} - 周数，如果找不到则返回null
       */
      function getWeekNumberFromDefinition(date, weekDefinitionMap) {
        if (!date || !weekDefinitionMap || Object.keys(weekDefinitionMap).length === 0) {
          return null;
        }
        
        // 遍历weekDefinitionMap，查找包含该日期的周别
        for (const [weekCode, weekDef] of Object.entries(weekDefinitionMap)) {
          if (!weekDef || !weekDef.sunday || !weekDef.saturday) {
            continue;
          }
          
          // 解析周别的开始和结束日期
          const startDate = parseDateString(weekDef.sunday);
          const endDate = parseDateString(weekDef.saturday);
          
          if (!startDate || !endDate) {
            continue;
          }
          
          // 比较日期（只比较年月日，忽略时分秒）
          const dateYear = date.getFullYear();
          const dateMonth = date.getMonth();
          const dateDay = date.getDate();
          const dateOnly = new Date(dateYear, dateMonth, dateDay);
          
          const startYear = startDate.getFullYear();
          const startMonth = startDate.getMonth();
          const startDay = startDate.getDate();
          const startOnly = new Date(startYear, startMonth, startDay);
          
          const endYear = endDate.getFullYear();
          const endMonth = endDate.getMonth();
          const endDay = endDate.getDate();
          const endOnly = new Date(endYear, endMonth, endDay);
          
          // 检查日期是否在范围内
          if (dateOnly >= startOnly && dateOnly <= endOnly) {
            // 提取周数（从weekCode中提取，格式：YYYYWW）
            const weekNo = parseInt(weekCode.substring(4), 10);
            if (!isNaN(weekNo)) {
              return weekNo;
            }
          }
        }
        
        return null;
      }
      
      /**
       * 获取周数（优先使用weekDefinitionMap，如果没有则使用计算方式）
       * @param {Date} date - 日期对象
       * @returns {number} - 周数（1-53）
       */
      function getWeekNumber(date) {
        // 优先使用weekDefinitionMap（如果已加载）
        if (state.weekDefinitionMap && Object.keys(state.weekDefinitionMap).length > 0) {
          const weekNo = getWeekNumberFromDefinition(date, state.weekDefinitionMap);
          if (weekNo !== null) {
            return weekNo;
          }
        }
        
        // 如果没有weekDefinitionMap或找不到，使用计算方式（从week-utils.js）
        if (typeof window.getWeekNumber === 'function') {
          return window.getWeekNumber(date);
        }
        
        // 最后的回退：返回1
        return 1;
      }
      
      // 与 001-04/365-04 保持一致：优先使用week表定义，如果没有则使用计算方式

      // 创建悬停提示框
      function createTooltip(item) {
        const lines = [];
        const is001Mode = item.mode === MODE_001;
        
        // 第一行：共舱船公司（完整显示，避免船期表中显示不全）
        if (item.carrier) {
          lines.push(`
            <div class="tooltip-grid-line">
              <span class="tooltip-label">共舱船公司：</span>
              <span class="tooltip-value" style="grid-column: 2 / -1;">${item.carrier}</span>
            </div>
          `);
        }
        
        // 001模式：显示所有目的港的详细信息
        if (is001Mode && item.portDetails && item.portDetails.length > 0) {
          item.portDetails.forEach((portDetail, index) => {
            // 目的港
            lines.push(`
              <div class="tooltip-grid-line">
                <span class="tooltip-label">目的港：</span>
                <span class="tooltip-value" style="grid-column: 2 / -1;">${portDetail.port || ''}</span>
              </div>
            `);
            
            // 标准开航日 + 标准航程
            let weekdayText = '';
            if (portDetail.weekday) {
              const weekdayStr = String(portDetail.weekday).trim();
              if (weekdayStr.includes('周')) {
                weekdayText = weekdayStr.replace(/周+/g, '周');
              } else {
                weekdayText = `周${weekdayStr}`;
              }
            }
            
            let voyageText = '';
            if (portDetail.voyageDays) {
              const voyageStr = String(portDetail.voyageDays).trim();
              voyageText = voyageStr.replace(/天+$/, '') + '天';
            }
            
            if (weekdayText || voyageText) {
              lines.push(`
                <div class="tooltip-grid-line">
                  <span class="tooltip-label">标准开航日：</span>
                  <span class="tooltip-value">${weekdayText}</span>
                  <span class="tooltip-label">标准航程：</span>
                  <span class="tooltip-value">${voyageText}</span>
                </div>
              `);
            }
            
            // 起运港码头 + 目的港码头
            if (portDetail.originTerminal || portDetail.destTerminal) {
              lines.push(`
                <div class="tooltip-grid-line">
                  <span class="tooltip-label">起运港码头：</span>
                  <span class="tooltip-value">${portDetail.originTerminal || ''}</span>
                  <span class="tooltip-label">目的港码头：</span>
                  <span class="tooltip-value">${portDetail.destTerminal || ''}</span>
                </div>
              `);
            }
            
            // 如果有多个港口，在最后一个港口后添加分隔线（除了最后一个）
            if (index < item.portDetails.length - 1) {
              lines.push(`<div style="height: 1px; background: #e9ecef; margin: 8px 0;"></div>`);
            }
          });
        } else if (is001Mode) {
          // 001模式降级：如果没有portDetails，使用旧的显示方式
          // 目的港
          const portText = item.isMerged ? item.portsText : (item.port || '');
          if (portText) {
            lines.push(`
              <div class="tooltip-grid-line">
                <span class="tooltip-label">目的港：</span>
                <span class="tooltip-value" style="grid-column: 2 / -1;">${portText}</span>
              </div>
            `);
          }
          
          // 标准开航日 + 标准航程
          if (item.weekday || item.voyageDays) {
            let weekdayText = '';
            if (item.weekday) {
              const weekdayStr = String(item.weekday).trim();
              if (weekdayStr.includes('周')) {
                weekdayText = weekdayStr.replace(/周+/g, '周');
              } else {
                weekdayText = `周${weekdayStr}`;
              }
            }
            
            let voyageText = '';
            if (item.voyageDays) {
              const voyageStr = String(item.voyageDays).trim();
              voyageText = voyageStr.replace(/天+$/, '') + '天';
            }
            
            lines.push(`
              <div class="tooltip-grid-line">
                <span class="tooltip-label">标准开航日：</span>
                <span class="tooltip-value">${weekdayText}</span>
                <span class="tooltip-label">标准航程：</span>
                <span class="tooltip-value">${voyageText}</span>
              </div>
            `);
          }
          
          // 起运港码头 + 目的港码头
          if (item.originTerminal || item.destTerminal) {
            lines.push(`
              <div class="tooltip-grid-line">
                <span class="tooltip-label">起运港码头：</span>
                <span class="tooltip-value">${item.originTerminal || ''}</span>
                <span class="tooltip-label">目的港码头：</span>
                <span class="tooltip-value">${item.destTerminal || ''}</span>
              </div>
            `);
          }
        } else {
          // 365模式：参照001模式，显示所有目的港的详细信息
          // 先显示船舶船型 + 建造年份
          if (item.shipType || item.year) {
            const shipTypeText = item.shipType ? `${item.shipType} TEU` : '';
            const yearText = item.year || '';
            lines.push(`
              <div class="tooltip-grid-line">
                <span class="tooltip-label">船舶船型：</span>
                <span class="tooltip-value">${shipTypeText}</span>
                <span class="tooltip-label">建造年份：</span>
                <span class="tooltip-value">${yearText}</span>
              </div>
            `);
          }
          
          // 然后显示航线路径
          if (item.routePath) {
            lines.push(`
              <div class="tooltip-grid-line">
                <span class="tooltip-label">航线路径：</span>
                <span class="tooltip-value tooltip-path" style="grid-column: 2 / -1;">${item.routePath}</span>
              </div>
            `);
          }
          
          // 最后显示所有目的港的详细信息（参照001模式）
          if (item.portDetails && item.portDetails.length > 0) {
            item.portDetails.forEach((portDetail, index) => {
              // 目的港
              lines.push(`
                <div class="tooltip-grid-line">
                  <span class="tooltip-label">目的港：</span>
                  <span class="tooltip-value" style="grid-column: 2 / -1;">${portDetail.port || ''}</span>
                </div>
              `);
              
              // 标准开航日 + 标准航程
              let weekdayText = '';
              if (portDetail.weekday) {
                const weekdayStr = String(portDetail.weekday).trim();
                if (weekdayStr.includes('周')) {
                  weekdayText = weekdayStr.replace(/周+/g, '周');
                } else {
                  weekdayText = `周${weekdayStr}`;
                }
              }
              
              let voyageText = '';
              if (portDetail.voyageDays) {
                const voyageStr = String(portDetail.voyageDays).trim();
                voyageText = voyageStr.replace(/天+$/, '') + '天';
              }
              
              if (weekdayText || voyageText) {
                lines.push(`
                  <div class="tooltip-grid-line">
                    <span class="tooltip-label">标准开航日：</span>
                    <span class="tooltip-value">${weekdayText}</span>
                    <span class="tooltip-label">标准航程：</span>
                    <span class="tooltip-value">${voyageText}</span>
                  </div>
                `);
              }
              
              // 起运港码头 + 目的港码头
              if (portDetail.originTerminal || portDetail.destTerminal) {
                lines.push(`
                  <div class="tooltip-grid-line">
                    <span class="tooltip-label">起运港码头：</span>
                    <span class="tooltip-value">${portDetail.originTerminal || ''}</span>
                    <span class="tooltip-label">目的港码头：</span>
                    <span class="tooltip-value">${portDetail.destTerminal || ''}</span>
                  </div>
                `);
              }
              
              // 如果有多个港口，在最后一个港口后添加分隔线（除了最后一个）
              if (index < item.portDetails.length - 1) {
                lines.push(`<div style="height: 1px; background: #e9ecef; margin: 8px 0;"></div>`);
              }
            });
          } else {
            // 365模式降级：如果没有portDetails，使用旧的显示方式
            // 标准开航日 + 标准航程
            if (item.weekday || item.voyageDays) {
              let weekdayText = '';
              if (item.weekday) {
                const weekdayStr = String(item.weekday).trim();
                if (weekdayStr.includes('周')) {
                  weekdayText = weekdayStr.replace(/周+/g, '周');
                } else {
                  weekdayText = `周${weekdayStr}`;
                }
              }
              
              let voyageText = '';
              if (item.voyageDays) {
                const voyageStr = String(item.voyageDays).trim();
                voyageText = voyageStr.replace(/天+$/, '') + '天';
              }
              
              lines.push(`
                <div class="tooltip-grid-line">
                  <span class="tooltip-label">标准开航日：</span>
                  <span class="tooltip-value">${weekdayText}</span>
                  <span class="tooltip-label">标准航程：</span>
                  <span class="tooltip-value">${voyageText}</span>
                </div>
              `);
            }
            
            // 起运港码头 + 目的港码头
            if (item.originTerminal || item.destTerminal) {
              lines.push(`
                <div class="tooltip-grid-line">
                  <span class="tooltip-label">起运港码头：</span>
                  <span class="tooltip-value">${item.originTerminal || ''}</span>
                  <span class="tooltip-label">目的港码头：</span>
                  <span class="tooltip-value">${item.destTerminal || ''}</span>
                </div>
              `);
            }
          }
        }
        
        // 如果没有内容，返回null
        if (lines.length === 0) {
          return null;
        }
        
        const tooltip = document.createElement('div');
        tooltip.className = 'tooltip';
        tooltip.style.display = 'none';
        tooltip.innerHTML = lines.join('');
        return tooltip;
      }

      // 定位提示框
      function positionTooltip(tooltip, target) {
        const rect = target.getBoundingClientRect();
        const tooltipRect = tooltip.getBoundingClientRect();
        
        // 默认显示在右侧
        let left = rect.right + 10;
        let top = rect.top;
        
        // 如果右侧空间不够，显示在左侧
        if (left + tooltipRect.width > window.innerWidth) {
          left = rect.left - tooltipRect.width - 10;
        }
        
        // 确保不超出左边界
        if (left < 10) {
          left = 10;
        }
        
        // 如果下方空间不够，向上调整
        if (top + tooltipRect.height > window.innerHeight) {
          top = window.innerHeight - tooltipRect.height - 10;
        }
        
        // 确保不超出上边界
        if (top < 10) {
          top = 10;
        }
        
        tooltip.style.left = left + 'px';
        tooltip.style.top = top + 'px';
      }


      // 页面加载完成后初始化
      // ==================== AI 分析模块 ====================
      
      // AI 提供商配置（使用统一的工具模块）
      const aiProviders = createAiProviders('sailing', {
        deepseek: { maxTokens: 8000 },
        kimi: { maxTokens: 8000 },
        qwen: { maxTokens: 8000 }
      });

      let activeAiProvider = 'deepseek';
      let setActiveAiPanelBound = null;

      /**
       * 初始化AI模块（使用统一的工具模块）
       */
      function initSailingAiModule() {
        // 先使用公共模板生成 AI 配置面板（必须在 initAiModule 之前）
        if (typeof window.generateAiConfigPanels === 'function') {
          const aiContainer = document.getElementById('aiConfigPanelsContainer');
          if (aiContainer) {
            aiContainer.innerHTML = window.generateAiConfigPanels();
          }
        }
        
        // 模板生成后，初始化 AI 模块（绑定标签页切换事件）
        if (typeof window.initAiModule === 'function') {
          setActiveAiPanelBound = window.initAiModule(aiProviders, eventListeners);
          // 设置默认激活的提供商
          if (setActiveAiPanelBound) {
            setActiveAiPanelBound(activeAiProvider);
          }
        }
        
        loadAiConfigsFromStorage(aiProviders);
        updateAiModuleVisibility();
      }

      /**
       * 设置活动的 AI 面板（使用统一工具模块）
       * @param {string} providerId - 提供商 ID
       */
      function setActiveAiPanel(providerId = 'deepseek') {
        if (setActiveAiPanelBound) {
          const result = setActiveAiPanelBound(providerId);
          if (result) {
            activeAiProvider = result;
          }
        } else {
          // 降级方案：如果 initAiModule 未调用，使用本地实现
          if (!aiProviders[providerId]) return;
          activeAiProvider = providerId;
          const aiTabButtons = document.querySelectorAll('.ai-tab-btn');
          const aiPanels = document.querySelectorAll('.ai-panel');
          aiTabButtons.forEach(btn => {
            if (btn.dataset.provider === providerId) {
              btn.classList.add('active');
            } else {
              btn.classList.remove('active');
            }
          });
          aiPanels.forEach(panel => {
            if (panel.dataset.provider === providerId) {
              panel.classList.add('active');
            } else {
              panel.classList.remove('active');
            }
          });
        }
      }

      /**
       * 加载 AI 配置（使用统一工具模块）
       */
      function loadAiConfigs() {
        loadAiConfigsFromStorage(aiProviders);
      }

      /**
       * 获取 AI 配置（使用统一工具模块）
       * @param {string} providerId - 提供商 ID
       * @returns {Object|null} 配置对象
       */
      function getAiConfig(providerId = 'deepseek') {
        return getAiConfigFromInputs(providerId, aiProviders);
      }

      /**
       * 保存 AI 配置（使用统一工具模块）
       * @param {string} providerId - 提供商 ID
       */
      function saveAiConfig(providerId = 'deepseek') {
        saveAiConfigToStorage(providerId, aiProviders, (providerName) => {
          // 使用统一的错误处理模块
          const configSavedMsg = typeof getErrorMessage === 'function'
              ? getErrorMessage(ErrorType.USER_ACTION, 'CONFIG_SAVED', { provider: providerName })
              : `${providerName} API 配置已保存`;
          showSuccess(configSavedMsg);
        });
      }
      
      // 导出到全局，供模板中的 onclick 使用
      window.saveAiConfig = saveAiConfig;

      /**
       * 更新AI模块可见性
       * 根据数据加载状态和筛选条件显示/隐藏AI分析模块
       */
      function updateAiModuleVisibility() {
        const aiSection = dom.aiAnalysisSection;
        const emptyMessage = dom.emptyAiMessage;
        const configSection = dom.aiConfigSection;
        
        if (!aiSection) return;
        
        // 获取AI模块的card元素（需要移除hidden类才能显示）
        const aiModuleCard = aiSection.querySelector('.module-card[data-module="ai"]');
        
        // 检查是否有筛选条件
        const hasFilters = (state.selectedOriginPorts.length > 0 || 
                           state.selectedDestPorts.length > 0 || 
                           state.selectedCarriers.length > 0);
        // 检查是否有数据（需要先检查是否为 null）
        const hasData = (state.currentMode === MODE_001 && state.data001 && state.data001.length > 0) ||
                        (state.currentMode === MODE_365 && state.data365 && state.data365.length > 0);
        
        // 如果有筛选条件和数据，检查筛选后的数据是否为空
        let hasFilteredData = false;
        if (hasFilters && hasData) {
          const currentData = state.currentMode === MODE_001 ? state.data001 : state.data365;
          const filteredData = filterDataBySelection(currentData);
          hasFilteredData = filteredData.length > 0;
        }
        
        // 始终显示AI模块section
        aiSection.style.display = 'block';
        
        if (hasFilters && hasData && hasFilteredData) {
          // 有筛选数据，显示配置面板
          if (aiModuleCard) aiModuleCard.classList.remove('hidden');
          if (emptyMessage) emptyMessage.style.display = 'none';
          if (configSection) configSection.style.display = 'block';
        } else {
          // 没有筛选数据，显示空消息
          if (aiModuleCard) aiModuleCard.classList.remove('hidden');
          if (emptyMessage) emptyMessage.style.display = 'block';
          if (configSection) configSection.style.display = 'none';
        }
      }

      /**
       * 构建AI分析提示词
       * @returns {string|null} 构建的提示词，如果数据无效则返回 null
       */
      function buildAiPrompt() {
        // 获取当前筛选后的数据
        const currentData = state.currentMode === MODE_001 ? state.data001 : state.data365;
        if (!currentData || currentData.length === 0) {
          showError(ErrorType.DATA_VALIDATION, 'NO_DATA_FOR_ANALYSIS');
          return null;
        }

        // 应用筛选条件（使用统一的筛选逻辑）
        let filteredData = currentData.filter(item => {
          // 起运港筛选
          if (state.selectedOriginPorts.length > 0) {
            if (!item.originPort || !state.selectedOriginPorts.includes(item.originPort)) {
              return false;
            }
          }
          
          // 目的港筛选（统一使用 selectedDestPorts）
          if (state.selectedDestPorts.length > 0) {
            if (!item.port || !state.selectedDestPorts.includes(item.port)) {
              return false;
            }
          }
          
          // 船公司筛选
          if (state.selectedCarriers.length > 0) {
            if (!state.selectedCarriers.includes(item.carrier)) {
              return false;
            }
          }
          
          return true;
        });

        if (filteredData.length === 0) {
          showError(ErrorType.DATA_VALIDATION, 'NO_FILTERED_DATA');
          return null;
        }

        // 按起运港/目的港和航线分组数据
        const groupedByPort = {};
        filteredData.forEach(item => {
          // 001模式：按起运港分组；365模式：按目的港分组
          const portKey = state.currentMode === MODE_001 
            ? (item.originPort || '未知起运港')
            : (item.port || '未知目的港');
          
          if (!groupedByPort[portKey]) {
            groupedByPort[portKey] = {};
          }
          
          // 按船公司分组（作为航线标识）
          const routeKey = item.carrier || '未知船公司';
          if (!groupedByPort[portKey][routeKey]) {
            groupedByPort[portKey][routeKey] = [];
          }
          
          groupedByPort[portKey][routeKey].push(item);
        });

        // 构建数据描述
        let dataDescription = `【筛选条件】\n`;
        if (state.selectedOriginPorts.length > 0) {
          dataDescription += `起运港：${state.selectedOriginPorts.join('、')}\n`;
        }
        if (state.selectedDestPorts.length > 0) {
          dataDescription += `目的港：${state.selectedDestPorts.join('、')}\n`;
        }
        if (state.selectedCarriers.length > 0) {
          dataDescription += `共舱船公司：${state.selectedCarriers.join('、')}\n`;
        }
        dataDescription += `数据模式：${state.currentMode}\n\n`;

        dataDescription += `【船期数据】\n`;
        dataDescription += `共 ${filteredData.length} 条船期记录\n\n`;

        // 按港口组织数据
        Object.keys(groupedByPort).sort().forEach(portKey => {
          dataDescription += `## ${portKey}\n\n`;
          const routes = groupedByPort[portKey];
          
          Object.keys(routes).sort().forEach(routeKey => {
            const items = routes[routeKey];
            // 按日期排序
            items.sort((a, b) => a.date.getTime() - b.date.getTime());
            
            dataDescription += `### 航线：${routeKey}\n`;
            dataDescription += `船期记录数：${items.length}\n\n`;
            
            // 按周分组显示
            const weeklyData = {};
            items.forEach(item => {
              const weekKey = getWeekKey(item.date);
              if (!weeklyData[weekKey]) {
                weeklyData[weekKey] = [];
              }
              weeklyData[weekKey].push(item);
            });
            
            Object.keys(weeklyData).sort().forEach(weekKey => {
              const weekItems = weeklyData[weekKey];
              dataDescription += `**${weekKey}**：\n`;
              weekItems.forEach(item => {
                const dateStr = formatDate(item.date);
                const port = item.port || '';
                const carrier = item.carrier || '';
                const vessel = item.vessel || '';
                const shipType = item.shipType ? `${item.shipType}TEU` : '';
                dataDescription += `  - ${dateStr} | ${port} | ${carrier} | ${vessel}${shipType ? ' ' + shipType : ''}\n`;
              });
              dataDescription += `\n`;
            });
            
            dataDescription += `\n`;
          });
          
          dataDescription += `\n`;
        });

        // 组合完整提示词
        const fullPrompt = `${sailingScheduleInstructionTemplate}\n\n${dataDescription}`;
        
        return fullPrompt;
      }

      /**
       * 为月度汇总中的航线列绑定悬停提示
       */
      function bindMonthlyRouteTooltips() {
        const routeCells = dom.monthlySummaryTable?.querySelectorAll('.route-cell') || [];
        routeCells.forEach(cell => {
          const routePath = normalizeRoutePath(cell.dataset.routePath || '');
          if (!routePath) return;
          cell.dataset.routePath = routePath; // 同步规范化后的文本

          // 懒创建 tooltip
          let tooltip = null;
          let hideTimer = null;
          let moveHandler = null;

          const show = () => {
            clearTimeout(hideTimer);
            if (!tooltip) {
              tooltip = document.createElement('div');
              tooltip.className = 'tooltip';
              tooltip.style.display = 'none';
              const span = document.createElement('span');
              span.textContent = routePath;
              span.style.whiteSpace = 'pre-wrap';
              span.style.display = 'block';
              span.style.lineHeight = '1.5';
              span.style.fontSize = '12px';
              tooltip.appendChild(span);
              document.body.appendChild(tooltip);
            }

            const updatePosition = (event) => {
              if (!tooltip || !tooltip.parentNode) return;
              const mouseX = event.clientX;
              const mouseY = event.clientY;
              const rect = tooltip.getBoundingClientRect();
              const width = rect.width || tooltip.offsetWidth;
              const height = rect.height || tooltip.offsetHeight;
              const pad = 10;

              let left = mouseX + pad;
              let top = mouseY + pad;
              if (left + width > window.innerWidth) left = mouseX - width - pad;
              if (left < 0) left = (window.innerWidth - width) / 2;
              if (top + height > window.innerHeight) top = mouseY - height - pad;
              if (top < 0) top = mouseY + pad;

              tooltip.style.left = `${left}px`;
              tooltip.style.top = `${top}px`;
            };

            moveHandler = updatePosition;
            tooltip.style.display = 'block';
            requestAnimationFrame(() => updatePosition(window.event || { clientX: cell.getBoundingClientRect().right, clientY: cell.getBoundingClientRect().bottom }));
            eventListeners.add(cell, 'mousemove', moveHandler);
          };

          const hide = () => {
            hideTimer = setTimeout(() => {
              if (tooltip) tooltip.style.display = 'none';
              if (moveHandler) {
                cell.removeEventListener('mousemove', moveHandler);
                moveHandler = null;
              }
            }, 100);
          };

          eventListeners.add(cell, 'mouseenter', show);
          eventListeners.add(cell, 'mouseleave', hide);
          // mousemove 在 show 里绑定
        });
      }

      // 获取周键（用于分组）
      function getWeekKey(date) {
        const year = date.getFullYear();
        const week = getWeekNumber(date);
        return `${year}年第${week}周`;
      }

      // 格式化日期
      function formatDate(date) {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const weekdays = ['周日', '周一', '周二', '周三', '周四', '周五', '周六'];
        const weekday = weekdays[date.getDay()];
        return `${year}/${month}/${day}(${weekday})`;
      }

      /**
       * 运行AI分析（使用统一工具模块）
       * @param {string} providerId - 提供商 ID
       */
      async function runAiAnalysis(providerId = 'deepseek') {
        await executeAiAnalysis(
          providerId,
          aiProviders,
          buildAiPrompt,
          sailingScheduleSystemPrompt,
          {
            onError: (message) => {
              showError(ErrorType.API_ERROR, 'API_REQUEST_FAILED', { message });
            }
          }
        );
      }
      
      // 导出到全局，供模板中的 onclick 使用
      window.runAiAnalysis = runAiAnalysis;

      // 页面卸载时清理所有事件监听器
      window.addEventListener('beforeunload', () => {
        eventListeners.cleanup();
      });

      // 初始化 - 使用 requestIdleCallback 优化初始加载性能
      const initializeApp = () => {
        init();
        // AI模块延迟初始化，避免阻塞主线程
        if ('requestIdleCallback' in window) {
          requestIdleCallback(() => {
            initSailingAiModule();
          }, { timeout: 2000 });
        } else {
          // 降级方案：使用 setTimeout
          setTimeout(() => {
            initSailingAiModule();
          }, 100);
        }
      };

      if (document.readyState === 'loading') {
        const handleDOMContentLoaded = () => {
          initializeApp();
        };
        eventListeners.add(document, 'DOMContentLoaded', handleDOMContentLoaded);
      } else {
        // 如果文档已加载，使用 requestAnimationFrame 延迟初始化
        requestAnimationFrame(() => {
          initializeApp();
        });
      }
    </script>
  </body>
</html>


