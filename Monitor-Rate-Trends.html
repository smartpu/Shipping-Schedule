<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Monitor · 运价趋势面板</title>
    <link rel="stylesheet" href="vendor/theme-styles.css">
    <script src="vendor/lib-loader.js"></script>
    <script src="vendor/common-utils.js"></script>
    <script src="vendor/pdf-utils.js"></script>
    <script src="vendor/error-handler.js"></script>
    <script src="vendor/debug-utils.js"></script>
    <script src="vendor/auth-gist.js"></script>
  </head>
  <body data-page="Monitor-Rate-Trends.html">
    <div class="dashboard-container">
      <!-- 左侧导航栏占位容器（将由sidebar-loader.js动态加载） -->
      <div id="sidebar-placeholder"></div>

      <!-- 右侧内容 -->
      <main class="dashboard-content">
        <div class="container">
          <!-- 顶部介绍卡片，沿用 dashboard 风格 -->
          <div class="section-intro">
            <div class="section-intro-header">
              <div class="section-intro-content">
                <h2>Monitor · 运价趋势面板</h2>
                <p>载入 Excel 后，用 D 列日期和 F 列港口筛选，自动抽取 G=2SD/4SH 对应的 H 列运费。</p>
              </div>
              <div class="section-intro-actions">
                <button type="button" class="tool-link" id="export-btn" aria-label="导出PDF" disabled>导出PDF</button>
                <a href="dashboard.html?tab=monitor" class="tool-link" aria-label="返回工具集首页">← 返回首页</a>
                <a href="Monitor-Rate-Trends-README.html" class="tool-link secondary" aria-label="查看使用说明文档">使用说明 →</a>
              </div>
            </div>
          </div>

          <!-- 文件上传和数据状态区域 -->
          <div class="grid-2-col" style="margin-bottom: 20px;">
            <!-- 左侧：载入 Excel -->
            <div class="card-white">
              <label for="file-input" class="file-upload-label" aria-label="选择Excel文件上传">
                <svg class="file-upload-icon" width="36" height="36" viewBox="0 0 36 36" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <rect x="4" y="4" width="28" height="28" rx="8" fill="url(#gradExcel)" />
                  <!-- Excel表格图标 -->
                  <rect x="8" y="8" width="20" height="20" rx="2" fill="none" stroke="#fff" stroke-width="1.5"/>
                  <line x1="8" y1="14" x2="28" y2="14" stroke="#fff" stroke-width="1.5"/>
                  <line x1="8" y1="20" x2="28" y2="20" stroke="#fff" stroke-width="1.5"/>
                  <line x1="14" y1="8" x2="14" y2="28" stroke="#fff" stroke-width="1.5"/>
                  <!-- 向下箭头 -->
                  <path d="M18 22L22 26L14 26Z" fill="#fff"/>
                  <defs>
                    <linearGradient id="gradExcel" x1="4" y1="4" x2="32" y2="32" gradientUnits="userSpaceOnUse">
                      <stop stop-color="#0071e3" />
                      <stop offset="1" stop-color="#54a4ff" />
                    </linearGradient>
                  </defs>
                </svg>
                <div class="file-upload-content">
                  <div class="file-upload-title">载入 Excel</div>
                  <div class="file-upload-desc">支持 .xlsx / .xls，数据仅在本地浏览器解析</div>
                </div>
                <input type="file" id="file-input" class="file-upload-input" accept=".xlsx,.xls" aria-label="选择Excel文件" title="选择Excel文件：文件需包含运价数据">
              </label>
            </div>
            
            <!-- 右侧：数据状态 -->
            <div class="card-white">
              <div class="data-status-container">
                <svg class="data-status-icon" width="36" height="36" viewBox="0 0 36 36" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <rect x="4" y="4" width="28" height="28" rx="8" fill="url(#gradStatus)" />
                  <!-- 数据状态图标：剪贴板 + 勾 -->
                  <rect x="11" y="10" width="14" height="16" rx="2" fill="none" stroke="#fff" stroke-width="1.5"/>
                  <rect x="15" y="8" width="6" height="4" rx="1" fill="#fff"/>
                  <path d="M14 18L17 21L23 15" stroke="#fff" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
                  <defs>
                    <linearGradient id="gradStatus" x1="4" y1="4" x2="32" y2="32" gradientUnits="userSpaceOnUse">
                      <stop stop-color="#FF8A00" />
                      <stop offset="1" stop-color="#FFB347" />
                    </linearGradient>
                  </defs>
                </svg>
                <div class="data-status-content">
                  <div class="data-status-title">数据状态</div>
                  <div id="status-value" class="data-status-text" style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">尚未载入数据</div>
                </div>
              </div>
            </div>
          </div>

          <!-- 筛选条件 -->
          <div class="card-white mt-20">
            <div class="filters">
              <div class="filter-block date-row">
                <div class="date-field-inline">
                  <label for="start-date">开始时间</label>
                  <input type="date" id="start-date" lang="en" />
                </div>
                <div class="date-field-inline">
                  <label for="end-date">结束时间</label>
                  <input type="date" id="end-date" lang="en" />
                </div>
              </div>
              <div class="filter-block port-chips">
                <label>港口（可多选）</label>
                <div id="port-chips-container" class="port-chips-container"></div>
              </div>
            </div>

            <div class="metrics" id="metric-base">
              <div class="metric-card">
                <h3>最新 2SD</h3>
                <p id="latest-2sd">—</p>
                <small id="latest-2sd-meta">—</small>
                <small class="metric-extra" id="latest-2sd-ports" style="display: none">—</small>
              </div>
              <div class="metric-card">
                <h3>最新 4SH</h3>
                <p id="latest-4sh">—</p>
                <small id="latest-4sh-meta">—</small>
                <small class="metric-extra" id="latest-4sh-ports" style="display: none">—</small>
              </div>
              <div class="metric-card">
                <h3>最高 2SD</h3>
                <p id="high-2sd">—</p>
                <small id="high-2sd-meta">—</small>
                <small class="metric-extra" id="high-2sd-ports" style="display: none">—</small>
              </div>
              <div class="metric-card">
                <h3>最高 4SH</h3>
                <p id="high-4sh">—</p>
                <small id="high-4sh-meta">—</small>
                <small class="metric-extra" id="high-4sh-ports" style="display: none">—</small>
              </div>
              <div class="metric-card">
                <h3>最低 2SD</h3>
                <p id="low-2sd">—</p>
                <small id="low-2sd-meta">—</small>
                <small class="metric-extra" id="low-2sd-ports" style="display: none">—</small>
              </div>
              <div class="metric-card">
                <h3>最低 4SH</h3>
                <p id="low-4sh">—</p>
                <small id="low-4sh-meta">—</small>
                <small class="metric-extra" id="low-4sh-ports" style="display: none">—</small>
              </div>
            </div>
            <div id="port-metric-groups" class="metric-group-stack"></div>
          </div>

          <!-- 筛选区间 · 趋势曲线 -->
          <div class="card-white mt-20">
            <h2 class="section-title">筛选区间 · 趋势曲线</h2>
            <div class="chart-stack" id="range-chart-stack">
              <div class="chart-empty">尚无数据</div>
            </div>
            <div class="table-wrap">
          <table>
            <thead>
              <tr>
                <th>周（C列）</th>
                <th>日期（D列）</th>
                <th>港口（F列）</th>
                <th>类型（G列）</th>
                <th>运费（H列）</th>
              </tr>
            </thead>
            <tbody id="data-body">
              <tr>
                <td colspan="5" style="text-align: center; color: #6c757d">
                  尚无数据，请先载入 Excel。
                </td>
              </tr>
            </tbody>
            </table>
          </div>
          </div>

          <!-- 全历史 · 周度走势 -->
          <div class="card-white mt-20">
            <h2 class="section-title">全历史 · 周度走势</h2>
            <div class="chart-stack" id="history-chart-stack">
              <div class="chart-empty">尚无数据</div>
            </div>
          </div>

          <!-- 年度对比 · 同期观察 -->
          <div class="card-white mt-20">
            <h2 class="section-title">年度对比 · 同期观察</h2>
            <div class="toggle-group" id="yearly-toggle">
              <label class="toggle-chip">
                <input type="checkbox" value="2SD" />
                只看 2SD
              </label>
              <label class="toggle-chip">
                <input type="checkbox" value="4SH" checked />
                只看 4SH
              </label>
            </div>
            <div class="chart-stack" id="yearly-chart-stack">
              <div class="chart-empty">尚无数据</div>
            </div>
          </div>

          <!-- 周度涨跌统计 -->
          <div class="card-white mt-20">
            <h2 class="section-title">周度涨跌统计</h2>
            <div class="trend-table-wrap">
              <table class="trend-table">
                <thead>
                  <tr>
                    <th>港口</th>
                    <th id="trend-h-prev2">上上周 2SD/4SH</th>
                    <th id="trend-h-compare-prev2">对比上上上周</th>
                    <th id="trend-h-prev1">上周 2SD/4SH</th>
                    <th id="trend-h-compare-prev1">对比上上周</th>
                    <th id="trend-h-current">本周 2SD/4SH</th>
                    <th id="trend-h-compare-current">对比上周</th>
                  </tr>
                </thead>
                <tbody id="trend-table-body">
                  <tr>
                    <td colspan="7" class="empty-row">数据载入后自动生成</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          </div>

          <!-- 使用声明 -->
          <div class="card-white mt-20">
            <h2 class="usage-statement-title">Monitor · 运价趋势面板使用声明</h2>
            <p class="usage-statement-text">资料整合自用户 Excel 数据，解析结果仅供内部研判，不构成对外报价或投资建议。</p>
            <p class="usage-statement-text">所有数据仅在本地浏览器解析，不会上传至任何服务器，请放心使用。</p>
          </div>
        </div>
      </main>
    </div>

    <!-- 引入导航栏公共组件 -->
    <script src="vendor/sidebar-loader.js"></script>
    <script>
      init001ToolPage('Monitor-Rate-Trends.html', 'monitor');
    </script>
    <script>

      // XLSX 和 Chart.js 已在 head 中通过 lib-loader.js 加载
      // 注意：Monitor-Rate-Trends.html 需要 Chart.js 4.4.6，而公共加载器使用 4.4.0
      // 如果需要特定版本，可以在这里覆盖（目前使用 4.4.0 应该也兼容）

      // PDF 库加载已统一到 vendor/pdf-utils.js
      // 使用 loadPdfLibraries() 函数来加载 html2canvas 和 jsPDF
      // 注意：如果页面需要 PDF 导出功能，会在使用时自动加载
    </script>
    <script>
      const TARGET_TYPES = ["2SD", "4SH"];
      const YEAR_COLORS = ["#0071e3", "#ff3b30", "#34c759", "#ff9500", "#af52de", "#ff2d55", "#64d2ff"];
      const PORT_COLORS = [
        "#0071e3",
        "#ff3b30",
        "#34c759",
        "#ff9500",
        "#af52de",
        "#ff2d55",
        "#64d2ff",
        "#ffd60a",
        "#ff375f",
        "#5856d6",
      ];

      const state = {
        rows: [],
        ports: [],
        lastFiltered: [],
        stats: {
          eligible: 0,
          dropped: {
            missingDate: 0,
            missingPort: 0,
            missingRate: 0,
          },
        },
        filters: {
          start: "",
          end: "",
          ports: [],
        },
        yearlyToggle: {
          "2SD": false,
          "4SH": true,
        },
      };

        const dom = {
        fileInput: document.getElementById("file-input"),
        statusValue: document.getElementById("status-value"),
        startDate: document.getElementById("start-date"),
        endDate: document.getElementById("end-date"),
        portChipsContainer: document.getElementById("port-chips-container"),
        exportBtn: document.getElementById("export-btn"),
        latest2sd: document.getElementById("latest-2sd"),
        latest4sh: document.getElementById("latest-4sh"),
        latest2sdMeta: document.getElementById("latest-2sd-meta"),
        latest4shMeta: document.getElementById("latest-4sh-meta"),
        latest2sdPorts: document.getElementById("latest-2sd-ports"),
        latest4shPorts: document.getElementById("latest-4sh-ports"),
        high2sd: document.getElementById("high-2sd"),
        high2sdMeta: document.getElementById("high-2sd-meta"),
        high4sh: document.getElementById("high-4sh"),
        high4shMeta: document.getElementById("high-4sh-meta"),
        low2sd: document.getElementById("low-2sd"),
        low2sdMeta: document.getElementById("low-2sd-meta"),
        low4sh: document.getElementById("low-4sh"),
        low4shMeta: document.getElementById("low-4sh-meta"),
        high2sdPorts: document.getElementById("high-2sd-ports"),
        high4shPorts: document.getElementById("high-4sh-ports"),
        low2sdPorts: document.getElementById("low-2sd-ports"),
        low4shPorts: document.getElementById("low-4sh-ports"),
        portMetricGroups: document.getElementById("port-metric-groups"),
        rangeStack: document.getElementById("range-chart-stack"),
        historyStack: document.getElementById("history-chart-stack"),
        yearlyStack: document.getElementById("yearly-chart-stack"),
        yearlyToggle: document.getElementById("yearly-toggle"),
        trendTableBody: document.getElementById("trend-table-body"),
        trendHeaders: {
          prev2: document.getElementById("trend-h-prev2"),
          prev1: document.getElementById("trend-h-prev1"),
          current: document.getElementById("trend-h-current"),
          comparePrev2: document.getElementById("trend-h-compare-prev2"),
          comparePrev1: document.getElementById("trend-h-compare-prev1"),
          compareCurrent: document.getElementById("trend-h-compare-current"),
        },
        tableBody: document.getElementById("data-body"),
      };

      const chartRegistry = {
        range: [],
        history: [],
        yearly: [],
      };

      dom.fileInput.addEventListener("change", handleFileUpload);
      dom.startDate.addEventListener("change", () => updateFilters("start", dom.startDate.value));
      dom.endDate.addEventListener("change", () => updateFilters("end", dom.endDate.value));
      dom.exportBtn.addEventListener("click", exportFilteredData);
      dom.yearlyToggle?.addEventListener("change", handleYearlyToggle);

      // ==================== 调试模式 ====================
      // 调试函数已统一到 vendor/debug-utils.js
      // 使用：debugLog(), debugWarn(), debugError()

      // ==================== 错误处理 ====================
      // 错误处理已统一到 vendor/error-handler.js
      // 使用：showError(ErrorType.FILE_LOAD, 'XLSX_NOT_LOADED')
      // ErrorType 和 showError 函数已从 error-handler.js 加载

      async function handleFileUpload(event) {
        const file = event.target.files?.[0];
        if (!file) return;
        
        if (typeof window.XLSX === "undefined") {
          showError(ErrorType.FILE_LOAD, 'XLSX_NOT_LOADED');
          dom.statusValue.textContent = "XLSX 库未加载";
          return;
        }
        
        dom.statusValue.textContent = "解析中...";
        state.stats = {
          eligible: 0,
          dropped: { missingDate: 0, missingPort: 0, missingRate: 0 },
        };

        const data = await file.arrayBuffer();
        const workbook = XLSX.read(data, { type: "array" });
        const firstSheetName = workbook.SheetNames[0];
        const sheet = workbook.Sheets[firstSheetName];

        const matrix = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: "" });
        const parsedRows = matrix
          .slice(1) // 跳过标题行
          .map(convertRow)
          .filter(Boolean);

        state.rows = parsedRows;
        const allPorts = Array.from(new Set(parsedRows.map((row) => row.port)));
        state.ports = sortPortsByCustomOrder(allPorts);

        populatePortChips();
        setDefaultPortSelection();
        setDefaultDateWindow();
        const eligible = state.stats.eligible;
        const used = state.rows.length;
        const droppedTotals = state.stats.dropped || { missingDate: 0, missingPort: 0, missingRate: 0 };
        const dropped = (droppedTotals.missingDate || 0) + (droppedTotals.missingPort || 0) + (droppedTotals.missingRate || 0);
        
        if (eligible) {
          if (dropped) {
            const parts = [];
            if (droppedTotals.missingDate) parts.push(`缺时间 ${droppedTotals.missingDate} 条`);
            if (droppedTotals.missingPort) parts.push(`缺港口 ${droppedTotals.missingPort} 条`);
            if (droppedTotals.missingRate) parts.push(`缺运费 ${droppedTotals.missingRate} 条`);
            dom.statusValue.innerHTML = `<span>已载入 1 个文件</span><span style="color: #6c757d;">共 ${eligible} 条记录，其中 ${dropped} 条数据不完整（${parts.join("、")}）已自动跳过</span>`;
          } else {
            dom.statusValue.innerHTML = `<span>已载入 1 个文件</span><span style="color: #6c757d;">共 ${eligible} 条记录</span>`;
          }
        } else {
          dom.statusValue.textContent = "尚未载入数据";
        }
        syncYearlyToggleUI();
        refreshOutputs();
      }

      function convertRow(row) {
        const weekCode = safeString(row[1]);
        const displayLabel = safeString(row[2]);
        const startCell = row[3];
        const filterDate = coerceDate(startCell);
        const startLabel = formatCellLabel(startCell, filterDate);
        const endCell = row[4];
        const endDate = coerceDate(endCell);
        const endLabel = formatCellLabel(endCell, endDate);
        const port = safeString(row[5]);
        const rateTypeRaw = safeString(row[6]).toUpperCase();
        const rateValue = parseNumber(row[7]);

        if (!TARGET_TYPES.includes(rateTypeRaw)) {
          return null;
        }

        state.stats.eligible++;

        if (!filterDate) {
          state.stats.dropped.missingDate++;
          return null;
        }

        if (!port) {
          state.stats.dropped.missingPort++;
          return null;
        }

        if (rateValue === null) {
          state.stats.dropped.missingRate++;
          return null;
        }

        const rateType = rateTypeRaw;

        return {
          weekCode,
          displayLabel,
          filterDate,
          startLabel,
          endLabel,
          port,
          rateType,
          rateValue,
        };
      }

      // 港口显示顺序（用户指定）
      const PORT_DISPLAY_ORDER = [
        'AEJBA', 'IQUQS', 'SAJED', 'INNXV', 'PKKHI', 'INCEN', 'AUMEL', 'AUSYD', 
        'KEMWA', 'TZDFQ', 'ZADRB', 'SGSGP', 'MYPKL', 'BNMRI', 'THLCH', 'VNHCM', 
        'VNHPG', 'KHSIH', 'PHMNL', 'PHCEB', 'IDDKT', 'MMYQT', 'HKHKG', 'TWKSG', 
        'USNYC', 'USLAX', 'COCTG', 'MXMZO', 'BRSTO', 'NLRDM', 'ESVLC'
      ];

      // 按照指定顺序排序港口
      function sortPortsByCustomOrder(ports) {
        const orderMap = new Map();
        PORT_DISPLAY_ORDER.forEach((port, index) => {
          orderMap.set(port, index);
        });
        
        const sorted = ports.sort((a, b) => {
          const indexA = orderMap.has(a) ? orderMap.get(a) : Infinity;
          const indexB = orderMap.has(b) ? orderMap.get(b) : Infinity;
          
          if (indexA !== Infinity && indexB !== Infinity) {
            return indexA - indexB;
          } else if (indexA !== Infinity) {
            return -1;
          } else if (indexB !== Infinity) {
            return 1;
          } else {
            return a.localeCompare(b, "zh-CN");
          }
        });
        
        return sorted;
      }

      function populatePortChips() {
        if (!dom.portChipsContainer) return;
        dom.portChipsContainer.innerHTML = "";
        
        if (!state.ports.length) {
          dom.portChipsContainer.innerHTML = '<div style="color: var(--color-text-tertiary); padding: 12px;">暂无港口数据</div>';
          return;
        }
        
        state.ports.forEach((port) => {
          const chip = document.createElement("button");
          chip.type = "button";
          chip.className = "port-chip";
          chip.textContent = port;
          chip.dataset.port = port;
          chip.addEventListener("click", () => {
            chip.classList.toggle("active");
            updatePortSelection();
            refreshOutputs();
          });
          dom.portChipsContainer.appendChild(chip);
        });
      }

      function setDefaultPortSelection() {
        if (!state.ports.length) {
          state.filters.ports = [];
          return;
        }
        const defaultPort = state.ports[0];
        setPortSelection([defaultPort]);
      }

      function setPortSelection(ports) {
        state.filters.ports = ports;
        const selectedSet = new Set(ports);
        if (dom.portChipsContainer) {
          dom.portChipsContainer.querySelectorAll(".port-chip").forEach((chip) => {
            if (selectedSet.has(chip.dataset.port)) {
              chip.classList.add("active");
            } else {
              chip.classList.remove("active");
            }
          });
        }
      }

      function updatePortSelection() {
        if (!dom.portChipsContainer) return;
        const selected = Array.from(dom.portChipsContainer.querySelectorAll(".port-chip.active"))
          .map((chip) => chip.dataset.port);
        state.filters.ports = selected;
      }

      function handleYearlyToggle(event) {
        const input = event.target.closest('input[type="checkbox"]');
        if (!input) return;
        const type = input.value.toUpperCase();
        state.yearlyToggle[type] = input.checked;
        if (!state.yearlyToggle["2SD"] && !state.yearlyToggle["4SH"]) {
          state.yearlyToggle[type] = true;
          input.checked = true;
        }
        syncYearlyToggleUI();
        if (!state.yearlyToggle["2SD"] && !state.yearlyToggle["4SH"]) return;
        updateYearlyChart(filterRowsByPorts(state.rows));
      }

      function syncYearlyToggleUI() {
        if (!dom.yearlyToggle) return;
        dom.yearlyToggle.querySelectorAll('input[type="checkbox"]').forEach((input) => {
          const type = input.value.toUpperCase();
          input.checked = !!state.yearlyToggle[type];
        });
      }

      function updateFilters(key, value) {
        state.filters[key] = value;
        refreshOutputs();
      }

      function setDefaultDateWindow() {
        const dateValues = state.rows
          .map((row) => row.filterDate)
          .filter((date) => date instanceof Date && !isNaN(date));

        if (!dateValues.length) {
          state.filters.start = "";
          state.filters.end = "";
          dom.startDate.value = "";
          dom.endDate.value = "";
          return;
        }

        const latest = new Date(Math.max(...dateValues.map((d) => d.getTime())));
        const earliest = new Date(Math.min(...dateValues.map((d) => d.getTime())));
        const eightWeeksAgo = new Date(latest);
        eightWeeksAgo.setDate(eightWeeksAgo.getDate() - 7 * 8);
        const effectiveStart = eightWeeksAgo < earliest ? earliest : eightWeeksAgo;

        state.filters.start = formatDate(effectiveStart);
        state.filters.end = formatDate(latest);

        dom.startDate.value = state.filters.start;
        dom.endDate.value = state.filters.end;
      }

      function refreshOutputs() {
        if (!state.rows.length) {
          state.lastFiltered = [];
          dom.tableBody.innerHTML =
            '<tr><td colspan="5" style="text-align:center;color:#6c757d">尚无数据，请载入 Excel。</td></tr>';
          updateRangeChart([]);
          updateHistoryChart([]);
          updateYearlyChart([]);
          updateMetrics([]);
          dom.exportBtn.disabled = true;
          return;
        }

        const filtered = getFilteredRows();
        state.lastFiltered = filtered;
        const portScopedRows = filterRowsByPorts(state.rows);
        dom.exportBtn.disabled = !filtered.length;
        updateMetrics(filtered);
        updateTable(filtered);
        updateRangeChart(filtered);
        updateHistoryChart(portScopedRows);
        updateYearlyChart(portScopedRows);
        updateTrendTable(state.rows);
      }

      /**
       * 显示模块选择对话框
       */
      function showModuleSelectionDialog() {
        return new Promise((resolve) => {
          const overlay = document.createElement('div');
          overlay.className = 'module-selection-overlay';

          const dialog = document.createElement('div');
          dialog.className = 'module-selection-dialog';

          dialog.innerHTML = `
            <h2>选择要导出的模块</h2>
            <div class="module-selection-options">
              <label class="module-selection-label">
                <input type="radio" name="moduleSelect" value="rangeModule">
                <div class="module-selection-content">
                  <div class="module-selection-title">筛选区间 · 趋势曲线</div>
                  <div class="module-selection-desc">包含筛选区间的趋势图表和数据表格</div>
                </div>
              </label>
              <label class="module-selection-label">
                <input type="radio" name="moduleSelect" value="historyModule">
                <div class="module-selection-content">
                  <div class="module-selection-title">全历史 · 周度走势</div>
                  <div class="module-selection-desc">包含全历史周度走势图表</div>
                </div>
              </label>
              <label class="module-selection-label">
                <input type="radio" name="moduleSelect" value="yearlyModule">
                <div class="module-selection-content">
                  <div class="module-selection-title">年度对比 · 同期观察</div>
                  <div class="module-selection-desc">包含年度对比图表</div>
                </div>
              </label>
              <label class="module-selection-label">
                <input type="radio" name="moduleSelect" value="trendModule">
                <div class="module-selection-content">
                  <div class="module-selection-title">周度涨跌统计</div>
                  <div class="module-selection-desc">包含周度涨跌统计表格</div>
                </div>
              </label>
              <label class="module-selection-label">
                <input type="radio" name="moduleSelect" value="all">
                <div class="module-selection-content">
                  <div class="module-selection-title">运价趋势面板 · 全部导出</div>
                  <div class="module-selection-desc">导出所有模块</div>
                </div>
              </label>
            </div>
            <div class="module-selection-actions">
              <button id="cancelExportBtn" class="btn-sweep-orange">取消</button>
              <button id="confirmExportBtn" class="btn-sweep-blue">导出</button>
            </div>
          `;

          overlay.appendChild(dialog);
          document.body.appendChild(overlay);

          // 更新标签选中状态
          const labels = dialog.querySelectorAll('.module-selection-label');
          const radios = dialog.querySelectorAll('input[type="radio"][name="moduleSelect"]');
          
          const updateLabelStyles = () => {
            labels.forEach((label) => {
              const radio = label.querySelector('input[type="radio"]');
              if (radio && radio.checked) {
                label.classList.add('selected');
              } else {
                label.classList.remove('selected');
              }
            });
          };

          radios.forEach(radio => {
            radio.addEventListener('change', () => {
              updateLabelStyles();
            });
          });
          
          labels.forEach(label => {
            label.addEventListener('click', (e) => {
              const radio = label.querySelector('input[type="radio"]');
              if (radio && e.target !== radio) {
                radio.checked = true;
                radio.dispatchEvent(new Event('change', { bubbles: true }));
              }
            });
          });

          // 确认按钮
          const confirmBtn = dialog.querySelector('#confirmExportBtn');
          confirmBtn.addEventListener('click', () => {
            const selected = dialog.querySelector('input[name="moduleSelect"]:checked');
            if (selected) {
              document.body.removeChild(overlay);
              resolve(selected.value);
            } else {
              if (typeof showError === 'function' && typeof ErrorType !== 'undefined') {
                showError(ErrorType.USER_ACTION, 'MODULE_NOT_SELECTED', { 
                  message: '请选择一个要导出的模块' 
                });
              } else {
                alert('请选择一个要导出的模块');
              }
            }
          });

          // 取消按钮
          const cancelBtn = dialog.querySelector('#cancelExportBtn');
          cancelBtn.addEventListener('click', () => {
            document.body.removeChild(overlay);
            resolve(null);
          });

          // 点击遮罩关闭
          overlay.addEventListener('click', (e) => {
            if (e.target === overlay) {
              document.body.removeChild(overlay);
              resolve(null);
            }
          });

          // 默认选中第一个模块
          const firstRadio = dialog.querySelector('input[type="radio"][value="rangeModule"]');
          if (firstRadio) {
            firstRadio.checked = true;
            firstRadio.dispatchEvent(new Event('change', { bubbles: true }));
            updateLabelStyles();
          }
        });
      }

      /**
       * 导出指定模块为 PDF
       */
      async function exportModuleToPdf(moduleId) {
        const moduleMap = {
          'rangeModule': { 
            containerSelector: '#range-chart-stack',
            name: '筛选区间-趋势曲线',
            chartType: 'range'
          },
          'historyModule': { 
            containerSelector: '#history-chart-stack',
            name: '全历史-周度走势',
            chartType: 'history'
          },
          'yearlyModule': { 
            containerSelector: '#yearly-chart-stack',
            name: '年度对比-同期观察',
            chartType: 'yearly'
          },
          'trendModule': { 
            containerSelector: '#trend-table-body',
            name: '周度涨跌统计',
            chartType: null
          }
        };

        const moduleInfo = moduleMap[moduleId];
        if (!moduleInfo) {
          showError(ErrorType.SYSTEM_ERROR, 'PDF_EXPORT_FAILED', { 
            message: `未知的模块ID: ${moduleId}` 
          });
          return;
        }

        // 先找到内容元素（chart-stack或table）
        const contentElement = document.querySelector(moduleInfo.containerSelector);
        if (!contentElement) {
          debugError(`找不到内容元素: ${moduleInfo.containerSelector}`);
          showError(ErrorType.SYSTEM_ERROR, 'PDF_EXPORT_FAILED', { 
            message: `找不到模块: ${moduleInfo.name}` 
          });
          return;
        }

        // 找到包含该内容的整个card容器
        const containerElement = contentElement.closest('.card-white.mt-20');
        if (!containerElement) {
          debugError(`找不到容器元素，内容元素: ${moduleInfo.containerSelector}`);
          showError(ErrorType.SYSTEM_ERROR, 'PDF_EXPORT_FAILED', { 
            message: `找不到模块容器: ${moduleInfo.name}` 
          });
          return;
        }

        debugLog(`导出模块 ${moduleInfo.name}, 容器元素:`, containerElement);

        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const day = String(now.getDate()).padStart(2, '0');
        const fileName = `运价趋势面板_${moduleInfo.name}_${year}${month}${day}`;

        // 查找模块内的所有图表canvas（通过Chart.js注册表）
        const chartCanvasIds = [];
        if (moduleInfo.chartType && chartRegistry[moduleInfo.chartType]) {
          chartRegistry[moduleInfo.chartType].forEach((chart, index) => {
            if (chart && chart.canvas) {
              if (!chart.canvas.id) {
                chart.canvas.id = `${moduleInfo.chartType}-chart-${index}`;
              }
              chartCanvasIds.push(chart.canvas.id);
            }
          });
        }
        
        debugLog(`导出模块 ${moduleInfo.name}, 找到 ${chartCanvasIds.length} 个图表`);

        if (typeof window.exportToPdfCommon === 'function') {
          try {
            await window.exportToPdfCommon({
              fileName,
              elements: containerElement,
              chartCanvasIds: chartCanvasIds.length > 0 ? chartCanvasIds : undefined,
              exportBtnId: 'export-btn'
            });
          } catch (error) {
            debugError('exportToPdfCommon 调用失败:', error);
            throw error;
          }
        } else {
          debugError('exportToPdfCommon 函数未找到');
          showError(ErrorType.SYSTEM_ERROR, 'PDF_EXPORT_FAILED', { 
            message: 'PDF 导出功能所需的工具函数未找到，请刷新页面重试' 
          });
        }
      }

      /**
       * 导出全部模块为 PDF
       */
      async function exportAllModulesToPdf() {
        // 使用ID选择器找到各个模块的容器
        const moduleSelectors = [
          { contentSelector: '#range-chart-stack', name: '筛选区间-趋势曲线', type: 'range' },
          { contentSelector: '#history-chart-stack', name: '全历史-周度走势', type: 'history' },
          { contentSelector: '#yearly-chart-stack', name: '年度对比-同期观察', type: 'yearly' },
          { contentSelector: '#trend-table-body', name: '周度涨跌统计', type: 'trend' }
        ];

        const moduleElements = [];
        moduleSelectors.forEach(({ contentSelector, name, type }) => {
          const contentElement = document.querySelector(contentSelector);
          if (contentElement) {
            const containerElement = contentElement.closest('.card-white.mt-20');
            if (containerElement) {
              moduleElements.push({ element: containerElement, name, type });
            } else {
              debugWarn(`找不到容器元素: ${contentSelector}`);
            }
          } else {
            debugWarn(`找不到内容元素: ${contentSelector}`);
          }
        });

        if (moduleElements.length === 0) {
          debugError('找不到要导出的模块元素');
          showError(ErrorType.SYSTEM_ERROR, 'PDF_EXPORT_FAILED', { 
            message: '找不到要导出的模块' 
          });
          return;
        }

        debugLog(`导出全部模块，找到 ${moduleElements.length} 个模块:`, moduleElements.map(m => m.name));

        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const day = String(now.getDate()).padStart(2, '0');
        const fileName = `运价趋势面板_全部模块_${year}${month}${day}`;

        // 收集所有图表canvas（通过Chart.js注册表）
        const allChartCanvases = [];
        ['range', 'history', 'yearly'].forEach(type => {
          if (chartRegistry[type]) {
            chartRegistry[type].forEach((chart, index) => {
              if (chart && chart.canvas) {
                if (!chart.canvas.id) {
                  chart.canvas.id = `${type}-chart-${index}`;
                }
                allChartCanvases.push(chart.canvas.id);
              }
            });
          }
        });

        debugLog(`找到 ${allChartCanvases.length} 个图表canvas`);

        if (typeof window.exportToPdfCommon === 'function') {
          try {
            await window.exportToPdfCommon({
              fileName,
              elements: moduleElements.map(m => m.element),
              chartCanvasIds: allChartCanvases.length > 0 ? allChartCanvases : undefined,
              exportBtnId: 'export-btn'
            });
          } catch (error) {
            debugError('exportToPdfCommon 调用失败:', error);
            throw error;
          }
        } else {
          debugError('exportToPdfCommon 函数未找到');
          showError(ErrorType.SYSTEM_ERROR, 'PDF_EXPORT_FAILED', { 
            message: 'PDF 导出功能所需的工具函数未找到，请刷新页面重试' 
          });
        }
      }

      async function exportFilteredData() {
        if (!state.rows.length) {
          showError(ErrorType.DATA_VALIDATION, 'NO_DATA_LOADED');
          return;
        }
        
        try {
          const selectedModule = await showModuleSelectionDialog();
          if (!selectedModule) {
            return; // 用户取消了选择
          }

          dom.exportBtn.disabled = true;
          dom.exportBtn.textContent = "导出中...";
          
          if (selectedModule === 'all') {
            await exportAllModulesToPdf();
          } else {
            await exportModuleToPdf(selectedModule);
          }
        } catch (error) {
          debugError("导出 PDF 失败:", error);
          showError(ErrorType.FILE_LOAD, 'PDF_EXPORT_FAILED', { message: error.message || "未知错误" }, error);
        } finally {
          dom.exportBtn.textContent = "导出 PDF";
          dom.exportBtn.disabled = !state.lastFiltered.length;
        }
      }

      function getFilteredRows() {
        return filterRowsByPorts(state.rows)
          .filter((row) => {
            const start = state.filters.start ? new Date(state.filters.start) : null;
            const end = state.filters.end ? new Date(state.filters.end) : null;
            if (start && row.filterDate < start) return false;
            if (end && row.filterDate > end) return false;
            return true;
          })
          .sort((a, b) => a.filterDate - b.filterDate);
      }

      function updateMetrics(rows) {
        const summary = summarizeMetricRows(rows);
        const multiLabel = state.filters.ports.length > 1 ? formatPortSummary() : "";

        dom.latest2sd.textContent = summary.latest2sd ? formatNumber(summary.latest2sd.rateValue) : "—";
        dom.latest2sdMeta.textContent = summary.latest2sd ? formatMetricMeta(summary.latest2sd) : "—";
        dom.latest4sh.textContent = summary.latest4sh ? formatNumber(summary.latest4sh.rateValue) : "—";
        dom.latest4shMeta.textContent = summary.latest4sh ? formatMetricMeta(summary.latest4sh) : "—";
        updatePortLine(dom.latest2sdPorts, summary.latest2sd, multiLabel);
        updatePortLine(dom.latest4shPorts, summary.latest4sh, multiLabel);

        dom.high2sd.textContent = summary.high2sd ? formatNumber(summary.high2sd.rateValue) : "—";
        dom.high2sdMeta.textContent = summary.high2sd ? formatMetricMeta(summary.high2sd) : "—";
        dom.high4sh.textContent = summary.high4sh ? formatNumber(summary.high4sh.rateValue) : "—";
        dom.high4shMeta.textContent = summary.high4sh ? formatMetricMeta(summary.high4sh) : "—";
        updatePortLine(dom.high2sdPorts, summary.high2sd, multiLabel);
        updatePortLine(dom.high4shPorts, summary.high4sh, multiLabel);

        dom.low2sd.textContent = summary.low2sd ? formatNumber(summary.low2sd.rateValue) : "—";
        dom.low2sdMeta.textContent = summary.low2sd ? formatMetricMeta(summary.low2sd) : "—";
        dom.low4sh.textContent = summary.low4sh ? formatNumber(summary.low4sh.rateValue) : "—";
        dom.low4shMeta.textContent = summary.low4sh ? formatMetricMeta(summary.low4sh) : "—";
        updatePortLine(dom.low2sdPorts, summary.low2sd, multiLabel);
        updatePortLine(dom.low4shPorts, summary.low4sh, multiLabel);

        renderPortMetricGroups(rows);
      }

      function summarizeMetricRows(rows) {
        const grouped = { "2SD": [], "4SH": [] };
        rows.forEach((row) => {
          if (grouped[row.rateType]) grouped[row.rateType].push(row);
        });
        return {
          latest2sd: pickLatest(grouped["2SD"]),
          latest4sh: pickLatest(grouped["4SH"]),
          high2sd: pickExtreme(grouped["2SD"], (current, candidate) => candidate.rateValue > current.rateValue),
          high4sh: pickExtreme(grouped["4SH"], (current, candidate) => candidate.rateValue > current.rateValue),
          low2sd: pickExtreme(grouped["2SD"], (current, candidate) => candidate.rateValue < current.rateValue),
          low4sh: pickExtreme(grouped["4SH"], (current, candidate) => candidate.rateValue < current.rateValue),
        };
      }

      function renderPortMetricGroups(rows) {
        if (!dom.portMetricGroups) return;
        dom.portMetricGroups.innerHTML = "";
        if (!state.filters.ports.length || state.filters.ports.length === 1) {
          dom.portMetricGroups.style.display = "none";
          return;
        }
        dom.portMetricGroups.style.display = "grid";
        state.filters.ports.forEach((port) => {
          const subset = rows.filter((row) => row.port === port);
          if (!subset.length) return;
          const summary = summarizeMetricRows(subset);
          const group = document.createElement("div");
          group.className = "metric-group";
          group.innerHTML = `
            <p class="metric-group-title">${port}</p>
            ${buildMetricCardRow(summary)}
          `;
          dom.portMetricGroups.appendChild(group);
        });
        if (!dom.portMetricGroups.children.length) {
          dom.portMetricGroups.style.display = "none";
        }
      }

      function buildMetricCardRow(summary) {
        const cards = [
          ["最新 2SD", summary.latest2sd],
          ["最新 4SH", summary.latest4sh],
          ["最高 2SD", summary.high2sd],
          ["最高 4SH", summary.high4sh],
          ["最低 2SD", summary.low2sd],
          ["最低 4SH", summary.low4sh],
        ];
        return `
          <div class="metrics">
            ${cards
              .map(
                ([label, row]) => `
                  <div class="metric-card">
                    <h3>${label}</h3>
                    <p>${row ? formatNumber(row.rateValue) : "—"}</p>
                    <small>${row ? formatMetricMeta(row) : "—"}</small>
                    <small class="metric-extra">${row ? `港口：${row.port || "—"}` : ""}</small>
                  </div>
                `
              )
              .join("")}
          </div>
        `;
      }

      function updateTable(rows) {
        if (!rows.length) {
          dom.tableBody.innerHTML =
            '<tr><td colspan="5" style="text-align:center;color:#6c757d">筛选无结果</td></tr>';
          return;
        }

        dom.tableBody.innerHTML = rows
          .slice(-40)
          .map(
            (row) => `
            <tr>
              <td>${row.displayLabel || "—"}</td>
              <td>${formatDate(row.filterDate)}</td>
              <td>${row.port}</td>
              <td>${row.rateType}</td>
              <td>${formatNumber(row.rateValue)}</td>
            </tr>`
          )
          .join("");
      }

      function updateRangeChart(rows) {
        const ports = state.filters.ports.length > 1 ? state.filters.ports : [null];
        renderChartStack("range", rows, ports, 8);
      }

      function updateHistoryChart(rows) {
        const ports = state.filters.ports.length > 1 ? state.filters.ports : [null];
        renderChartStack("history", rows, ports, 12);
      }

      function renderChartStack(type, rows, ports, maxTicks) {
        const stackEl = type === "range" ? dom.rangeStack : dom.historyStack;
        if (!stackEl) return;
        destroyCharts(type);
        stackEl.innerHTML = "";
        const sources = ports && ports.length ? ports : [null];
        sources.forEach((port) => {
          const subset = port ? rows.filter((row) => row.port === port) : rows;
          const entries = buildTimelineEntries(subset);
          if (!entries.length) return;
          const labelPrefix = port || formatPortSummary();
          const series = buildAggregatedSeries(entries, port, labelPrefix);
          if (!series.datasets.length) return;
          const panel = document.createElement("div");
          panel.className = "chart-panel";
          const title = document.createElement("p");
          title.className = "chart-panel-title";
          title.textContent = labelPrefix;
          panel.appendChild(title);
          const canvas = document.createElement("canvas");
          panel.appendChild(canvas);
          stackEl.appendChild(panel);
          const chart = createLineChart(canvas, series, { maxTicks, isYearly: false });
          chartRegistry[type].push(chart);
        });
        if (!stackEl.children.length) {
          stackEl.innerHTML = '<div class="chart-empty">暂无可绘制的港口数据</div>';
        }
      }

      function updateTrendTable(allRows) {
        if (!dom.trendTableBody) return;
        if (!allRows.length) {
          dom.trendTableBody.innerHTML =
            '<tr><td colspan="7" class="empty-row">尚无可用数据</td></tr>';
          return;
        }

        // 只显示筛选选中的港口
        const selectedPorts = state.filters.ports.length > 0 ? state.filters.ports : [];
        if (selectedPorts.length === 0) {
          dom.trendTableBody.innerHTML =
            '<tr><td colspan="7" class="empty-row">请先选择港口以查看周度涨跌统计</td></tr>';
          return;
        }

        const portIndex = buildPortWeekIndex(allRows);
        const timeline = buildWeekTimeline(allRows);
        if (timeline.order.length < 2) {
          dom.trendTableBody.innerHTML =
            '<tr><td colspan="7" class="empty-row">周度数据不足，无法计算涨跌</td></tr>';
          return;
        }

        const columns = buildTrendColumns(timeline.order, timeline.info);
        updateTrendHeaders(columns);
        
        // 按照筛选选中的港口顺序显示（保持当前顺序）
        const rowsHtml = selectedPorts
          .map((port) => {
            const weeks = portIndex.get(port);
            if (!weeks) return null;
            return renderTrendRow(port, weeks, columns);
          })
          .filter(Boolean)
          .join("");

        dom.trendTableBody.innerHTML =
          rowsHtml || '<tr><td colspan="7" class="empty-row">选中的港口暂无可用数据</td></tr>';
      }

      function buildPortWeekIndex(rows) {
        const map = new Map();
        rows.forEach((row) => {
          if (!row.filterDate) return;
          const port = row.port || "—";
          if (!map.has(port)) {
            map.set(port, new Map());
          }
          const weeks = map.get(port);
          const key = row.filterDate.getTime();
          if (!weeks.has(key)) {
            weeks.set(key, {
              label: row.weekCode || row.displayLabel || formatDate(row.filterDate),
              range: extractRangeFromRow(row),
              values: { "2SD": null, "4SH": null },
            });
          }
          const weekEntry = weeks.get(key);
          if (!weekEntry.range) {
            weekEntry.range = extractRangeFromRow(row);
          }
          weekEntry.values[row.rateType] = row.rateValue;
        });
        return map;
      }

      function buildWeekTimeline(rows) {
        const info = new Map();
        rows.forEach((row) => {
          if (!row.filterDate) return;
          const key = row.filterDate.getTime();
          if (!info.has(key)) {
            info.set(key, {
              label: row.weekCode || row.displayLabel || formatDate(row.filterDate),
              range: extractRangeFromRow(row),
            });
          } else if (!info.get(key).range) {
            info.get(key).range = extractRangeFromRow(row);
          }
        });
        const order = Array.from(info.keys()).sort((a, b) => b - a);
        return { order, info };
      }

      function buildTrendColumns(order, info) {
        const labelOr = (key, fallback) =>
          typeof key === "number" ? info.get(key)?.label || fallback : fallback;
        const rangeOr = (key) =>
          typeof key === "number" ? info.get(key)?.range || "" : "";
        return [
          { key: order[2], compare: order[3], label: labelOr(order[2], "上上周"), range: rangeOr(order[2]), compareLabel: labelOr(order[3], "") },
          { key: order[1], compare: order[2], label: labelOr(order[1], "上周"), range: rangeOr(order[1]), compareLabel: labelOr(order[2], "") },
          { key: order[0], compare: order[1], label: labelOr(order[0], "本周"), range: rangeOr(order[0]), compareLabel: labelOr(order[1], "") },
        ];
      }

      function updateTrendHeaders(columns) {
        if (!dom.trendHeaders) return;
        const defaults = ["上上周", "上周", "本周"];
        const compareKeys = ["comparePrev2", "comparePrev1", "compareCurrent"];
        ["prev2", "prev1", "current"].forEach((key, index) => {
          const header = dom.trendHeaders[key];
          if (!header) return;
          const col = columns[index];
          let label = col && col.label ? col.label : defaults[index];
          const range = col && col.range ? col.range : "";
          
          // 提取周代码并添加WK前缀
          if (label && label !== defaults[index]) {
            const weekMatch = label.match(/(?:WK)?(\d+)/i);
            if (weekMatch) {
              const weekNum = weekMatch[1];
              label = `WK${weekNum}`;
            } else if (!label.match(/^WK/i)) {
              // 如果label是纯数字，添加WK前缀
              const numMatch = label.match(/^(\d+)$/);
              if (numMatch) {
                label = `WK${numMatch[1]}`;
              }
            }
          }
          
          // 添加"2SD/4SH"后缀
          const suffix = " 2SD/4SH";
          header.innerHTML = range
            ? `<div>${label}${suffix}</div><small>${range}</small>`
            : `${label}${suffix}`;
          
          // 更新对比列的描述
          const compareHeader = dom.trendHeaders[compareKeys[index]];
          if (compareHeader && col && col.compareLabel) {
            // 如果周代码存在，显示"对比WK{周代码}"格式，否则显示默认描述
            const weekCode = col.compareLabel.trim();
            if (weekCode) {
              // 提取周代码（可能是"WK52"、"52"等格式）
              const weekMatch = weekCode.match(/(?:WK)?(\d+)/i);
              if (weekMatch) {
                const weekNum = weekMatch[1];
                compareHeader.textContent = `对比WK${weekNum}`;
              } else {
                // 如果无法提取数字，直接使用原周代码
                compareHeader.textContent = `对比${weekCode}`;
              }
            } else {
              // 如果没有周代码，使用默认描述
              const defaultCompare = ["对比上上上周", "对比上上周", "对比上周"];
              compareHeader.textContent = defaultCompare[index];
            }
          }
        });
      }

      function renderTrendRow(port, weeks, columns) {
        if (!columns.length) return "";
        const cells = columns
          .map((col) => {
            const current =
              col && typeof col.key === "number" ? weeks.get(col.key) : null;
            const compareEntry =
              col && typeof col.compare === "number" ? weeks.get(col.compare) : null;
            return `
              <td>${formatTrendValue(current)}</td>
              <td>${formatTrendChange(current, compareEntry)}</td>
            `;
          })
          .join("");
        return `<tr><td>${port}</td>${cells}</tr>`;
      }

      function formatTrendValue(entry) {
        if (!entry || (!entry.values["2SD"] && !entry.values["4SH"])) return "—";
        const sd = entry.values["2SD"] != null ? formatNumber(entry.values["2SD"]) : "—";
        const sh = entry.values["4SH"] != null ? formatNumber(entry.values["4SH"]) : "—";
        const range = entry.range ? `<small class="trend-range">${entry.range}</small>` : "";
        return `
          <div class="trend-value">
            ${range}
            <span>2SD ${sd}</span>
            <span>4SH ${sh}</span>
          </div>
        `;
      }

      function formatTrendChange(current, previous) {
        if (!current || !previous) return "—";
        const sdLine = buildChangeLine("2SD", current.values["2SD"], previous.values["2SD"]);
        const shLine = buildChangeLine("4SH", current.values["4SH"], previous.values["4SH"]);
        if (!sdLine && !shLine) return "—";
        return [sdLine, shLine].filter(Boolean).join("<br />");
      }

      function buildChangeLine(label, current, previous) {
        if (current == null || previous == null) return "";
        const diff = current - previous;
        if (!diff) {
          return `<span class="trend-change trend-flat">${label} 持平</span>`;
        }
        const pct = previous ? ((diff / previous) * 100).toFixed(2) : "—";
        const cls = diff > 0 ? "trend-up" : "trend-down";
        const sign = diff > 0 ? "↑" : "↓";
        const diffText = formatNumber(Math.abs(diff));
        const pctText = pct === "—" ? "—" : `${Math.abs(pct)}%`;
        return `<span class="trend-change ${cls}">${label} ${sign} ${diffText} (${pctText})</span>`;
      }

      function extractRangeFromRow(row) {
        const meta = {
          startLabel: row.startLabel || "",
          endLabel: row.endLabel || "",
        };
        return formatRange(meta);
      }

      function getActiveYearlyTypes() {
        const active = Object.entries(state.yearlyToggle)
          .filter(([, enabled]) => enabled)
          .map(([type]) => type);
        return active.length ? active : ["4SH"];
      }

      function updateYearlyChart(rows) {
        const stackEl = dom.yearlyStack;
        if (!stackEl) return;
        destroyCharts("yearly");
        stackEl.innerHTML = "";
        const activeTypes = getActiveYearlyTypes();
        const ports =
          state.filters.ports.length > 1
            ? state.filters.ports
            : [state.filters.ports[0] || null];

        ports.forEach((port) => {
          const subset = port ? rows.filter((row) => row.port === port) : rows;
          if (!subset.length) return;
          const labelPrefix = port || formatPortSummary();
          const fullSeries = buildYearlySeries(subset, labelPrefix);
          if (!fullSeries.labels.length) return;

          const panel = document.createElement("div");
          panel.className = "yearly-port-panel";
          const header = document.createElement("div");
          header.className = "yearly-port-header";
          header.textContent = labelPrefix;
          panel.appendChild(header);

          const typeStack = document.createElement("div");
          typeStack.className = "yearly-type-stack";

          activeTypes.forEach((type) => {
            const filtered = {
              labels: fullSeries.labels,
              datasets: fullSeries.datasets.filter((ds) => ds.label.endsWith(`· ${type}`)),
            };
            if (!filtered.datasets.length) return;
            const block = document.createElement("div");
            block.className = "chart-panel";
            const title = document.createElement("p");
            title.className = "chart-panel-title";
            title.textContent = `${type} 历年走势`;
            block.appendChild(title);
            const canvas = document.createElement("canvas");
            block.appendChild(canvas);
            typeStack.appendChild(block);
          const chart = createLineChart(canvas, filtered, { maxTicks: 12, isYearly: true });
            chartRegistry.yearly.push(chart);
          });

          if (!typeStack.children.length) return;
          panel.appendChild(typeStack);
          stackEl.appendChild(panel);
        });

        if (!stackEl.children.length) {
          stackEl.innerHTML = '<div class="chart-empty">暂无可绘制的港口数据</div>';
        }
      }

      function destroyCharts(type) {
        chartRegistry[type].forEach((chart) => chart.destroy());
        chartRegistry[type] = [];
      }

      function createLineChart(canvas, series, { maxTicks, isYearly }) {
        if (typeof window.Chart === "undefined") {
          debugError("Chart.js 尚未加载，无法创建图表");
          return null;
        }
        const ctx = canvas.getContext("2d");
        return new Chart(ctx, {
          type: "line",
          data: {
            labels: series.labels,
            datasets: series.datasets,
          },
          options: {
            responsive: true,
            plugins: {
              legend: {
                display: true,
                position: "top",
                labels: { usePointStyle: true },
              },
              tooltip: {
                mode: "index",
                intersect: false,
                displayColors: false,
                callbacks: isYearly ? createYearlyTooltipCallbacks() : createTooltipCallbacks(),
              },
            },
            interaction: {
              mode: "index",
              intersect: false,
            },
            scales: {
              x: {
                ticks: { autoSkip: true, maxTicksLimit: maxTicks || 8 },
              },
              y: {
                beginAtZero: false,
                ticks: {
                  callback: (value) => value.toLocaleString(),
                },
              },
            },
          },
        });
      }

      function buildTimelineEntries(rows) {
        const map = new Map();
        rows.forEach((row) => {
          const key = formatDate(row.filterDate);
          if (!key) return;
          if (!map.has(key)) {
            map.set(key, {
              sortKey: row.filterDate.getTime(),
              label: row.displayLabel || key,
              ports: new Map(),
            });
          }
          const entry = map.get(key);
          const portKey = row.port || "—";
          if (!entry.ports.has(portKey)) {
            entry.ports.set(portKey, {
              port: row.port || "—",
              meta: createMetaSnapshot(row, entry.label),
              values: { "2SD": null, "4SH": null },
            });
          }
          const portEntry = entry.ports.get(portKey);
          portEntry.values[row.rateType] = row.rateValue;
          portEntry.meta = mergeMetaSnapshot(portEntry.meta, row, entry.label);
        });

        return Array.from(map.values()).sort((a, b) => a.sortKey - b.sortKey);
      }

      function buildAggregatedSeries(entries, lockedPort, labelPrefix) {
        const labels = entries.map((entry) => entry.label);
        const dataset2sd = {
          label: `${labelPrefix || "全部港口"} · 2SD`,
          data: [],
          meta: [],
          borderColor: "#0071e3",
          backgroundColor: "rgba(0, 113, 227, 0.15)",
          tension: 0.35,
          pointRadius: 2.5,
          spanGaps: true,
        };
        const dataset4sh = {
          label: `${labelPrefix || "全部港口"} · 4SH`,
          data: [],
          meta: [],
          borderColor: "#ff3b30",
          backgroundColor: "rgba(255, 59, 48, 0.15)",
          tension: 0.35,
          pointRadius: 2.5,
          spanGaps: true,
        };

        entries.forEach((entry) => {
          const portEntries = Array.from(entry.ports.values());
          const aggregated = aggregateEntry(portEntries, entry.label, lockedPort);
          dataset2sd.data.push(aggregated["2SD"].value);
          dataset2sd.meta.push(aggregated["2SD"].meta);
          dataset4sh.data.push(aggregated["4SH"].value);
          dataset4sh.meta.push(aggregated["4SH"].meta);
        });

        return {
          labels,
          datasets: [dataset2sd, dataset4sh],
        };
      }

      function aggregateEntry(portEntries, label, lockedPort) {
        const result = {
          "2SD": { value: null, meta: null },
          "4SH": { value: null, meta: null },
        };
        ["2SD", "4SH"].forEach((type) => {
          const values = [];
          let metaSource = null;
          portEntries.forEach((entry) => {
            const value = entry.values[type];
            if (typeof value === "number" && !Number.isNaN(value)) {
              if (!lockedPort || entry.port === lockedPort) {
                values.push(value);
                if (!metaSource) metaSource = entry.meta;
              }
            }
          });
          if (!values.length) {
            result[type] = { value: null, meta: null };
          } else {
            const avg = lockedPort ? values[values.length - 1] : values.reduce((a, b) => a + b, 0) / values.length;
            const metaSnapshot = metaSource
              ? finalizeMetaSnapshot(metaSource, label)
              : { displayLabel: label, port: lockedPort || "多港口", startLabel: "", endLabel: "" };
            if (!lockedPort && portEntries.length > 1) {
              metaSnapshot.port = "多港口";
            }
            result[type] = { value: avg, meta: metaSnapshot };
          }
        });
        return result;
      }

      function buildYearlySeries(rows, labelPrefix = "全部港口") {
        if (!rows.length) return { labels: [], datasets: [] };

        const sequence = [];
        const labelMap = {};
        const buckets = {};

        rows.forEach((row) => {
          if (!row.filterDate) return;
          const year = row.filterDate.getFullYear();
          const key = row.weekCode || row.displayLabel || formatDate(row.filterDate);
          if (!key) return;
          if (!labelMap[key]) {
            labelMap[key] = key;
            sequence.push(key);
          }

          if (!buckets[year]) {
            buckets[year] = {
              "2SD": new Map(),
              "4SH": new Map(),
            };
          }
          const slot = buckets[year][row.rateType];
          if (!slot) return;
          if (!slot.has(key)) {
            slot.set(key, {
              value: row.rateValue,
              meta: createMetaSnapshot(row, row.displayLabel || key),
            });
          } else {
            const existing = slot.get(key);
            existing.value = row.rateValue;
            existing.meta = mergeMetaSnapshot(existing.meta, row, row.displayLabel || key);
          }
        });

        const labels = sequence.map((key) => labelMap[key]);
        const years = Object.keys(buckets).sort();
        const datasets = [];

        years.forEach((year, index) => {
          const color = YEAR_COLORS[index % YEAR_COLORS.length];
          ["2SD", "4SH"].forEach((type) => {
            const values = [];
            const metaSeries = [];
            sequence.forEach((key) => {
              const entry = buckets[year][type]?.get(key);
              values.push(entry ? entry.value : null);
              metaSeries.push(entry ? finalizeMetaSnapshot(entry.meta, entry.meta?.displayLabel || labelMap[key]) : null);
            });
            datasets.push({
              label: `${labelPrefix} · ${year} · ${type}`,
              data: values,
              borderColor: color,
              backgroundColor: hexToRgba(color, type === "4SH" ? 0.12 : 0.2),
              borderWidth: 2,
              tension: 0.35,
              spanGaps: true,
              borderDash: type === "4SH" ? [6, 4] : undefined,
              pointRadius: 0,
              meta: metaSeries,
            });
          });
        });

        return { labels, datasets };
      }

      function filterRowsByPorts(rows) {
        if (!state.filters.ports.length) return rows;
        const set = new Set(state.filters.ports);
        return rows.filter((row) => set.has(row.port));
      }

      function pickLatest(list) {
        if (!list || !list.length) return null;
        return list[list.length - 1];
      }

      function pickExtreme(list, compareFn) {
        if (!list || !list.length) return null;
        return list.reduce(
          (best, candidate) => (compareFn(best, candidate) ? candidate : best),
          list[0]
        );
      }

      function formatMetricMeta(row) {
        if (!row) return "—";
        return `${formatDate(row.filterDate)} · ${row.port || "—"}`;
      }


      function updatePortLine(element, row, overridePort) {
        if (!element) return;
        const portLabel = overridePort || (row ? row.port : "");
        const shouldShow = shouldShowPortLine(portLabel);
        element.style.display = shouldShow ? "block" : "none";
        element.textContent = shouldShow ? `港口：${portLabel || "—"}` : "";
      }

      function shouldShowPortLine(portLabel) {
        if (state.filters.ports.length > 1) return true;
        if (!state.filters.ports.length && portLabel && portLabel !== "—") return false;
        return false;
      }

      function formatPortSummary() {
        if (!state.filters.ports.length) return "全部港口";
        if (state.filters.ports.length === 1) return state.filters.ports[0];
        if (state.filters.ports.length <= 3) return state.filters.ports.join(" / ");
        const preview = state.filters.ports.slice(0, 3).join(" / ");
        return `${preview} 等 ${state.filters.ports.length} 个港口`;
      }

      function createMetaSnapshot(row, fallbackLabel) {
        return {
          displayLabel: row.displayLabel || fallbackLabel || "",
          startLabel: row.startLabel || "",
          endLabel: row.endLabel || "",
          ports: new Set(row.port ? [row.port] : []),
        };
      }

      function mergeMetaSnapshot(snapshot, row, fallbackLabel) {
        if (!snapshot) return createMetaSnapshot(row, fallbackLabel);
        if (row.port) snapshot.ports.add(row.port);
        if (!snapshot.startLabel && row.startLabel) snapshot.startLabel = row.startLabel;
        if (!snapshot.endLabel && row.endLabel) snapshot.endLabel = row.endLabel;
        if (!snapshot.displayLabel && (row.displayLabel || fallbackLabel)) {
          snapshot.displayLabel = row.displayLabel || fallbackLabel;
        }
        return snapshot;
      }

      function finalizeMetaSnapshot(snapshot, fallbackLabel) {
        if (!snapshot) return null;
        const ports =
          snapshot.ports && snapshot.ports.size
            ? Array.from(snapshot.ports).join(" / ")
            : "—";
        return {
          displayLabel: snapshot.displayLabel || fallbackLabel || "—",
          startLabel: snapshot.startLabel || "—",
          endLabel: snapshot.endLabel || "—",
          port: ports,
        };
      }

      function coerceDate(value) {
        if (value instanceof Date && !isNaN(value)) return value;
        if (typeof value === "number") {
          return new Date(Math.round((value - 25569) * 86400 * 1000));
        }
        if (typeof value === "string") {
          const normalized = value
            .toString()
            .trim()
            .replace(/\./g, "/")
            .replace(/年|月/g, "/")
            .replace("日", "");
          const parsed = new Date(normalized);
          if (!isNaN(parsed)) return parsed;
        }
        return null;
      }

      function parseNumber(value) {
        if (typeof value === "number" && Number.isFinite(value)) return value;
        if (typeof value === "string") {
          const numeric = parseFloat(value.replace(/[^0-9.-]/g, ""));
          return Number.isFinite(numeric) ? numeric : null;
        }
        return null;
      }

      function formatNumber(value) {
        return value === null || value === undefined
          ? "—"
          : Number(value).toLocaleString(undefined, { maximumFractionDigits: 2 });
      }

      function formatDate(date) {
        if (!date) return "—";
        return date.toISOString().split("T")[0];
      }

      function safeString(value) {
        return value === undefined || value === null ? "" : value.toString().trim();
      }

      function formatCellLabel(cellValue, parsedDate) {
        if (parsedDate) return formatDate(parsedDate);
        const raw = safeString(cellValue);
        return raw || "—";
      }

      function normalizeLabel(value) {
        if (!value || value === "—") return "";
        return value;
      }

      function formatRange(meta) {
        if (!meta) return "";
        const start = normalizeLabel(meta.startLabel);
        const end = normalizeLabel(meta.endLabel);
        if (!start && !end) return "";
        if (!end || end === start) return start;
        return `${start} ~ ${end}`;
      }

      function createTooltipCallbacks() {
        return {
          title() {
            return [];
          },
          beforeBody(items) {
            return buildSharedTooltipBlocks(items);
          },
          label() {
            return null;
          },
          afterBody() {
            return [];
          },
        };
      }

      function buildSharedTooltipBlocks(items) {
        if (!items || !items.length) return [];
        const groups = new Map();
        items.forEach((item) => {
          const meta = getMetaForItem(item);
          const portLabel =
            (meta && meta.port) || extractDatasetPort(item.dataset);
          const key = portLabel || "—";
          if (!groups.has(key)) {
            groups.set(key, {
              meta,
              values: { "2SD": "—", "4SH": "—" },
            });
          }
          const type = extractDatasetType(item.dataset);
          const value =
            item.raw ?? (item.parsed && typeof item.parsed.y === "number" ? item.parsed.y : null);
          groups.get(key).values[type] = formatTooltipValue(value);
          if (!groups.get(key).meta && meta) {
            groups.get(key).meta = meta;
          }
        });

        const lines = [];
        const order = Array.from(groups.keys());
        order.forEach((key, index) => {
          const group = groups.get(key);
          const meta = group.meta || {};
          const weekLabel = meta.displayLabel || (items[0] && items[0].label) || "";
          const firstLine =
            weekLabel + (key && key !== "—" ? ` · ${key}` : key && key === "—" ? "" : "");
          if (firstLine.trim()) lines.push(firstLine.trim());
          const range = formatRange(meta);
          if (range) lines.push(range);
          lines.push(`2SD ${group.values["2SD"] || "—"} / 4SH ${group.values["4SH"] || "—"}`);
          if (index < order.length - 1) {
            lines.push("");
          }
        });
        if (lines.length && lines[lines.length - 1] === "") lines.pop();
        return lines;
      }

      function createYearlyTooltipCallbacks() {
        return {
          title() {
            return [];
          },
          beforeBody(items) {
            return buildYearlyTooltipLines(items);
          },
          label() {
            return null;
          },
          afterBody() {
            return [];
          },
        };
      }

      function buildYearlyTooltipLines(items) {
        if (!items || !items.length) return [];
        const groups = new Map();
        items.forEach((item) => {
          const parsed = parseYearDatasetLabel(item.dataset?.label);
          if (!parsed) return;
          const meta = getMetaForItem(item);
          if (!groups.has(parsed.year)) {
            groups.set(parsed.year, {
              meta,
              value: "—",
            });
          }
          const entry = groups.get(parsed.year);
          if (!entry.meta && meta) entry.meta = meta;
          entry.value = formatTooltipValue(
            item.parsed && typeof item.parsed.y === "number" ? item.parsed.y : item.raw
          );
        });

        const portLabel =
          (items[0] && parseYearDatasetLabel(items[0].dataset?.label)?.port) || "";
        const typeLabel = (items[0] && parseYearDatasetLabel(items[0].dataset?.label)?.type) || "";
        const lines = [];
        Array.from(groups.keys())
          .sort()
          .forEach((year) => {
            const entry = groups.get(year);
            const meta = entry.meta || {};
            const header =
              meta.displayLabel || items[0]?.label || portLabel
                ? `${meta.displayLabel || items[0]?.label || portLabel} · ${year}`
                : `${year}`;
            lines.push(header);
            const range = formatRange(meta);
            if (range) lines.push(range);
            lines.push(`${typeLabel || ""} ${entry.value || "—"}`);
            lines.push("");
          });
        if (lines.length && lines[lines.length - 1] === "") lines.pop();
        return lines;
      }

      function extractDatasetPort(dataset) {
        const parsed = parseYearDatasetLabel(dataset?.label);
        return parsed ? parsed.port : dataset?.label || "";
      }

      function extractDatasetType(dataset) {
        const parsed = parseYearDatasetLabel(dataset?.label);
        if (parsed) return parsed.type;
        if (!dataset || !dataset.label) return "2SD";
        return dataset.label.toUpperCase().includes("4SH") ? "4SH" : "2SD";
      }

      function formatTooltipValue(value) {
        if (value === null || value === undefined || Number.isNaN(value)) return "—";
        return Number(value).toLocaleString(undefined, { maximumFractionDigits: 2 });
      }

      function getMetaForItem(context) {
        if (!context || !context.dataset || !context.dataset.meta) return null;
        return context.dataset.meta[context.dataIndex] || null;
      }

      function hexToRgba(hex, alpha = 1) {
        const cleaned = hex.replace("#", "");
        const bigint = parseInt(cleaned, 16);
        const r = (bigint >> 16) & 255;
        const g = (bigint >> 8) & 255;
        const b = bigint & 255;
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
      }

      function parseYearDatasetLabel(label) {
        if (!label) return null;
        const parts = label.split("·").map((part) => part.trim());
        if (parts.length < 3) return null;
        return {
          port: parts[0],
          year: parts[1],
          type: parts[2],
        };
      }


      // 等待 XLSX 库加载完成后再自动加载文件
      if (typeof window.ensureXlsx === 'function') {
        window.ensureXlsx().then(() => {
          // 使用 loadDefaultExcelFile 从 index.json 加载文件
          if (typeof window.loadDefaultExcelFile === 'function') {
            window.loadDefaultExcelFile('Monitor-Rate-Trends', async (file) => {
              // 模拟文件选择事件，触发文件处理逻辑
              if (dom.fileInput) {
                // 使用 DataTransfer API 设置文件
                const dataTransfer = new DataTransfer();
                dataTransfer.items.add(file);
                dom.fileInput.files = dataTransfer.files;
                
                // 触发 change 事件
                const changeEvent = new Event('change', { bubbles: true });
                dom.fileInput.dispatchEvent(changeEvent);
                
                if (typeof window.debugLog === 'function') {
                  window.debugLog(`[Monitor-Rate-Trends] 自动加载文件: ${file.name}`);
                }
              }
            });
          }
        });
      } else {
        // 如果 ensureXlsx 不存在，等待一段时间后尝试加载
        setTimeout(() => {
          if (typeof window.loadDefaultExcelFile === 'function') {
            window.loadDefaultExcelFile('Monitor-Rate-Trends', async (file) => {
              if (dom.fileInput) {
                const dataTransfer = new DataTransfer();
                dataTransfer.items.add(file);
                dom.fileInput.files = dataTransfer.files;
                const changeEvent = new Event('change', { bubbles: true });
                dom.fileInput.dispatchEvent(changeEvent);
                if (typeof window.debugLog === 'function') {
                  window.debugLog(`[Monitor-Rate-Trends] 自动加载文件: ${file.name}`);
                }
              }
            });
          }
        }, 1000);
      }

    </script>
  </body>
</html>

