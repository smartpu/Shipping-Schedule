<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Monitor Â· å¥èº«è®°å½•é¢æ¿</title>
    <link rel="stylesheet" href="vendor/auth.css">
    <link rel="stylesheet" href="vendor/common-styles.css">
    <link rel="stylesheet" href="vendor/monitor-styles.css">
    <script src="vendor/lib-loader.js"></script>
    <script src="vendor/common-utils.js"></script>
    <script src="vendor/date-utils.js"></script>
    <script src="vendor/pdf-utils.js"></script>
    <script src="vendor/error-handler.js"></script>
    <script src="vendor/debug-utils.js"></script>
    <style>
      /* é¡µé¢ç‰¹å®šæ ·å¼ï¼ˆä¿ç•™ä¸å…¬å…±æ ·å¼ä¸åŒçš„éƒ¨åˆ†ï¼‰ */
      /* æ³¨æ„ï¼šview-controlsã€legend-containerã€chart-container ç­‰æ ·å¼å·²ç§»è‡³ vendor/monitor-styles.css */
    </style>
  </head>
  <body data-page="Monitor-Workouts.html">
    <!-- ç”¨æˆ·éªŒè¯æ¨¡æ€æ¡† -->
    <div id="authOverlay" class="auth-overlay">
      <div class="auth-modal">
        <h2>ğŸ” è®¿é—®éªŒè¯</h2>
        <p>ä¸ºäº†äº†è§£å·¥å…·ä½¿ç”¨æƒ…å†µï¼Œè¯·å¡«å†™ä»¥ä¸‹ä¿¡æ¯</p>
        <form id="authForm">
          <div class="auth-form-group">
            <label for="userName">å§“å *</label>
            <input type="text" id="userName" name="userName" placeholder="è¯·è¾“å…¥æ‚¨çš„å§“å" required autocomplete="name">
            <div class="auth-error" id="nameError">è¯·è¾“å…¥æ‚¨çš„å§“å</div>
          </div>
          <div class="auth-form-group">
            <label for="userPhone">æ‰‹æœºå· *</label>
            <input type="tel" id="userPhone" name="userPhone" placeholder="è¯·è¾“å…¥æ‚¨çš„æ‰‹æœºå·" required autocomplete="tel">
            <div class="auth-error" id="phoneError">è¯·è¾“å…¥æœ‰æ•ˆçš„æ‰‹æœºå·</div>
          </div>
          <div class="auth-form-group">
            <label for="userEmail">é‚®ç®± *</label>
            <input type="email" id="userEmail" name="userEmail" placeholder="è¯·è¾“å…¥æ‚¨çš„é‚®ç®±åœ°å€" required autocomplete="email">
            <div class="auth-error" id="emailError">è¯·è¾“å…¥æœ‰æ•ˆçš„é‚®ç®±åœ°å€</div>
          </div>
          <button type="submit" class="auth-submit-btn">ç¡®è®¤å¹¶ç»§ç»­</button>
        </form>
      </div>
    </div>

    <div class="container">
      <div class="header">
        <a href="index.html?tab=monitor" class="back-home-btn">â† è¿”å›é¦–é¡µ</a>
        <a href="Monitor-Workouts-README.html" class="readme-btn">ä½¿ç”¨è¯´æ˜ â†’</a>
        <h1>Monitor Â· å¥èº«è®°å½•é¢æ¿</h1>
        <p>å¯è§†åŒ–æ‚¨çš„è‹¹æœå¥èº«è®°å½•æ•°æ®ï¼Œè¿½è¸ªè¿åŠ¨è·ç¦»å’Œæ—¶é—´è¶‹åŠ¿</p>
      </div>

      <div class="content">
        <section class="panel">
          <div class="upload-area">
            <label class="upload-card" for="fileInput">
              <svg
                width="36"
                height="36"
                viewBox="0 0 36 36"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
              >
                <rect
                  x="4"
                  y="4"
                  width="28"
                  height="28"
                  rx="8"
                  fill="url(#grad)"
                ></rect>
                <path
                  d="M18 11v14M11 18h14"
                  stroke="#fff"
                  stroke-width="2.2"
                  stroke-linecap="round"
                ></path>
                <defs>
                  <linearGradient
                    id="grad"
                    x1="4"
                    y1="4"
                    x2="32"
                    y2="32"
                    gradientUnits="userSpaceOnUse"
                  >
                    <stop stop-color="#0071e3" />
                    <stop offset="1" stop-color="#54a4ff" />
                  </linearGradient>
                </defs>
              </svg>
              <span>
                <strong>è½½å…¥ CSV</strong><br />
                <small>æ”¯æŒ .csvï¼Œæ•°æ®ä»…åœ¨æœ¬åœ°æµè§ˆå™¨è§£æ</small>
              </span>
              <input id="fileInput" type="file" accept=".csv" />
            </label>
            <div class="status-card">
              <span class="status-label">æ•°æ®çŠ¶æ€</span>
              <span class="status-value" id="statusInfo">å°šæœªè½½å…¥æ•°æ®</span>
              <small class="status-detail" id="status-detail" style="display: none">â€”</small>
            </div>
          </div>
        </section>

        <section class="panel hidden" id="chartSection">
          <div class="view-controls">
            <div style="flex: 1;">
              <h3 style="margin: 0; color: #1f2d3d;">å¥èº«è®°å½•è¶‹åŠ¿</h3>
            </div>
            <button class="view-btn" data-view="day">æ—¥è§†å›¾</button>
            <button class="view-btn active" data-view="month">æœˆè§†å›¾</button>
            <button class="view-btn" data-view="year">å¹´è§†å›¾</button>
            <button class="file-btn" id="exportPdfBtn" title="å¯¼å‡ºæ•´é¡µ PDF" style="margin-left: 12px;">
              ğŸ“„ å¯¼å‡º PDF
            </button>
          </div>

          <div class="chart-container">
            <canvas id="trendChart"></canvas>
          </div>

          <div class="legend-container" id="legendContainer"></div>
        </section>
      </div>
    </div>

    <!-- ä½¿ç”¨ Gist å­˜å‚¨ç³»ç»Ÿï¼ˆç”¨æˆ·ç™½åå• + è®¿é—®è®°å½•ï¼‰ -->
    <script src="vendor/auth-gist.js"></script>
    <script>
      (function() {
        'use strict';

        // é”™è¯¯å¤„ç†å·²ç»Ÿä¸€åˆ° vendor/error-handler.js
        // ErrorType å’Œ showError å‡½æ•°å·²ä» error-handler.js åŠ è½½

        const fileInput = document.getElementById('fileInput');
        const statusInfo = document.getElementById('statusInfo');
        const chartSection = document.getElementById('chartSection');
        const legendContainer = document.getElementById('legendContainer');
        const viewButtons = document.querySelectorAll('.view-btn');

        let workoutData = [];
        let workoutChart = null;
        let currentView = 'month'; // 'day', 'month', 'year' - é»˜è®¤æœˆè§†å›¾

        /**
         * ä»æ—¥æœŸå­—ç¬¦ä¸²ä¸­æå– YYYY-MM-DD æ ¼å¼çš„æ—¥æœŸ
         * @param {string} dateStr - æ—¥æœŸå­—ç¬¦ä¸²ï¼Œæ ¼å¼å¦‚ "2022-12-07 14:11:52 - 2022-12-07 14:25:17"
         * @returns {string} YYYY-MM-DD æ ¼å¼çš„æ—¥æœŸ
         */
        function extractDate(dateStr) {
          if (!dateStr) return '';
          // æå–å‰é¢çš„æ—¥æœŸéƒ¨åˆ†ï¼ˆYYYY-MM-DDï¼‰
          const match = String(dateStr).match(/^(\d{4}-\d{2}-\d{2})/);
          return match ? match[1] : '';
        }

        /**
         * å°†ç§’æ•°è½¬æ¢ä¸ºåˆ†:ç§’æ ¼å¼
         * @param {number} seconds - ç§’æ•°
         * @returns {string} åˆ†:ç§’æ ¼å¼ï¼Œå¦‚ "12:34"
         */
        function formatDuration(seconds) {
          if (!seconds || isNaN(seconds)) return '0:00';
          const totalSeconds = Math.round(Number(seconds));
          const mins = Math.floor(totalSeconds / 60);
          const secs = totalSeconds % 60;
          return `${mins}:${String(secs).padStart(2, '0')}`;
        }

        /**
         * å°†åˆ†:ç§’æ ¼å¼è½¬æ¢ä¸ºç§’æ•°ï¼ˆç”¨äºå›¾è¡¨æ˜¾ç¤ºï¼‰
         * @param {string} durationStr - åˆ†:ç§’æ ¼å¼ï¼Œå¦‚ "12:34"
         * @returns {number} æ€»ç§’æ•°
         */
        function parseDurationToSeconds(durationStr) {
          if (!durationStr) return 0;
          const parts = String(durationStr).split(':');
          if (parts.length !== 2) return 0;
          const mins = parseInt(parts[0], 10) || 0;
          const secs = parseInt(parts[1], 10) || 0;
          return mins * 60 + secs;
        }

        /**
         * è§£æ CSV è¡Œï¼ˆå¤„ç†å¼•å·å’Œé€—å·ï¼‰
         * @param {string} line - CSV è¡Œæ–‡æœ¬
         * @returns {Array} è§£æåçš„å€¼æ•°ç»„
         */
        function parseCSVLine(line) {
          const values = [];
          let current = '';
          let inQuotes = false;
          
          for (let i = 0; i < line.length; i++) {
            const char = line[i];
            const nextChar = line[i + 1];
            
            if (char === '"') {
              if (inQuotes && nextChar === '"') {
                // è½¬ä¹‰çš„å¼•å·
                current += '"';
                i++; // è·³è¿‡ä¸‹ä¸€ä¸ªå¼•å·
              } else {
                // åˆ‡æ¢å¼•å·çŠ¶æ€
                inQuotes = !inQuotes;
              }
            } else if (char === ',' && !inQuotes) {
              // å­—æ®µåˆ†éš”ç¬¦
              values.push(current.trim());
              current = '';
            } else {
              current += char;
            }
          }
          
          // æ·»åŠ æœ€åä¸€ä¸ªå­—æ®µ
          values.push(current.trim());
          
          return values;
        }

        /**
         * è§£æ CSV æ–‡ä»¶
         * @param {string} csvText - CSV æ–‡æœ¬å†…å®¹
         * @returns {Array} è§£æåçš„æ•°æ®æ•°ç»„
         */
        function parseCSV(csvText) {
          const lines = csvText.split(/\r?\n/).filter(line => line.trim());
          if (lines.length < 2) {
            throw new Error('CSV æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®ï¼Œè‡³å°‘éœ€è¦æ ‡é¢˜è¡Œå’Œä¸€è¡Œæ•°æ®');
          }

          // è§£ææ ‡é¢˜è¡Œ
          const headers = parseCSVLine(lines[0]);
          const dateIndex = headers.findIndex(h => h.toLowerCase().includes('date'));
          // Distanceåˆ—ï¼šæŸ¥æ‰¾åŒ…å«"distance"å’Œ"km"çš„åˆ—
          let distanceIndex = headers.findIndex(h => {
            const lower = h.toLowerCase();
            return lower.includes('distance') && lower.includes('km');
          });
          // å¦‚æœæ‰¾ä¸åˆ°ï¼Œå°è¯•åªåŒ…å«"distance"çš„åˆ—
          if (distanceIndex === -1) {
            distanceIndex = headers.findIndex(h => h.toLowerCase().includes('distance'));
          }
          // Durationåˆ—ï¼šæŸ¥æ‰¾åŒ…å«"duration"å’Œ"s"çš„åˆ—
          let durationIndex = headers.findIndex(h => {
            const lower = h.toLowerCase();
            return lower.includes('duration') && lower.includes('s');
          });
          // å¦‚æœæ‰¾ä¸åˆ°ï¼Œå°è¯•åªåŒ…å«"duration"çš„åˆ—
          if (durationIndex === -1) {
            durationIndex = headers.findIndex(h => h.toLowerCase().includes('duration'));
          }

          if (dateIndex === -1 || distanceIndex === -1 || durationIndex === -1) {
            throw new Error(`CSV æ–‡ä»¶ç¼ºå°‘å¿…è¦çš„åˆ—ï¼šDate(${dateIndex}), Distance(${distanceIndex}), Duration(${durationIndex})`);
          }

          // è§£ææ•°æ®è¡Œ
          const data = [];
          for (let i = 1; i < lines.length; i++) {
            const line = lines[i].trim();
            if (!line) continue;

            const values = parseCSVLine(line);

            if (values.length < Math.max(dateIndex, distanceIndex, durationIndex) + 1) {
              continue; // è·³è¿‡ä¸å®Œæ•´çš„è¡Œ
            }

            const dateStr = extractDate(values[dateIndex] || '');
            if (!dateStr) continue; // è·³è¿‡æ²¡æœ‰æœ‰æ•ˆæ—¥æœŸçš„è¡Œ

            const distanceKm = parseFloat(values[distanceIndex] || '0') || 0;
            const distanceM = Math.round(distanceKm * 1000); // è½¬æ¢ä¸ºç±³

            const durationSeconds = parseFloat(values[durationIndex] || '0') || 0;
            const durationFormatted = formatDuration(durationSeconds);

            // è§£ææ—¥æœŸ
            const dateParts = dateStr.split('-');
            const date = new Date(parseInt(dateParts[0]), parseInt(dateParts[1]) - 1, parseInt(dateParts[2]));

            if (isNaN(date.getTime())) {
              continue; // è·³è¿‡æ— æ•ˆæ—¥æœŸ
            }

            data.push({
              date: date,
              dateStr: dateStr,
              distance: distanceM, // ç±³
              duration: durationSeconds, // ç§’ï¼ˆç”¨äºè®¡ç®—ï¼‰
              durationFormatted: durationFormatted // åˆ†:ç§’æ ¼å¼ï¼ˆç”¨äºæ˜¾ç¤ºï¼‰
            });
          }

          // æŒ‰æ—¥æœŸæ’åº
          data.sort((a, b) => a.date.getTime() - b.date.getTime());

          return data;
        }

        /**
         * æŒ‰è§†å›¾ç±»å‹èšåˆæ•°æ®
         * @param {Array} data - åŸå§‹æ•°æ®
         * @param {string} viewType - è§†å›¾ç±»å‹ï¼š'day', 'month', 'year'
         * @returns {Array} èšåˆåçš„æ•°æ®
         */
        function aggregateData(data, viewType) {
          if (viewType === 'day') {
            // æ—¥è§†å›¾ï¼šæŒ‰æ—¥æœŸèšåˆï¼ˆåŒä¸€å¤©çš„æ•°æ®ç´¯åŠ ï¼‰
            const dayMap = new Map();
            data.forEach(item => {
              const key = item.dateStr;
              if (!dayMap.has(key)) {
                dayMap.set(key, {
                  date: item.date,
                  dateStr: item.dateStr,
                  label: item.dateStr,
                  distance: 0,
                  duration: 0
                });
              }
              const entry = dayMap.get(key);
              entry.distance += item.distance;
              entry.duration += item.duration;
            });
            return Array.from(dayMap.values()).map(item => ({
              ...item,
              durationFormatted: formatDuration(item.duration)
            }));
          } else if (viewType === 'month') {
            // æœˆè§†å›¾ï¼šæŒ‰å¹´æœˆèšåˆ
            const monthMap = new Map();
            data.forEach(item => {
              const year = item.date.getFullYear();
              const month = item.date.getMonth() + 1;
              const key = `${year}-${String(month).padStart(2, '0')}`;
              const label = `${year}/${String(month).padStart(2, '0')}`;
              
              if (!monthMap.has(key)) {
                monthMap.set(key, {
                  date: new Date(year, month - 1, 1),
                  dateStr: key,
                  label: label,
                  distance: 0,
                  duration: 0
                });
              }
              const entry = monthMap.get(key);
              entry.distance += item.distance;
              entry.duration += item.duration;
            });
            return Array.from(monthMap.values())
              .sort((a, b) => a.date.getTime() - b.date.getTime())
              .map(item => ({
                ...item,
                durationFormatted: formatDuration(item.duration)
              }));
          } else if (viewType === 'year') {
            // å¹´è§†å›¾ï¼šæŒ‰å¹´èšåˆ
            const yearMap = new Map();
            data.forEach(item => {
              const year = item.date.getFullYear();
              const key = String(year);
              
              if (!yearMap.has(key)) {
                yearMap.set(key, {
                  date: new Date(year, 0, 1),
                  dateStr: key,
                  label: key,
                  distance: 0,
                  duration: 0
                });
              }
              const entry = yearMap.get(key);
              entry.distance += item.distance;
              entry.duration += item.duration;
            });
            return Array.from(yearMap.values())
              .sort((a, b) => a.date.getTime() - b.date.getTime())
              .map(item => ({
                ...item,
                durationFormatted: formatDuration(item.duration)
              }));
          }
          return [];
        }

        /**
         * æ›´æ–°å›¾è¡¨
         */
        function updateChart() {
          if (!workoutData.length) return;

          const aggregatedData = aggregateData(workoutData, currentView);
          if (!aggregatedData.length) return;

          const labels = aggregatedData.map(item => item.label);
          const distanceData = aggregatedData.map(item => item.distance);
          const durationData = aggregatedData.map(item => item.duration); // ä½¿ç”¨ç§’æ•°ç”¨äºå›¾è¡¨

          // é”€æ¯æ—§å›¾è¡¨
          if (workoutChart) {
            workoutChart.destroy();
          }

          // åˆ›å»ºæ–°å›¾è¡¨ï¼ˆæ··åˆå›¾è¡¨ï¼šæŸ±çŠ¶å›¾+æ›²çº¿å›¾ï¼‰
          const ctx = document.getElementById('trendChart').getContext('2d');
          workoutChart = new Chart(ctx, {
            type: 'bar',
            data: {
              labels: labels,
              datasets: [
                {
                  label: 'è·ç¦»ï¼ˆç±³ï¼‰',
                  data: distanceData,
                  type: 'bar',
                  backgroundColor: 'rgba(102, 126, 234, 0.6)',
                  borderColor: '#667eea',
                  borderWidth: 2,
                  yAxisID: 'y',
                  order: 2 // æŸ±çŠ¶å›¾åœ¨åé¢
                },
                {
                  label: 'è®­ç»ƒæ—¶é—´',
                  data: durationData,
                  type: 'line',
                  borderColor: '#ff6b6b',
                  backgroundColor: 'rgba(255, 107, 107, 0.1)',
                  borderWidth: 3,
                  fill: false,
                  tension: 0.4,
                  yAxisID: 'y1',
                  order: 1, // æ›²çº¿å›¾åœ¨å‰é¢
                  pointRadius: 4,
                  pointHoverRadius: 6
                }
              ]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              interaction: {
                mode: 'index',
                intersect: false
              },
              plugins: {
                legend: {
                  display: false // ä½¿ç”¨è‡ªå®šä¹‰å›¾ä¾‹
                },
                tooltip: {
                  mode: 'index',
                  intersect: false,
                  callbacks: {
                    label: function(context) {
                      const datasetLabel = context.dataset.label || '';
                      const value = context.parsed.y;
                      if (datasetLabel.includes('è·ç¦»')) {
                        return `${datasetLabel}: ${value.toLocaleString()} ç±³`;
                      } else if (datasetLabel.includes('æ—¶é—´')) {
                        const formatted = formatDuration(value);
                        return `${datasetLabel}: ${formatted} (${value} ç§’)`;
                      }
                      return `${datasetLabel}: ${value}`;
                    }
                  }
                }
              },
              scales: {
                x: {
                  title: {
                    display: true,
                    text: currentView === 'day' ? 'æ—¥æœŸ' : currentView === 'month' ? 'æœˆä»½' : 'å¹´ä»½'
                  },
                  ticks: {
                    maxRotation: 45,
                    minRotation: 45
                  }
                },
                y: {
                  type: 'linear',
                  position: 'left',
                  title: {
                    display: true,
                    text: 'è·ç¦»ï¼ˆç±³ï¼‰'
                  },
                  beginAtZero: true,
                  ticks: {
                    callback: function(value) {
                      return value.toLocaleString() + ' ç±³';
                    }
                  }
                },
                y1: {
                  type: 'linear',
                  position: 'right',
                  title: {
                    display: true,
                    text: 'è®­ç»ƒæ—¶é—´ï¼ˆç§’ï¼‰'
                  },
                  beginAtZero: true,
                  grid: {
                    drawOnChartArea: false
                  },
                  ticks: {
                    callback: function(value) {
                      return formatDuration(value);
                    }
                  }
                }
              }
            }
          });

          // æ›´æ–°å›¾ä¾‹
          updateLegend();
        }

        /**
         * æ›´æ–°å›¾ä¾‹
         */
        function updateLegend() {
          legendContainer.innerHTML = '';
          
          const legends = [
            { label: 'è·ç¦»ï¼ˆç±³ï¼‰', color: '#667eea' },
            { label: 'è®­ç»ƒæ—¶é—´', color: '#ff6b6b' }
          ];

          legends.forEach(legend => {
            const legendItem = document.createElement('div');
            legendItem.className = 'legend-item';
            legendItem.innerHTML = `
              <div class="legend-color" style="background-color: ${legend.color};"></div>
              <span>${legend.label}</span>
            `;
            legendContainer.appendChild(legendItem);
          });
        }

        /**
         * å¤„ç†æ–‡ä»¶è½½å…¥
         */
        fileInput.addEventListener('change', async (e) => {
          const file = e.target.files[0];
          if (!file) return;

          try {
            statusInfo.textContent = 'è§£æä¸­...';
            const statusDetail = document.getElementById('status-detail');
            if (statusDetail) statusDetail.style.display = 'none';
            
            const text = await file.text();
            const data = parseCSV(text);
            
            if (!data.length) {
              showError(ErrorType.FILE_LOAD, 'FILE_EMPTY');
              statusInfo.textContent = 'æ–‡ä»¶ä¸ºç©º';
              if (statusDetail) {
                statusDetail.textContent = 'æ–‡ä»¶ä¸­æ²¡æœ‰æœ‰æ•ˆæ•°æ®';
                statusDetail.style.display = 'block';
              }
              return;
            }

            workoutData = data;
            statusInfo.textContent = `å·²åŠ è½½ ${data.length} æ¡è®°å½•`;
            if (statusDetail) statusDetail.style.display = 'none';
            chartSection.classList.remove('hidden');
            updateChart();
          } catch (error) {
            showError(ErrorType.FILE_LOAD, 'FILE_READ_FAILED', { message: error.message }, error);
            statusInfo.textContent = 'è§£æå¤±è´¥';
            const statusDetail = document.getElementById('status-detail');
            if (statusDetail) {
              statusDetail.textContent = error.message || 'æ–‡ä»¶è¯»å–å¤±è´¥';
              statusDetail.style.display = 'block';
            }
            debugError('è¯»å–æ–‡ä»¶å¤±è´¥:', error);
          }
        });

        /**
         * è§†å›¾åˆ‡æ¢
         */
        viewButtons.forEach(btn => {
          btn.addEventListener('click', () => {
            const view = btn.dataset.view;
            if (view === currentView) return;

            currentView = view;
            viewButtons.forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            updateChart();
          });
        });

        /**
         * å¯¼å‡ºæ•´é¡µ PDFï¼ˆä½¿ç”¨ vendor/pdf-utils.jsï¼‰
         */
        async function exportPageToPdf() {
          const exportBtn = document.getElementById('exportPdfBtn');
          if (!exportBtn) return;
          
          try {
            exportBtn.disabled = true;
            exportBtn.textContent = 'æ­£åœ¨å¯¼å‡º...';
            
            // ç”Ÿæˆæ–‡ä»¶åï¼šå¥èº«è®°å½•æŠ¥å‘Š_å¹´æœˆæ—¥.pdf
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const fileName = `å¥èº«è®°å½•æŠ¥å‘Š_${year}${month}${day}`;
            
            // ç­‰å¾…ä¸€å°æ®µæ—¶é—´ç¡®ä¿å›¾è¡¨å®Œå…¨æ¸²æŸ“
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // å¦‚æœå›¾è¡¨å­˜åœ¨ï¼Œå…ˆå°†canvasè½¬æ¢ä¸ºå›¾ç‰‡å¹¶æ›¿æ¢åŸcanvas
            let originalCanvas = null;
            let chartImage = null;
            let chartImgElement = null;
            
            if (workoutChart && workoutChart.canvas) {
              try {
                originalCanvas = workoutChart.canvas;
                // ä½¿ç”¨Chart.jsçš„å†…ç½®æ–¹æ³•è·å–base64å›¾ç‰‡
                chartImage = workoutChart.toBase64Image('image/png', 1.0);
                
                // åˆ›å»ºimgå…ƒç´ æ›¿æ¢canvas
                chartImgElement = document.createElement('img');
                chartImgElement.src = chartImage;
                chartImgElement.style.width = originalCanvas.offsetWidth + 'px';
                chartImgElement.style.height = originalCanvas.offsetHeight + 'px';
                chartImgElement.style.display = 'block';
                chartImgElement.id = 'trendChart';
                
                // ä¸´æ—¶æ›¿æ¢canvasä¸ºimg
                originalCanvas.parentNode.insertBefore(chartImgElement, originalCanvas);
                originalCanvas.style.display = 'none';
              } catch (error) {
                debugError('è½¬æ¢å›¾è¡¨ä¸ºå›¾ç‰‡å¤±è´¥:', error);
              }
            }
            
            // ç­‰å¾…å›¾ç‰‡åŠ è½½å®Œæˆ
            if (chartImgElement) {
              await new Promise((resolve) => {
                if (chartImgElement.complete) {
                  resolve();
                } else {
                  chartImgElement.onload = resolve;
                  chartImgElement.onerror = resolve; // å³ä½¿å¤±è´¥ä¹Ÿç»§ç»­
                  setTimeout(resolve, 1000); // è¶…æ—¶ä¿æŠ¤
                }
              });
            }
            
            // åˆ›å»ºä¸€ä¸ªåŒ…è£…å™¨åŒ…å«containerå’Œfooter
            const wrapper = document.createElement('div');
            wrapper.style.position = 'relative';
            wrapper.style.width = '100%';
            wrapper.style.backgroundColor = '#ffffff';
            
            const container = document.querySelector('.container');
            const footer = document.querySelector('.page-footer');
            
            if (container) {
              wrapper.appendChild(container.cloneNode(true));
            }
            if (footer) {
              wrapper.appendChild(footer.cloneNode(true));
            }
            
            // ä¸´æ—¶æ·»åŠ åˆ°bodyï¼ˆå¯è§ä½ç½®ï¼‰
            wrapper.style.position = 'absolute';
            wrapper.style.top = '0';
            wrapper.style.left = '0';
            wrapper.style.zIndex = '9999';
            document.body.appendChild(wrapper);
            
            try {
              await exportToPdf(wrapper, {
                fileName: fileName,
                onStart: () => {
                  // å·²åœ¨å¤–éƒ¨è®¾ç½®
                },
                onComplete: () => {
                  exportBtn.textContent = 'ğŸ“„ å¯¼å‡º PDF';
                  exportBtn.disabled = false;
                },
                onError: (error) => {
                  debugError('å¯¼å‡ºPDFå¤±è´¥:', error);
                  showError(ErrorType.SYSTEM_ERROR, 'PDF_EXPORT_FAILED', { 
                    message: error.message || String(error) 
                  }, error);
                  exportBtn.textContent = 'ğŸ“„ å¯¼å‡º PDF';
                  exportBtn.disabled = false;
                }
              });
            } finally {
              // æ¢å¤åŸå§‹canvas
              if (originalCanvas && chartImgElement) {
                chartImgElement.remove();
                originalCanvas.style.display = '';
              }
              
              // æ¸…ç†åŒ…è£…å™¨
              if (wrapper.parentNode) {
                wrapper.parentNode.removeChild(wrapper);
              }
            }
          } catch (error) {
            debugError('å¯¼å‡ºPDFå¤±è´¥:', error);
            showError(ErrorType.SYSTEM_ERROR, 'PDF_EXPORT_FAILED', { 
              message: error.message || String(error) 
            }, error);
            if (exportBtn) {
              exportBtn.textContent = 'ğŸ“„ å¯¼å‡º PDF';
              exportBtn.disabled = false;
            }
          }
        }

        document.getElementById('exportPdfBtn')?.addEventListener('click', exportPageToPdf);

        // è‡ªåŠ¨åŠ è½½ Monitor-Workouts.csv æ–‡ä»¶
        async function loadDefaultCsvFile() {
          // æ£€æŸ¥æ˜¯å¦åœ¨æœ¬åœ°æ–‡ä»¶ç³»ç»Ÿï¼ˆfile://åè®®ï¼‰ï¼Œå¦‚æœæ˜¯åˆ™è·³è¿‡è‡ªåŠ¨åŠ è½½
          if (window.location.protocol === 'file:') {
            console.log('æœ¬åœ°æ–‡ä»¶ç³»ç»Ÿç¯å¢ƒï¼Œè·³è¿‡è‡ªåŠ¨åŠ è½½ï¼Œè¯·æ‰‹åŠ¨é€‰æ‹©æ–‡ä»¶');
            return;
          }

          try {
            // ä» index.json è¯»å–æ–‡ä»¶è·¯å¾„é…ç½®
            let csvFileName = null;
            try {
              const configResponse = await fetch('Data/index.json');
              if (configResponse.ok) {
                const config = await configResponse.json();
                if (config.files && config.files['Monitor-Workouts']) {
                  csvFileName = config.files['Monitor-Workouts'];
                }
              }
            } catch (e) {
              console.log('æ— æ³•è¯»å–é…ç½®æ–‡ä»¶ï¼Œè¯·æ‰‹åŠ¨é€‰æ‹©æ–‡ä»¶');
              return;
            }

            if (!csvFileName) {
              console.log('é…ç½®æ–‡ä»¶ä¸­æœªæ‰¾åˆ°æ–‡ä»¶è·¯å¾„ï¼Œè¯·æ‰‹åŠ¨é€‰æ‹©æ–‡ä»¶');
              return;
            }

            const response = await fetch(`Data/${csvFileName}`);
            if (!response.ok) {
              console.log('é»˜è®¤ CSV æ–‡ä»¶ä¸å­˜åœ¨ï¼Œç­‰å¾…ç”¨æˆ·æ‰‹åŠ¨é€‰æ‹©');
              return;
            }
            const blob = await response.blob();
            const file = new File([blob], csvFileName, { type: 'text/csv' });
            
            // æ¨¡æ‹Ÿæ–‡ä»¶é€‰æ‹©äº‹ä»¶ï¼Œè§¦å‘æ–‡ä»¶å¤„ç†
            const dataTransfer = new DataTransfer();
            dataTransfer.items.add(file);
            fileInput.files = dataTransfer.files;
            
            // è§¦å‘ change äº‹ä»¶
            const changeEvent = new Event('change', { bubbles: true });
            fileInput.dispatchEvent(changeEvent);
          } catch (error) {
            // å¦‚æœæ˜¯CORSé”™è¯¯ï¼Œé™é»˜å¤„ç†ï¼ˆæœ¬åœ°æ–‡ä»¶ç³»ç»Ÿç¯å¢ƒï¼‰
            if (error.name === 'TypeError' && error.message.includes('fetch')) {
              console.log('æœ¬åœ°æ–‡ä»¶ç³»ç»Ÿç¯å¢ƒï¼Œæ— æ³•è‡ªåŠ¨åŠ è½½ï¼Œè¯·æ‰‹åŠ¨é€‰æ‹©æ–‡ä»¶');
            } else {
              console.log('è‡ªåŠ¨åŠ è½½ CSV æ–‡ä»¶å¤±è´¥ï¼Œç­‰å¾…ç”¨æˆ·æ‰‹åŠ¨é€‰æ‹©:', error);
            }
          }
        }

        // é¡µé¢åŠ è½½å®Œæˆåå°è¯•è‡ªåŠ¨åŠ è½½æ–‡ä»¶
        window.addEventListener('DOMContentLoaded', async () => {
          // ç­‰å¾…ä¸€å°æ®µæ—¶é—´ï¼Œç¡®ä¿é¡µé¢å®Œå…¨åŠ è½½
          setTimeout(() => {
            loadDefaultCsvFile();
          }, 500);
        });
      })();
    </script>
    <div class="page-footer">
      <h2>Monitor Â· å¥èº«è®°å½•é¢æ¿ä½¿ç”¨å£°æ˜</h2>
      <p>æœ¬å·¥å…·ç”¨äºå¯è§†åŒ–æ‚¨çš„è‹¹æœå¥èº«è®°å½•æ•°æ®ï¼Œè§£æç»“æœä»…ä¾›ä¸ªäººä½¿ç”¨ï¼Œå¸®åŠ©æ‚¨è¿½è¸ªè¿åŠ¨è·ç¦»å’Œæ—¶é—´è¶‹åŠ¿ã€‚</p>
      <p>æ‰€æœ‰æ•°æ®ä»…åœ¨æœ¬åœ°æµè§ˆå™¨è§£æï¼Œä¸ä¼šä¸Šä¼ è‡³ä»»ä½•æœåŠ¡å™¨ï¼Œè¯·æ”¾å¿ƒä½¿ç”¨ã€‚</p>
    </div>
  </body>
</html>

